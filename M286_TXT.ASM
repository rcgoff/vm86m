;обработчик прерывания int 06h (неизвестная команда)
;оказались в стеке, адресуемом теневой парой
;SS':SP'=E800:4000 (EC000h)
;CS:IP, сохраненные в стеке, указывают на следующий за опкодом байт команды
	PUSH    DS
	PUSHA                       ;AX,CX,DX,BX,SP,BP,SI,DI
	PUSH    ES
	MOV     BP,SP               ;BP - ук-ль стека после сохранения всех регистров
;теперь имеем
;[BP]=ES
;[BP+2]=DI
;[BP+4]=SI
;[BP+6]=BP
;[BP+8]=SP
;[BP+0Ah]=BX
;[BP+0Ch]=DX
;[BP+0Eh]=CX
;[BP+10h]=AX
;[BP+12h]=DS
;[BP+14h]=IP
;[BP+16h]=CS
;[BP+18h]=FLAGS
	MOV     AX,SS
	MOV     DS,AX               ;DS=сегмент стека при входе в прерывание (а значит, ко всем сохраненным выше в стеке можно обращаться через DS)
	IN      AL,0C8h             ;c8h - порт информации о команде 1843вг1
	MOV     AH,AL
	IN      AL,0C8h
	MOV     [0000],AX           ;сохранили считанное из порта информации о команде в DS:0 (E800:0)
	IN      AL,0CEh             ;ceh - порт первого слова команды 1843вг1
	MOV     AH,AL
	IN      AL,0CEh
	MOV     [0002],AX           ;сохранили считанное из порта слова команды в DS:2 (E800:2)
	MOV     AL,AH               ;оставили только первый байт
	MOV     BX,offset op_table  ;адрес таблицы опкодов
	XLAT    CS:op_table         ;AL:=номер обработчика в таблице обработчиков команд
	XOR     BH,BH
	MOV     BL,AL
	JMP     CS:[BX+CMD_TABLE]   ;адрес таблицы адресов обработчиков команд
                                    ;перешли на обработчик соответствующей команды

002B B85300        MOV     AX,0E800h           ;адрес настраивается при загрузке EXE-шника - т.е. это был сегмент. В файле - 0053h
                                               ;возможно, использован как указатель конца кода эмулятора для загрузчика

;обработчик INT 02h (NMI)
;устанавливается при первом вызове сопроцессорной команды в обработчике INT 7
h_NMI proc far
	PUSH    AX
	PUSH    DS
	PUSH    ES
	XOR     AX,AX
	MOV     DS,AX               ;уст DS на таблицу векторов прерываний
	MOV     AX,0E800h
	MOV     ES,AX               ;уст ES на область данных эмулятора E800
	MOV     AX,ES:[0000]        ;прочесть сохраненный IP INT 2
	MOV     [0004],AX           ;записать в таблицу векторов
	MOV     AX,ES:[0002]        ;прочесть сохраненный CS INT 2
	MOV     [0006],AX           ;записать в таблицу векторов
	MOV     AX,ES:[0004]        ;прочесть сохраненные флаги, бывшие до вызова INT 7
	POP     ES
	POP     DS
	XCHG    BP,SP
;теперь распределение в стеке такое
;[BP]=AX
;[BP+2]=IP
;[BP+4]=CS
;[BP+6]=FLAGS
;SP'=BP до прерывания
	MOV     [BP+06],AX          ;записать старые флаги
	XCHG    BP,SP               ;восстановить BP и SP
	MOV     AL,0Ah              ;команда контроллеру прерываний: чтение регистра IRR (запросов на прерывание)
	OUT     0A0h,AL             ;A0h - второй контроллер прерываний
	JMP     005B                ;очистить очередь команд
005B E4A0          IN      AL,0A0h               ;прочитать регистр запросов на прерывание 2-го контроллера
	TEST    AL,20h              ;было прерывание от сопроцессора? (IRQ 13)
	JNZ     0074                ;да - уйти на 0074
        	                    ;иначе прерывание получили от КВП по командам FLDENV, FSTENV, FSAVE, FRSTOR и сопр их выполняет
	WAIT                        ;ждать готовности сопроцессора
	DB      0F1h
	STD                         ;включить INT 07 на каждую ESC команду
	IN      AL,62h
	OR      AL,40h              ;установить триггер блокировки очереди команд процессора
	OUT     62h,AL
	TEST    AL,10h              ;частота сопроцессора 8мгц?
	JNZ     0072                ;да - уйти на 72
	OUT     0E0h,AL             ;иначе переключить синхронизатор
	JMP     0072                ;очистить очередь команд
0072 58            POP     AX
	IRET

;если было прерывание от сопроцессора IRQ13
0074 B020          MOV     AL,20
	OUT     0A0h,AL             ;команда 2-му контроллеру прерывания "обычный конец прерывания"
	MOV     AL,62h
	OUT     20h,AL               ;команда 1-му контроллеру прерывания "специальный конец прерывания" - сброс каскадируемого IRQ2
	DB      0F1h
	STD                         ;включить INT 07 на каждую ESC команду
	IN      AL,62h
	OR      AL,40h               
	OUT     62h,AL              ;установить триггер блокировки очереди команд процессора
	TEST    AL,10h              ;частота сопроцессора 8мгц?
	JNZ     008C                ;да - уйти на 8C
	OUT     0E0h,AL             ;иначе переключить синхронизатор
	JMP     008C                ;очистить очередь команд
008C 58            POP     AX
	INT     02                  ;вновь сгенерировать NMI уже с настоящим обработчиком (сохраненным по первому вызову int07h)
	IRET
h_NMI endp

;обработчик прерывания int 07h (встречена команда сопроцессора ESC)
	PUSH    AX
	PUSH    DS
	XOR     AX,AX
	MOV     DS,AX               ;установить DS на таблицу векторов прерываний
	MOV     AX,[0004]           ;прочесть IP обработчика INT 2 (NMI)
	MOV     SS:[0000],AX        ;сохранить IP INT 2 в области данных эмулятора (E800:0000)
	MOV     AX,[0006]           ;прочесть CS обработчика INT 2 (NMI)
	MOV     SS:[0002],AX        ;сохранить CS INT 2 в области данных эмулятора (E800:0002)
	MOV     AX,offset h_NMI             
	MOV     [0004],AX
	MOV     [0006],CS           ;установить обработчик INT2 (NMI) на E000:02Eh
	POP     DS
	XCHG    SP,BP
;теперь распределение в стеке такое
;[BP]=AX
;[BP+2]=IP
;[BP+4]=CS
;[BP+6]=FLAGS
;SP'=BP до прерывания
	MOV     AX,[BP+06]          ;прочесть флаги, бывшие до прерывания
	MOV     SS:[0004],AX        ;сохранить старые флаги в E800:0004
	MOV     BYTE PTR [BP+07],0F1h ;уст старшие флаги: режим без int 07h на ESC, реальный, OF,DF,IF=0, TF=1
	DEC     WORD PTR [BP+02]    ;уст IP на байт опкода, вызвавшего прерывание
	IN      AL,0C8h             ;c8h - порт информации о команде 1843вг1
	MOV     AH,AL
	IN      AL,0C8h
	TEST    AH,0Fh              ;были ли сегментные префиксы?
	JZ      00CD                ;нет - уйти на CD
	DEC     WORD PTR [BP+02]    ;были - сделать IP указывающим на префикс (начало команды)
00CD 87E5          XCHG    SP,BP
	IN      AL,62h             ;2-й порт конфигурации компьютера
	AND     AL,0D7h             ;сбросить бит 5 (????пусть кнопка TURBO переключает синхронизацию) и 3 (сопроцессор не установлен?) - но в бит 3 запись невозможна
	OUT     62h,AL
	TEST    AL,10h              ;частота сопроцессора 8МГц?
	JNZ     00E3                ;да - уйти на 0E3
	IN      AL,61h              ;иначе прочесть 1-й порт конфигурации компьютера 
	TEST    AL,10h              ;режим синхронизатора 8МГц?
	JZ      00E3                ;нет - уйти на 0E3
	OUT     0E0h,AL             ;иначе переключить синхронизатор
	JMP     00E3                ;очистить очередь команд
00E3 F1            DB      0F1h
	CLD                         ;ОТКЛЮЧИТЬ int 07 на каждую ESC команду
	POP     AX
	IRET                        ;рестарт команды (теперь ее исполнит сопроцессор)

;обработчик сдвигов SHIFT immediate
;формат команд:
;(SHIFT) reg/mem,immed8 
;первый байт:
;C0 - сдвигаемый операнд 8 бит
;С1 - сдвигаемый операнд 16 бит
;второй байт: mod-reg-rm
;тип сдвига определяется reg:
;000 - ROL
;001 - ROR
;010 - RCL
;011 - RCR
;100 - SHL
;101 - SHR
;110 - SHL, как и для 100 (а по справочникам - ничего)
;111 - SAR
;mod и rm аналогичны обычной кодировке для одноадресных команд
;последний байт - число, на которое нужно сдвинуть
h_SHIFT proc near
	OR      AH,02               ;установить, что это команда SHIFT, для дальнейшей обработки
	LES     BX,[BP+0014h]       ;BX указ. на след. за опкодом байт обрабатываемой команды          
	MOV     CX,ES               ;ES=CX= CS обрабатываемой команды
	CALL    h_ADRMODE           ;возвращает адрес первого операнда в SI и сегмент операнда в ES
	CALL    fetch_arg2                ;возвращает второй операнд в CL или CX
	CALL    fetch_arg1          ;возвращает первый операнд в DL или DX
	AND     CL,01Fh             ;ограничить величину сдвига
	MOV     DI,AX
	AND     DI,38h              ;вычленяем из mod-reg-rm команды только reg
	SHR     DI,1
	SHR     DI,1                ;превратили reg в указатель при переходе 
	TEST    AH,01               ;8 или 16 бит команда?
	PUSH    AX
	MOV     AH,[BP+0018h]       ;старые флаги
	JZ      shft8               ;8 бит - уйти на 115
	SAHF                        ;записать старые флаги (мл.часть)
	JMP     CS:[DI+SHIFTABLE16] ;переход по таблице сдвига в 16-разрядном случае

                            ;8-разр. случай
shft8:	SAHF                        ;записать старые флаги (мл.часть)
	JMP     CS:[DI+SHIFTABLE8]  ;переход по таблице сдвига в 8-разрядном случае

;8-битный операнд
ROL8:	ROL     DL,CL               ;000
	JMP     set_flag
	NOP
ROR8:	ROR     DL,CL               ;001
	JMP     set_flag
	NOP
RCL8:	RCL     DL,CL               ;010
	JMP     set_flag
	NOP
RCR8:	RCR     DL,CL               ;011
	JMP     set_flag
	NOP
SHL8:	SHL     DL,CL               ;100 и 110
	JMP     set_flag
	NOP
SHR8:	SHR     DL,CL               ;101
	JMP     set_flag
	NOP
SAR8:	SAR     DL,CL               ;111
	JMP     set_flag
	NOP

;16-битный операнд
ROL16:	ROL     DX,CL               ;000
	JMP     set_flag                    
	NOP                             
ROR16:	ROR     DX,CL               ;001
	JMP     set_flag                    
	NOP                             
RCL16:	RCL     DX,CL               ;010
	JMP     set_flag                    
	NOP                             
RCR16:	RCR     DX,CL               ;011
	JMP     set_flag                    
	NOP                             
SHL16:	SHL     DX,CL               ;100 и 110
	JMP     set_flag                    
	NOP                             
SHR16:	SHR     DX,CL               ;101
	JMP     set_flag                    
	NOP                             
SAR16:	SAR     DX,CL               ;111
	
;запись в сохраненный в теневом стеке регистр флагов, запись результата и выход
set_flag:
	LAHF                        ;выгрузить младшие флаги после сдвига в AH
	MOV     AL,[BP+0019h]       ;прочесть старшие флаги из стека (какие были до команды)
	JO      set_OF              ;OF хранится в старших флагах, он уст? да - 183
	AND     AL,F7               ;нет - сбросить OF=0
ret_of:	XCHG    AH,AL
	MOV     [BP+0018h],AX       ;записать в стек правильное значение флагов после сдвига
	POP     AX                  ;восстановить первый байт команды в AL и AH (с уст. битом 1)
	CALL    write_result        ;записать результат сдвига в память или регистр
	MOV     AX,[0006]           ;прочесть полную длину операндов команды из E800:6
	ADD     [BP+0014h],AX       ;увеличить IP на эту длину, чтобы он указывал на след команду 
	MOV     BYTE PTR [0005],00  ;очистить E800:5, т.к. не инициализируется при входе - для последующих команд
	MOV     SP,BP               ;восстановить указатель стека на сохраненные при входе регистры
	POP     ES
	POPA
	POP     DS                  ;восстановить регистры
	IRET                        ;закончить обработку команды, восстановить CS и SS

set_of: OR      AL,08               ;установить OF=1
	JMP     ret_of

write_result:
;запись результата сдвига в требуемое место (туда же, где был и источник)
	TEST    BYTE PTR [0005],02  ;операнд находится в памяти или в регистре?
	NOP
	JNZ     wr_mem              ;в памяти - уйти на 019С
	TEST    AH,01               ;8 или 16 бит операнд?
	JZ      wr8reg              ;8 бит - уйти на 0198                                                                       
	MOV     [BP+SI+10h],DX      ;запись результата в 16-бит регистр
	                            ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
	RET
                         
wr8reg: MOV     [BP+SI+10h],DL       ;запись результата в 8-бит регистр
	                            ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
	RET
wr_mem:	                            ;запись в память
	TEST    AH,01               ;8 или 16 бит операнд?
	JZ      wr8mem              ;8 бит - уйти на 01A5 
	MOV     ES:[SI],DX          ;запись слова результата в память
	RET

wr8mem:	MOV     ES:[SI],DL          ;запись байта результата в память
	RET
h_SHIFT endp


;осуществляет выборку операнда в регистр DL либо DX
;вызывается третьим после 01FB, 01CB в обработчиках SHIFT и IMUL
;при вызове:
;ES указывает на правильный сегмент в памяти с учетом префиксов команды
;SI - адрес операнда
fetch_arg1 proc hear
	TEST    BYTE PTR [0005],02  ;операнд находится в памяти или в регистре?
	NOP
	JNZ     rd_mem              ;в памяти - уйти на 01BE
	                            ;операнд в регистре
	TEST    AH,01               ;8 или 16 бит операнд?
	JNZ     rd16reg             ;16 бит - уйти на 01BA
	MOV     DL,[BP+SI+10]       ;выборка операнда из 8-бит регистра
	                            ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
	RET

rd16reg:
	MOV     DX,[BP+SI+10]       ;выборка операнда из 16-бит регистра
	RET
        	                    ;выборка из памяти
rd_mem:	TEST    AH,01               ;8 или 16 бит операнд?
	JNZ     rd16mem             ;16 бит - уйти на 01BA
	MOV     DL,ES:[SI]          ;выборка 8-бит операнда из памяти
	RET

rd16mem:
	MOV     DX,ES:[SI]          ;выборка 16-бит операнда из памяти 
	RET
fetch_arg1 endp

;выборка второго операнда команды в регистр CX или CL
;вызывается после h_ADRMODE в обработчиках SHIFT и IMUL
;при вызове:
;AL - первый байт команды, AH - первый байт команды с правками
;CX - CS команды, BX - указывает на следующий за опкодом байт команды
;плюс см. возвращаемое h_ADRMODE
;при возврате:
;E800:6 - реальная длина команды (увеличенная на байт или слово)
;CL/CX - второй операнд
fetch_arg2 proc near 
        PUSH    ES
	MOV     ES,CX
	ADD     BX,[0006]           ;передвинуть BX на байт, следующий за первым операндом команды
	TEST    AH,01               ;8 или 16 бит операнд? (для SHIFT)
	JNZ     arg16bit            ;16 бит - уйти на 1E0
	INC     BYTE PTR [0006]     ;увеличить длину команды на байт
	MOV     CL,ES:[BX]          ;прочесть байтовый второй операнд в CL
	POP     ES
	RET
arg16bit:
	TEST    AH,02               ;это команда SHIFT?
	JZ      no_sft              ;нет - уйти на 1F1
	INC     BYTE PTR [0006]     ;увеличить длину команды на байт
	MOV     CL,ES:[BX]          ;прочесть байтовый второй операнд в CL
	XCHG    CX,AX
	CBW                         
	XCHG    CX,AX               ;превратить операнд в слово, сохраняя знак
	POP     ES
	RET

;не SHIFT и 16-бит
no_sft:	ADD     BYTE PTR [0006],02  ;увеличить длину команды на 2 байта
	MOV     CX,ES:[BX]          ;прочесть слово второго операнда в CL
	POP     ES
	RET
fetch_arg2 endp

;выборка адреса операнда 
;вызывается во всех обработчиках, кроме ENTER
;при вызове:
;BX указывает на следующий за опкодом байт команды, 
;в ES и CX - CS команды
;DS указывает на E800, стек с E800:4000
;при возврате:
;SI - смещение операнда, если он в памяти, 
;и полуфабрикат для выборки регистра, если он в регистре
;ES - сегмент операнда
;AL - второй (mod-reg-rm) байт команды
;AH - первый (опкод) байт команды
;по адресу E800:5 значение:
;бит 0 установлен - адресация по регистру BP
;бит 1 установлен - операнд в памяти (не в регистре)
;по адресу E800:6 значение:
;1=регистровый операнд, непосредственный операнд
;2=слово смещения
;3=байт смещения
;позже это будет использоваться как информация о длине команды

h_ADRMODE proc near
	MOV     AL,ES:[BX]          ;прочитали второй (mod-reg-rm) байт команды, т.к. IP указывает на следующий за опкодом
	CMP     AL,C0               ;операнды находятся в памяти? (если да, то два старших бита не могут быть 11, т.е. меньше C0h)
	JB      inmem               ;да - уйти на 223
        	                    ;нет - случай регистровых операндов
                	            ;формируем адрес нужного регистра, сохраненного в стеке, по полю reg
	                            ;порядок регистров обратен по отношению к тому, как они сохранены по PUSHA
        	                    ;важно, что здесь мы НЕ получим истинного адреса регистра, а только полуфабрикат
	MOV     BYTE PTR [0006],01
	MOV     SI,AX
	TEST    AH,01               ;8 или 16 разрядный операнд?
	JZ      0216                ;8 - уйти на 216
	AND     SI,+07              ;оставить только три младших бита rm
	SHL     SI,1                ;т.к. регистры в стеке расположены по словам
	NEG     SI                  ;т.к. регистры идут в обратном порядке
	RET

;8-разрядный операнд в регистре
0216 83E603        AND     SI,+03              ;оставить только 2 младших бита rm
	SHL     SI,1                ;т.к. регистры расположены по словам
	NEG     SI                  ;т.к. регистры идут в обратном порядке
	TEST    AL,04               ;L-половинки или H-половинки регистров?
	JZ      l_reg                
	INC     SI                  ;H-половинки - адрес на 1 больше
l_reg:	RET

;операнды находятся в памяти
inmem:  OR      BYTE PTR [0005],02
	NOP
	XOR     SI,SI               
	MOV     DL,AL               ;mod-reg-rm -> DL
	AND     DL,0C7h             ;обнулить поле reg
	CMP     DL,06               ;06=00-xxx-110 - это прямая адресация со смещ=0?
	JZ      0291                ;да - уйти на 291
	MOV     DI,AX
	AND     DI,+07              ;иначе использовать rm как индекс в таблице
	SHL     DI,1                ;таблице слов, а не байт, т.ч. сдвинем на 1 разряд
	JMP     CS:[DI+RM_TABLE]    ;переход по таблице обработчиков rm

;обработка режимов косвенной адресации к памяти
;сюда (на разные строки) попадаем из таблицы на 04ffh
;если затрагивается BP, бит 1 E800:5 уст в 1
RM0:	ADD     SI,[BP+000A]        ;точка входа rm=0: BX+SI+смещ (0A - адрес BX в стеке)
RM4:	ADD     SI,[BP+0004]        ;точка входа rm=4: SI+смещ (04 - адрес SI в стеке)
	JMP     0276
	NOP
RM3:	OR      BYTE PTR [0005],01  ;точка входа rm=3: BP+DI+смещ 
	NOP
	ADD     SI,[BP+0006]        ;06 - адрес BP в стеке
RM5:	ADD     SI,[BP+0002]        ;точка входа rm=5: DI+смещ (02 - адрес DI в стеке)
	JMP     0276
	NOP
RM2:	ADD     SI,[BP+0004]        ;точка входа rm=2: BP+SI+смещ (04 - адрес SI в стеке)
RM6:	ADD     SI,[BP+0006]        ;точка входа rm=6: BP+смещ (06 - адрес BP в стеке)
	OR      BYTE PTR [0005],01
	NOP
	JMP     0276
	NOP     	
RM1:	ADD     SI,[BP+0002]        ;точка входа rm=1: BX+DI+смещ (02 - адрес DI в стеке)
RM7:	ADD     SI,[BP+000A]        ;точка входа rm=7: BX+смещ (0A - адрес BX в стеке)

;общая часть обработки косвенной адресации после прибавления значений регистров
0276 A8C0          TEST    AL,C0               ;mod 01,10? (есть смещение?)
	JZ      029F                ;нет - уйти на 29F
	TEST    AL,40               ;mod 01? (один байт смещения?)
	JZ      0291                ;нет - уйти на 291
;считаем, что байт смещения один
	MOV     DX,AX               ;сохраняем КОП и mod-reg-rm
	MOV     AL,ES:[BX+01]       ;читаем байт смещения
	CBW                         ;превращаем в слово с учетом знака (т.к. прибавляем к 16бит регистру)
	ADD     SI,AX               ;прибавили смещение
	MOV     AX,DX               ;восстановили КОП и mod-reg-rm
	MOV     BYTE PTR [0006],02
	JMP     02A4                ;перейти к выбору сегмента
	NOP

;прямая адресация со смещением =0
;два байта смещения или непосредственная словная адресация
0291 C606060003    MOV     BYTE PTR [0006],03
	MOV     DX,ES:[BX+01]          ;прочитать слово, следующее сразу за mod-reg-rm
	ADD     SI,DX               ;прибавили его к SI (как смещение или как значение)
	JMP     02A4                ;перейти к выбору сегмента
	NOP

;сюда попадем, если нет смещения
029F C606060001    MOV     BYTE PTR [0006],01

;установка регистра ES правильным сегментом для доступа к операнду
02A4 8A160100      MOV     DL,[0001]           ;прочесть байт информации о команде, считанный из 1843вг1
	TEST    DL,0F               ;были ли сегментные префиксы?
	JNZ     seg_pref            ;да - обработать
	TEST    BYTE PTR [0005],01  ;использовали ли регистр BP?
	NOP
	JNZ     ss_pref             ;да - установить сегмент SS
ds_pref:
	MOV     ES,[BP+0012]        ;установить ES значением DS, которое было до команды
	RET

;если использовался регистр BP либо был префикс SS,
;адресоваться нужно по сегменту стека, каким он был до вызова команды (в основной паре SS:SP)
ss_pref:
	DB      0F1h
	CLI                         ;F1 FA - переключаемся на основную пару SS:SP
	MOV     DX,SS               ;сохранили стековый сегмент
	DB      0F1h
	STI                         ;F1 FB - переключаемся обратно на теневую пару SS':SP'
	MOV     ES,DX               ;установить ES значением SS, которое было до вызова команды
	RET

;обработка сегментных префиксов
seg_pref:
	TEST    DL,08               ;есть префикс CS?
	NOP
	JNZ     cs_pref
	TEST    DL,04               ;есть префикс DS?
	NOP
	JNZ     ds_pref
	TEST    DL,02               ;есть префикс ES?
	NOP
	JZ      ss_pref             ;нет - значит префикс SS
	MOV     ES,[BP+0000]        ;есть - установить ES значением ES, которое было до вызова команды
	RET
cs_pref:
	MOV     ES,[BP+0016]        ;установить ES значением CS, которое было до вызова команды
	RET
h_ADRMODE endp

;обработчик ENTER
;команда создания стекового кадра процедуры
;формат: enter nvar, nest
;C8 iw 00 если ENTER nvar,0
;C8 iw ib если ENTER nvar,nest и nest<>0
;nvar - кол-во слов памяти под переменные
;nest - уровень вложенности процедуры

;команда ENTER предполагает следующий формат стекового кадра
;(см. Морс С.П., Алберт Д.Д. Архитектура микропроцессора 80286. М.:Радио и связь, 1990 - стр.99):
;SS:BP указывает на начало (высший адрес) для стекового кадра
;[SS:BP], первый байт стекового кадра, содержит 
;"динамическую связь" - указатель на начало стекового кадра процедуры, вызвавшей данную
;[SS:BP-2] и далее содержат "индикаторы" - указатели на начало стекового кадра всех активных процедур:
;-процедура первого уровня вложенности содержит индикатор из одного слова, 
;  указывающий на свое же слово динамической связи (т.е. на следующее слово [SS:BP], высшее в кадре)
;-процедура второго уровня вложенности содержит индикатор из двух слов - 
;  [SS:BP-2] указывает на начало стекового кадра родительской процедуры,
;  [SS:BP-4] указывает на свое же слово динамической связи
;-процедура 3-го уровня вложенности содержит индикатор из трех слов - 
;  [SS:BP-2] - начало стекового кадра процедуры-дедушки, родительской для родительской
;  [SS:BP-4] - на начало стекового кадра родительской процедуры
;  [SS:BP-6] - на свое же слово динамической связи
;и так далее. Т.е n элементов индикатора стекового кадра процедуры уровня n+1
;аналогичны индикатору родительской процедуры.
;После индикаторов в стековом кадре располагается память под переменные.
;В книге Морса все пояснено на картинках и с примерами на Паскале.

;команда ENTER обновляет BP (чтобы он указывал на начало созданного стекового кадра),
;SP (резервируя место в стеке под созданный кадр),
;и записывает в начало созданного стекового кадра "динамическую связь" и "индикатор"

h_ENTER proc near
	LES BX,[BP+0014]     ;BX указ. на след. за опкодом байт обрабатываемой команды,ES:=CS команды
	MOV DX,ES:[BX]       ;DX:=nvar (кол-во байт памяти под переменные)                                
	MOV CL,ES:[BX+02]    ;CL:=nest (уровень вложенности)                                           
	XOR CH,CH                                                                                
	DB F1                                                                                    
	CLI                  ;основной стек                                                                    
	MOV DI,SP            ;DI:=SP указатель основного стека                                                                              
	DB F1                                                                                    
	STI                  ;обратно в теневой стек                                                                    
	MOV SI,[BP+0006]     ;SI:=BP до команды ENTER (указатель на стековый кадр процедуры, вызвавшей данную)
     ;DS ранее был установлен на SS до команды ENTER (до входа в прерывание)
	LEA DI,[DI-02]       ;DI:=указатель на начало создаваемого стекового кадра
	MOV [BP+0006],DI     ;установили BP-после-команды-ENTER на начало нового стекового кадра
	DB F1                
	CLI                  ;основной стек                                                                    
	MOV BX,SS            ;BX:=SS сегмент основного стека
	DB F1                                                                                    
	STI                  ;обратно в теневой стек
	MOV ES,BX            ;ES:=SS основного стека                                                                    
	MOV ES:[DI],SI          ;записали указатель на стековый кадр родительской (вызвавшей) процедуры в создаваемый стековый кадр
	MOV BX,DI            ;BX:=указатель на начало создаваемого стекового кадра
	CMP CL,00            ;уровень вложенности в команде ENTER =0?
	JZ var_allocate      ;да - уйти на распределение стека под переменные
     ;случай ненулевой вложенности 
	STD                  ;строковые команды:= на уменьшение
	PUSH DS                                                                                  
	PUSH ES                                                                                  
	POP DS               ;DS=ES:= SS основного стека
	DEC CX               ;число элементов индикатора=уровню вложенности,
	                     ;а нам нужно скопировать все элементы индикатора родительской процедуры, у нее уровень на 1 меньше
	LEA SI,[SI-02]       ;SI:=смещение на начало индикатора родительской процедуры (слово меньше того, на которое указывал BP до команды ENTER)
	LEA DI,[DI-02]       ;DI:=смещение в основном стеке под индикатор (еще один новый операнд уже после заталкивания туда BP)
	CMP CL,00            ;уровень вложенности 1? (в этом случае копировать нечего)                                                                               
	JZ last_indic        ;да - уйти на запись последнего элемента индикатора
	REPZ                                                                                     
	MOVSW                ;скопировать индикатор родительской процедуры в создаваемый кадр
last_indic:                                                    
	MOV [DI],BX          ;записать в создаваемый кадр последний элемент индикатора для вложенности >0 - 
	                     ;указатель на начало создаваемого стекового кадра
	POP DS               ;DS:=SS основного стека                                                                    
var_allocate:
	SUB DI,DX            ;продвинуть указатель основного стека (в DI) с учетом места в стековом кадре под кол-во переменных,
	                     ;указанных в команде ENTER, под дин.связь и индикаторы указатель (DI) уже модифицирован
	DB F1                                                                                    
	CLI                  ;основной стек
	MOV SP,DI            ;обновить непосредственно указатель основного стека                                                      
	DB F1                                                                                    
	STI                  ;обратно в теневой стек
	ADD WORD PTR [BP+0014],+03 ;увеличить IP на длину команды

;завершающий этап обработки команды ENTER
;полностью аналогичен концу обработки SHIFT (адрес 0178)
;т.е. просто лишний повтор
	MOV     BYTE PTR [0005],00
	MOV     SP,BP
	POP     ES
	POPA
	POP     DS
	IRET
h_ENTER endp

;обработчик IMUL immediate
h_IMUL proc near
	LES     BX,[BP+0014]        ;BX указ. на след. за опкодом байт обрабатываемой команды
	MOV     CX,ES               ;ES=CX= CS обрабатываемой команды       
	CALL    h_ADRMODE           ;возвращает адрес первого операнда в SI и сегмент операнда в ES
	CALL    fetch_arg2          ;возвращает второй операнд в CL или CX
	CALL    fetch_arg1          ;возвращает первый операнд в DL или DX         
	XCHG    CX,AX               ;AX=второй (непосредственный) операнд, CX = первые 2 байта команды
	IMUL    DX                  ;(DX,AX)=(AX)*(DX)
	JO      0376                ;есть переполнение?
	AND     WORD PTR [BP+0018],F7FE    ;нет - сбросить OF и CF
0356 8BF1          MOV     SI,CX               ;SI=первые 2 байта команды (второй на младших адресах)
	AND     SI,+38              ;высечь поле reg из mod-reg-rm
	SHR     SI,1
	SHR     SI,1                ;сдвинуть к началу регистра, с учетом того, что адресоваться по словам
	NEG     SI                  ;т.к. регистры в поле reg идут в обратном порядке по отношению к стеку
	MOV     [BP+SI+10],AX       ;запись результата в 16-бит регистр
        	                    ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
	MOV     AX,[0006]           ;прочесть полную длину операндов команды из E800:6
	ADD     [BP+0014],AX        ;увеличить IP на эту длину, чтобы он указывал на след команду

;завершающий этап обработки команды IMUL
;полностью аналогичен концу обработки SHIFT (адрес 0178)
;т.е. просто лишний повтор
	MOV     BYTE PTR [0005],00
	MOV     SP,BP
	POP     ES
	POPA
	POP     DS
	IRET

;если получили флаг OF
0376 818E18000108  OR      WORD PTR [BP+0018],0801    ;установить OF и CF
	JMP     0356
h_IMUL endp

;обработчик BOUND
;формат команды:
;BOUND reg16 mem
;62 mod-reg-rm mem1 mem2
;поскольку команда двухадресная, mod-reg-rm указывает на второй аргумент
h_BOUND proc near
	OR      AH,01                      ;установить 16-бит тип операнда
	LES     BX,[BP+0014]               ;BX указ. на след. за опкодом байт обрабатываемой команды,ES:=CS команды
	CMP     ES:BYTE PTR [BX],BF        ;операнд в регистре? (mod в mod-reg-rm = 11?)
	JA      03B2                       ;да - уйти на 3B2 (выход из команды)
	CALL    h_ADRMODE                  ;возвращает адрес (???второго) операнда в SI и сегмент операнда в ES
	MOV     CX,ES:[SI]                 ;CX:= операнд из памяти - нижняя граница массива
	MOV     DX,ES:[SI+02]              ;DX:= следующее за ним слово - верхняя граница массива
	MOV     SI,AX                      ;SI=первые 2 байта команды (второй на младших адресах)                                       
	AND     SI,+38                     ;высечь поле reg из mod-reg-rm                                                              
	SHR     SI,1                                                                                                                    
	SHR     SI,1                       ;сдвинуть к началу регистра, с учетом того, что адресоваться по словам
	NEG     SI                         ;т.к. регистры в поле reg идут в обратном порядке по отношению к стеку
	MOV     AX,[BP+SI+10]              ;чтение операнда-регистра
	                                   ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
	CMP     CX,AX                      ;сравнение с нижней границей
	JA      em_INT5                    ;если вышли за нее (н.граница>числа) - уйти на 3BD
	CMP     AX,DX                      ;сравнение с верхней границей
	JA      em_INT5                    ;если вышли за нее (число>в.границв) - уйти на 3BD
	MOV     AX,[0006]                  ;иначе считать длину операндов команды
	ADD     [BP+0014],AX               ;увеличить IP в стеке на эту длину, чтобы он указывал на начало след.команды

;обработчик ненайденной команды 
;также завершающая фаза обработчика BOUND
;полностью аналогичен концу обработки SHIFT (адрес 0178)
;т.е. просто лишний повтор
h_EXIT:
	MOV     BYTE PTR [0005],00
	MOV     SP,BP
	POP     ES
	POPA
	POP     DS
	IRET

;BOUND: случай выхода за границу массива
;эмуляция действий процессора при вызове INT 5 
em_INT5:
	MOV     AX,[BP+0014h]              ;считать IP в стеке (указывающий на второй байт эмулируемой команды)
	DEC     AX                         ;теперь IP указывает на опкод
	TEST    BYTE PTR [0001],0Fh        ;были ли префиксы у команды?
	JZ      nopref
	DEC     AX                         ;если были префиксы, сделать IP указывающим на байт префикса
        	                           ;теперь IP точно указывает на начало команды
nopref: MOV     BX,[BP+0016h]              ;BX:=CS команды
	MOV     CX,[BP+0018h]              ;CX:=флаги команды
	DB      0F1h
	CLI                                ;переключаемся на основную пару SS:SP
	PUSH    CX                         ;как бы pushf
	PUSH    BX                         ;как бы push cs
	PUSH    AX                         ;как бы push ip - все в основном стеке, как при уходе на прерывание
	DB      0F1h
	STI                                ;обратно на теневую пару SS':SP'
	XOR     AX,AX
	MOV     ES,AX                      ;ES указывает на таблицу векторов прерываний
	MOV     AX,ES:[0014h]              ;14h=20=5*4, начало записи для INT 5 в таблице векторов
	MOV     [BP+0014h],AX               ;IP стека эмулятора:= IP обработчика INT 5
	MOV     AX,ES:[0016h]
	MOV     [BP+0016h],AX              ;CS стека эмулятора:= CS обработчика INT 5
	AND     BYTE PTR [BP+0019h],FC     ;сбросить IF и TF во флагах в стеке, как при уходе на прерывание
	NOP
	JMP     h_EXIT                     ;возврат из эмулятора
h_BOUND endp

;таблица адресов программ эмуляции команд
;адрес в таблице соответствует опкоду
OP_table label byte
03F5 0000            0
03F7 0000            2
03F9 0000            4
03FB 0000            6
03FD 0000            8
03FF 0000            a
0401 0000            c
0403 0000            e
0405 0000            10
0407 0000            12
0409 0000            14
040B 0000            16
040D 0000            18
040F 0000            1a
0411 0000            1c
0413 0000            1e
0415 0000            20
0417 0000            22
0419 0000            24
041B 0000            26
041D 0000            28
041F 0000            2a
0421 0000            2c
0423 0000            2e
0425 0000            30
0427 0000            32
0429 0000            34
042B 0000            36
042D 0000            38
042F 0000            3a
0431 0000            3c
0433 0000            3e
0435 0000            40
0437 0000            42
0439 0000            44
043B 0000            46
043D 0000            48
043F 0000            4a
0441 0000            4c
0443 0000            4e
0445 0000            50
0447 0000            52
0449 0000            54
044B 0000            56
044D 0000            58
044F 0000            5a
0451 0000            5c
0453 0000            5e
0455 0000            60
0457 0200            62h - BOUND
0459 0000            64
045B 0000            66
045D 0004            69h - IMUL immediate
045F 0004            6bh - IMUL S immediate
0461 0000            6c
0463 0000            6e
0465 0000            70                        
0467 0000            72                        
0469 0000            74                        
046B 0000            76                        
046D 0000            78                        
046F 0000            7a                        
0471 0000            7c                        
0473 0000            7e                        
0475 0000            80                        
0477 0000            82                        
0479 0000            84                        
047B 0000            86                        
047D 0000            88                        
047F 0000            8a                        
0481 0000            8c                        
0483 0000            8e                        
0485 0000            90                        
0487 0000            92                        
0489 0000            94                        
048B 0000            96                        
048D 0000            98                        
048F 0000            9a                        
0491 0000            9c                        
0493 0000            9e                        
0495 0000            a0                        
0497 0000            a2                        
0499 0000            a4                        
049B 0000            a6                        
049D 0000            a8                        
049F 0000            aa                        
04A1 0000            ac                        
04A3 0000            ae                        
04A5 0000            b0                        
04A7 0000            b2                        
04A9 0000            b4                        
04AB 0000            b6                        
04AD 0000            b8                        
04AF 0000            ba                        
04B1 0000            bc                        
04B3 0000            be                        
04B5 06              c0h - SHIFT immediate  
04B6 06              c1h - SHIFT immediate               
04B7 0000            c2
04B9 0000            c4
04BB 0000            c6
04BD 0800            c8h - ENTER
04BF 0000            ca
04C1 0000            cc 
04C3 0000            ce 
04C5 0000            d0 
04C7 0000            d2 
04C9 0000            d4 
04CB 0000            d6 
04CD 0000            d8 
04CF 0000            da 
04D1 0000            dc 
04D3 0000            de 
04D5 0000            e0 
04D7 0000            e2 
04D9 0000            e4 
04DB 0000            e6 
04DD 0000            e8 
04DF 0000            ea 
04E1 0000            ec 
04E3 0000            ee 
04E5 0000            f0 
04E7 0000            f2 
04E9 0000            f4 
04EB 0000            f6 
04ED 0000            f8 
04EF 0000            fa 
04F1 0000            fc
04F3 0000            fe

;таблица адресов обработчиков команд
CMD_TABLE label word
	DW      offset h_EXIT              ;обработчик ненайденной команды
	DW      offset h_BOUND             ;обрабочик BOUND (смещ.2)
	DW      offset h_IMUL              ;обработчик IMUL (смещ.4)
	DW      offset h_SHIFT             ;обработчик сдвигов (смещ.6)
	DW      offset h_ENTER             ;обработчик ENTER (смещ.8)

;таблица адресов обработчиков режимов косвенной адресации rm  (mod=00,01,10)
RM_TABLE label word
	DW      offset RM0                 ;rm=0
	DW      offset RM1                 ;rm=1
	DW      offset RM2                 ;rm=2
	DW      offset RM3                 ;rm=3
	DW      offset RM4                 ;rm=4
	DW      offset RM5                 ;rm=5
	DW      offset RM6                 ;rm=6
	DW      offset RM7                 ;rm=7

;таблица адресов обработчиков команд сдвига в 16-разрядном случае
;NB! по справочнику Морса reg=6 (010) не используется,
;а здесь reg=6 аналогично reg=4 (100) 
SHIFTABLE16 label word
	DW      offset ROL16               ;000 - ROL   
	DW      offset ROR16               ;001 - ROR   
	DW      offset RCL16               ;010 - RCL   
	DW      offset RCR16               ;011 - RCR   
	DW      offset SHL16               ;100 - SHL   
	DW      offset SHR16               ;101 - SHR   
	DW      offset SHL16               ;110 - ничего
	DW      offset SAR16               ;111 - SAR   

;таблица адресов обработчиков команд сдвига в 8-разрядном случае
;NB! по справочнику Морса reg=6 (010) не используется,
;а здесь reg=6 аналогично reg=4 (100) 
SHIFTABLE8 label word
	DW      offset ROL8               ;000 - ROL   
	DW      offset ROR8               ;001 - ROR   
	DW      offset RCL8               ;010 - RCL   
	DW      offset RCR8               ;011 - RCR   
	DW      offset SHL8               ;100 - SHL   
	DW      offset SHR8               ;101 - SHR   
	DW      offset SHL8               ;110 - ничего
	DW      offset SAR8               ;111 - SAR   

052F 00            DB      00h

STACK segment para
;этого в памяти эмулятора уже не будет, это пойдет в E800:0
	DB	8 dup 00h
STACK ends
;end
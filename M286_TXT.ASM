;M286.TXT - эмулятор команд реального режима 80286, 
;не выполняемых аппаратно процессором 1810ВМ86М.
;Предназнчен для работы на ЕС1842 с м/сх КА1843ВГ1.
;Также выполняет "горячее" переключение тактовой
;частоты с 8МГц на 4 при выполнении команд сопроцессором.

;Дизассемблирование - RCgoff (Л.Ядренников), 20.04.2022

;Для получения файла, полностью совпадающего с исходным,
;использовал Borland Turbo Assembler 5.0 с ключами
;tasm32 /m0 /l /w-LCO M286_TXT.ASM

.286c                               ;включить инструкции реального режима 286

.XLIST
include vm86m.mac                   ;определения четырех дополнительных команд ВМ86М
.LIST

vg1_infport	equ	0C8h        ;порт информации о прерванной команде 1843вг1, включая префиксы  
vg1_opcode	equ	0CEh        ;порт первого слова прерванной команды 1843вг1

;информация в сегменте данных для обработчика INT6
DATA segment at 0E800h
cmd_inf		dw	?           ;слово информации о прерванной команде из 1843ВГ1. Содержит сегментные префиксы
cmd_word	dw	?           ;первый байт команды, считывается из 1843ВГ1, повторен в обоих байтах слова
		db	?           ;на этот байт ссылок нет
reg_or_mem	db	?           ;байт флажков информации об эмулируемой команде
                                    ;бит 0: 1 - в адресации использовался регистр BP
                                    ;бит 1: 1 - операнд одноадресной команды находится в памяти, 0 - в регистре
cmd_len		dw	?           ;длина операндов команды

;информация в сегменте данных для обработчиков INT7 и INT1
bckp_int1_ip	equ	cmd_inf
bckp_int1_cs	equ	cmd_word
DATA ends

INT_TBL segment at 0h               ;таблица векторов прерываний
org 01h*4                           ;INT 01h - прерывание пошагового режима, вызывается после каждой команды, если TF=1
int1_ip	dw	?
int1_cs	dw	?
org 05h*4                           ;INT 05h - прерывание, генерируемое по команде BOUND
int5_ip	dw	?
int5_cs	dw	?
INT_TBL ends

;расположение информации в теневом стеке для обработчика INT6
;для обработчиков INT1 и INT7 расположение другое и приведено
;в комментариях
SHADOW_STACK segment at 0FFFFh      ;адрес условный, теневой стек инициализирован E800:4000
saved_ES	dw	?
saved_DI	dw	?
saved_SI	dw	?
saved_BP	dw	?
saved_SP	dw	?
saved_BX	dw	?
saved_DX	dw	?
saved_CX	dw	?
saved_AX	dw	?
saved_DS	dw	?
saved_IP	dw	?
saved_CS	dw	?
saved_FLAGS	dw	?
SHADOW_STACK ends

END_CMD macro                       ;завершающий этап обработки команды, повторяется во всех четырех обработчиках
	MOV     reg_or_mem,00       ;очистить E800:5, т.к. не инициализируется при входе - для последующих команд
	MOV     SP,BP               ;восстановить указатель стека на сохраненные при входе регистры
	POP     ES
	POPA
	POP     DS                  ;восстановить регистры
	IRET                        ;закончить обработку команды, восстановить CS и SS
	endm

_TEXT segment word public 'CODE'

;==========================================================================
;обработчик прерывания int 06h (неизвестная команда)
;оказались в стеке, адресуемом теневой парой
;SS':SP'=E800:4000 (EC000h)
;CS:IP, сохраненные в стеке, указывают на следующий за опкодом байт команды
assume cs:_TEXT
h_int6 proc far
	PUSH    DS
	PUSHA                       ;AX,CX,DX,BX,SP,BP,SI,DI
	PUSH    ES
	MOV     BP,SP               ;BP - ук-ль стека после сохранения всех регистров
;теперь смещение по адресации через BP совпадает со смещением в декларации SHADOW_STACK выше
	MOV     AX,SS
	MOV     DS,AX               ;DS:=SS=E800,сегмент стека при входе в прерывание (установлено загрузчиком эмулятора)
assume DS:DATA                      ;теперь по DS можно адресоваться к области данных эмулятора E800:0 (ну и к стеку)
	IN      AL,vg1_infport      ;прочли порт информации о команде 1843вг1
	MOV     AH,AL
	IN      AL,vg1_infport
	MOV     cmd_inf,AX          ;сохранили считанное из порта информации о команде
	IN      AL,vg1_opcode       ;прочли порт первого слова команды 1843вг1
	MOV     AH,AL
	IN      AL,vg1_opcode
	MOV     cmd_word,AX         ;сохранили считанное из порта слова команды
	MOV     AL,AH               ;оставили только первый байт
	MOV     BX,offset op_table  ;адрес таблицы опкодов
	XLAT    CS:op_table         ;AL:=номер обработчика в таблице обработчиков команд
	XOR     BH,BH
	MOV     BL,AL
	JMP     CS:[BX+CMD_TABLE]   ;адрес таблицы адресов обработчиков команд
                                    ;перешли на обработчик соответствующей команды
h_int6 endp

	MOV     AX,DUMMYSEG         ;адрес настраивается при загрузке EXE-шника. В файле - 0053h
                                    ;использован как указатель конца кода эмулятора для загрузчика

;==========================================================================
;обработчик INT 01h (пошаговый режим)
;устанавливается при первом вызове сопроцессорной команды в обработчике INT 7
;вызывается после рестарта команды, вызвавшей INT 7
;восстанавливает старый вектор прерывания INT 01h,
;переключает процессор обратно на 8МГц и включает прерывание INT 7
;от любой сопроцессорной команды.
;кроме того, если выполнившаяся команда сопроцессора вызвала аппаратное прерывание от него
;(IRQ13), генерирует программное NMI
h_int1 proc far
	PUSH    AX
	PUSH    DS
	PUSH    ES
	XOR     AX,AX
	MOV     DS,AX               ;уст DS на таблицу векторов прерываний
assume DS:INT_TBL
	MOV     AX,0E800h
	MOV     ES,AX               ;уст ES на область данных эмулятора E800
	MOV     AX,ES:bckp_int1_ip  ;прочесть сохраненный IP INT 1
	MOV     int1_ip,AX          ;записать в таблицу векторов
	MOV     AX,ES:bckp_int1_cs  ;прочесть сохраненный CS INT 1
	MOV     int1_cs,AX          ;записать в таблицу векторов
	MOV     AX,ES:[0004]        ;прочесть сохраненные флаги, бывшие до вызова INT 7
	POP     ES
	POP     DS
assume DS:DATA
	XCHG    BP,SP
;теперь распределение в стеке такое
;[BP]=AX
;[BP+2]=IP
;[BP+4]=CS
;[BP+6]=FLAGS
;SP'=BP до прерывания
	MOV     [BP+06],AX          ;записать старые флаги
	XCHG    BP,SP               ;восстановить BP и SP
	MOV     AL,0Ah              ;команда контроллеру прерываний: чтение регистра IRR (запросов на прерывание)
	OUT     0A0h,AL             ;A0h - второй контроллер прерываний
	JMP     $+2                 ;очистить очередь команд
	IN      AL,0A0h             ;прочитать регистр запросов на прерывание 2-го контроллера
	TEST    AL,20h              ;было прерывание от сопроцессора? (IRQ 13)
	JNZ     IRQ13               ;да - уйти
	WAIT                        ;иначе ждать готовности сопроцессора
	CLM                         ;включить INT 07 на каждую ESC команду
	IN      AL,62h
	OR      AL,40h              ;установить триггер блокировки очереди команд сопроцессора
	OUT     62h,AL
	TEST    AL,10h              ;частота сопроцессора 8МГц?
	JNZ     endnmi              ;да - уйти
	OUT     0E0h,AL             ;иначе переключить синхронизатор
	JMP     $+2                 ;очистить очередь команд
endnmi:	POP     AX
	IRET

;если было прерывание от сопроцессора IRQ13
IRQ13:	MOV     AL,20h
	OUT     0A0h,AL             ;команда 2-му контроллеру прерывания "обычный конец прерывания"
	MOV     AL,62h
	OUT     20h,AL              ;команда 1-му контроллеру прерывания "специальный конец прерывания" - сброс каскадируемого IRQ2
	CLM                         ;включить INT 07 на каждую ESC команду
	IN      AL,62h
	OR      AL,40h
	OUT     62h,AL              ;установить триггер блокировки очереди команд сопроцессора
	TEST    AL,10h              ;частота сопроцессора 8МГц?
	JNZ     nmigen              ;да - уйти
	OUT     0E0h,AL             ;иначе переключить синхронизатор
	JMP     $+2                 ;очистить очередь команд
nmigen:	POP     AX
	INT     02                  ;сгенерировать NMI
	IRET
h_int1 endp


;==========================================================================
;обработчик прерывания int 07h (встречена команда сопроцессора ESC)
;устанавливается загрузчиком эмулятора,
;если используется сопроцессор с частотой 4МГц.

;Данный обработчик совместно с обработчиком INT1 дает возможность работать с процессором
;8086 на частоте 8МГц и с медленным 4-МГц 8087, автоматически переключаясь на 4МГц
;только на время исполнения команд сопроцессора.
;Поддерживается горячее переключение частоты 86+87 кнопкой РЕЖИМ (=TURBO) 4 <-> 8 МГц,
;при работе на 4МГц обработчики не делают по командам сопроцессора переключения частоты.

;Алгоритм. Если система работает на 8МГц, обработчик переключает частоту на 4МГц,
;устанавливает пошаговое прерывание на свой обработчик INT1, запомнив адрес старого,
;и делает рестарт команды сопроцессора, вызвавшей прерывание,
;со включенным флагом пошагового режима и выключенным флагом прерывания по команде сопроцессора.
h_int7 proc far
	PUSH    AX
	PUSH    DS
	XOR     AX,AX
	MOV     DS,AX               ;установить DS на таблицу векторов прерываний
assume DS:INT_TBL
	MOV     AX,int1_ip         ;прочесть IP обработчика INT 1 (пошаговый режим)
	MOV     SS:bckp_int1_ip,AX ;сохранить IP INT 1 в области данных эмулятора (E800:0000)
	MOV     AX,int1_cs         ;прочесть CS обработчика INT 1 (пошаговый режим)
	MOV     SS:bckp_int1_cs,AX ;сохранить CS INT 1 в области данных эмулятора (E800:0002)
	MOV     AX,offset h_int1
	MOV     int1_ip,AX
	MOV     int1_cs,CS         ;установить обработчик прерывания пошагового режима INT1 на h_int1
	POP     DS
assume DS:DATA
	XCHG    SP,BP
;теперь распределение в стеке такое
;[BP]=AX
;[BP+2]=IP
;[BP+4]=CS
;[BP+6]=FLAGS
;SP'=BP до прерывания
	MOV     AX,[BP+06]          ;прочесть флаги, бывшие до прерывания
	MOV     SS:[0004],AX        ;сохранить старые флаги в E800:0004
	MOV     BYTE PTR [BP+07],0F1h ;уст старшие флаги: БЕЗ int 07h на ESC, TF=1 (пошаговый режим ВКЛ), режим реальный, OF,DF,IF=0
	DEC     WORD PTR [BP+02]    ;уст IP на байт опкода, вызвавшего прерывание
	IN      AL,vg1_infport      ;прочли порт информации о команде 1843вг1
	MOV     AH,AL
	IN      AL,vg1_infport
	TEST    AH,0Fh              ;были ли сегментные префиксы?
	JZ      nopref              ;нет - уйти
	DEC     WORD PTR [BP+02]    ;были - сделать IP указывающим на префикс (начало команды)
nopref: XCHG    SP,BP
	IN      AL,62h              ;2-й порт конфигурации компьютера
	AND     AL,0D7h             ;сбросить бит 5 (разрешить переключение синхронизации кнопкой TURBO) 
                                    ;и бит 3 - ошибочно (в него нет записи)
	OUT     62h,AL
	TEST    AL,10h              ;частота сопроцессора 8МГц?
	JNZ     exit7               ;да - уйти
	IN      AL,61h              ;иначе прочесть 1-й порт конфигурации компьютера
	TEST    AL,10h              ;режим синхронизатора 8МГц?
	JZ      exit7               ;нет - уйти
	OUT     0E0h,AL             ;иначе переключить синхронизатор
	JMP     $+2                 ;очистить очередь команд
exit7:	STM                         ;ОТКЛЮЧИТЬ int 07h на каждую ESC команду
	POP     AX
	IRET                        ;рестарт команды (теперь ее исполнит сопроцессор)
h_int7 endp


;==========================================================================
;обработчик сдвигов SHIFT immediate
;формат команд:
;(SHIFT) reg/mem,immed8
;первый байт:
;C0 - сдвигаемый операнд 8 бит
;С1 - сдвигаемый операнд 16 бит
;второй байт: mod-reg-rm
;тип сдвига определяется reg:
;000 - ROL
;001 - ROR
;010 - RCL
;011 - RCR
;100 - SHL
;101 - SHR
;110 - SHL, как и для 100 (а по справочникам - ничего)
;111 - SAR
;mod и rm аналогичны обычной кодировке для одноадресных команд
;последний байт - число, на которое нужно сдвинуть
assume ss:SHADOW_STACK
h_SHIFT proc near
	OR      AH,02               ;установить, что это команда SHIFT, для дальнейшей обработки
	LES     BX,[BP+offset saved_IP]    ;BX указ. на след. за опкодом байт обрабатываемой команды
	MOV     CX,ES               ;ES=CX:= CS обрабатываемой команды
	CALL    h_ADRMODE           ;возвращает адрес первого операнда в SI и сегмент операнда в ES
	CALL    fetch_arg2          ;возвращает второй операнд в CL или CX
	CALL    fetch_arg1          ;возвращает первый операнд в DL или DX
	AND     CL,01Fh             ;ограничить величину сдвига
	MOV     DI,AX
	AND     DI,38h              ;вычленяем из mod-reg-rm команды только reg
	SHR     DI,1
	SHR     DI,1                ;превратили reg в указатель при переходе
	TEST    AH,01               ;8 или 16 бит команда? (переходы чуть дальше)
	PUSH    AX
	MOV     AH,[BP+offset saved_FLAGS]       ;старые флаги
	JZ      shft8               ;8 бит - уйти
	SAHF                        ;записать старые флаги (мл.часть)
	JMP     CS:[DI+SHIFTABLE16] ;переход по таблице сдвига в 16-разрядном случае

                            ;8-разр. случай
shft8:	SAHF                        ;записать старые флаги (мл.часть)
	JMP     CS:[DI+SHIFTABLE8]  ;переход по таблице сдвига в 8-разрядном случае

;8-битный операнд                   ;rm:
ROL8:	ROL     DL,CL               ;000
	JMP     set_flag
ROR8:	ROR     DL,CL               ;001
	JMP     set_flag
RCL8:	RCL     DL,CL               ;010
	JMP     set_flag
RCR8:	RCR     DL,CL               ;011
	JMP     set_flag
SHL8:	SHL     DL,CL               ;100 и 110
	JMP     set_flag
SHR8:	SHR     DL,CL               ;101
	JMP     set_flag
SAR8:	SAR     DL,CL               ;111
	JMP     set_flag

;16-битный операнд                  ;rm:
ROL16:	ROL     DX,CL               ;000
	JMP     set_flag
ROR16:	ROR     DX,CL               ;001
	JMP     set_flag
RCL16:	RCL     DX,CL               ;010
	JMP     set_flag
RCR16:	RCR     DX,CL               ;011
	JMP     set_flag
SHL16:	SHL     DX,CL               ;100 и 110
	JMP     set_flag
SHR16:	SHR     DX,CL               ;101
	JMP     set_flag
SAR16:	SAR     DX,CL               ;111
	
;запись в сохраненный в теневом стеке регистр флагов, запись результата и выход
set_flag:
	LAHF                        ;выгрузить младшие флаги после сдвига в AH
	MOV     AL,[BP+offset saved_FLAGS+1]       ;прочесть старшие флаги из стека (какие были до команды)
	JO      set_OF              ;OF хранится в старших флагах, он уст? да - уйти
	AND     AL,0F7h             ;нет - сбросить OF=0
wr_fl:	XCHG    AH,AL
	MOV     [BP+offset saved_FLAGS],AX       ;записать в стек правильное значение флагов после сдвига
	POP     AX                  ;восстановить первый байт команды в AL и AH (с уст. битом 1)
	CALL    write_result        ;записать результат сдвига в память или регистр
	MOV     AX,cmd_len          ;прочесть полную длину операндов команды
	ADD     [BP+offset saved_IP],AX       ;увеличить IP на эту длину, чтобы он указывал на след команду
	END_CMD

set_of: OR      AL,08               ;установить OF=1
	JMP     wr_fl

write_result:
;запись результата сдвига в требуемое место (туда же, где был и источник)
	TEST    reg_or_mem,02       ;операнд находится в памяти или в регистре?
	NOP
	JNZ     wr_mem              ;в памяти - уйти
	TEST    AH,01               ;8 или 16 бит операнд?
	JZ      wr8reg              ;8 бит - уйти
	MOV     [BP+SI+10h],DX      ;запись результата в 16-бит регистр
	                            ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
	RET

wr8reg: MOV     [BP+SI+10h],DL      ;запись результата в 8-бит регистр
	                            ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
	RET
wr_mem:	                            ;запись в память
	TEST    AH,01               ;8 или 16 бит операнд?
	JZ      wr8mem              ;8 бит - уйти
	MOV     ES:[SI],DX          ;запись слова результата в память
	RET

wr8mem:	MOV     ES:[SI],DL          ;запись байта результата в память
	RET
h_SHIFT endp


;==========================================================================
;fetch_arg1
;осуществляет выборку операнда в регистр DL либо DX
;вызывается третьим после 01FB, 01CB в обработчиках SHIFT и IMUL
;при вызове:
;ES указывает на правильный сегмент в памяти с учетом префиксов команды
;SI - адрес операнда
fetch_arg1 proc near
	TEST    reg_or_mem,02       ;операнд находится в памяти или в регистре?
	NOP
	JNZ     rd_mem              ;в памяти - уйти
	                            ;операнд в регистре
	TEST    AH,01               ;8 или 16 бит операнд?
	JNZ     rd16reg             ;16 бит - уйти
	MOV     DL,[BP+SI+10h]      ;выборка операнда из 8-бит регистра
	                            ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
	RET

rd16reg:
	MOV     DX,[BP+SI+10h]      ;выборка операнда из 16-бит регистра
	RET
        	                    ;выборка из памяти
rd_mem:	TEST    AH,01               ;8 или 16 бит операнд?
	JNZ     rd16mem             ;16 бит - уйти
	MOV     DL,ES:[SI]          ;выборка 8-бит операнда из памяти
	RET

rd16mem:
	MOV     DX,ES:[SI]          ;выборка 16-бит операнда из памяти
	RET
fetch_arg1 endp


;==========================================================================
;fetch_arg2
;выборка второго операнда команды в регистр CX или CL
;вызывается после h_ADRMODE в обработчиках SHIFT и IMUL
;при вызове:
;AL - первый байт команды, AH - первый байт команды с правками
;CX - CS команды, BX - указывает на следующий за опкодом байт команды
;плюс см. возвращаемое h_ADRMODE
;при возврате:
;E800:6 - реальная длина команды (увеличенная на байт или слово)
;CL/CX - второй операнд
fetch_arg2 proc near
        PUSH    ES
	MOV     ES,CX
	ADD     BX,cmd_len          ;передвинуть BX на байт, следующий за первым операндом команды
	TEST    AH,01               ;8 или 16 бит операнд? (для SHIFT)
	JNZ     arg16bit            ;16 бит - уйти
	INC     BYTE PTR cmd_len    ;увеличить длину команды на байт
	MOV     CL,ES:[BX]          ;прочесть байтовый второй операнд в CL
	POP     ES
	RET
arg16bit:
	TEST    AH,02               ;это команда SHIFT?
	JZ      no_sft              ;нет - уйти
	INC     BYTE PTR cmd_len    ;увеличить длину команды на байт
	MOV     CL,ES:[BX]          ;прочесть байтовый второй операнд в CL
	XCHG    CX,AX
	CBW
	XCHG    CX,AX               ;превратить операнд в слово, сохраняя знак
	POP     ES
	RET

;не SHIFT и 16-бит
no_sft:	ADD     BYTE PTR cmd_len,2  ;увеличить длину команды на 2 байта
	MOV     CX,ES:[BX]          ;прочесть слово второго операнда в CL
	POP     ES
	RET
fetch_arg2 endp


;==========================================================================
;h_ADRMODE
;выборка адреса операнда
;вызывается во всех обработчиках, кроме ENTER
;при вызове:
;BX указывает на следующий за опкодом байт команды,
;в ES и CX - CS команды
;DS указывает на E800, стек с E800:4000
;при возврате:
;SI - смещение операнда, если он в памяти,
;и полуфабрикат для выборки регистра, если он в регистре
;ES - сегмент операнда
;AL - второй (mod-reg-rm) байт команды
;AH - первый (опкод) байт команды
;по адресу E800:5 значение:
;бит 0 установлен - адресация по регистру BP
;бит 1 установлен - операнд в памяти (не в регистре)
;по адресу E800:6 значение:
;1=регистровый операнд, непосредственный операнд
;2=слово смещения
;3=байт смещения
;позже это будет использоваться как информация о длине команды

h_ADRMODE proc near
	MOV     AL,ES:[BX]          ;прочитали второй (mod-reg-rm) байт команды, т.к. IP указывает на следующий за опкодом
	CMP     AL,0C0h             ;операнды находятся в памяти? (если да, то два старших бита не могут быть 11, т.е. меньше C0h)
	JB      inmem               ;да - уйти

        	                    ;нет - случай регистровых операндов
                	            ;формируем адрес нужного регистра, сохраненного в стеке, по полю rm
	                            ;порядок регистров обратен по отношению к тому, как они сохранены по PUSHA
        	                    ;важно, что здесь мы НЕ получим истинного адреса регистра, а только полуфабрикат
	MOV     BYTE PTR cmd_len,01
	MOV     SI,AX
	TEST    AH,01               ;8 или 16 разрядный операнд?
	JZ      inreg8              ;8 - уйти
	AND     SI,07h              ;оставить только три младших бита rm
	SHL     SI,1                ;т.к. регистры в стеке расположены по словам
	NEG     SI                  ;т.к. регистры идут в обратном порядке
	RET

;8-разрядный операнд в регистре
inreg8:
	AND     SI,03h              ;оставить только 2 младших бита rm
	SHL     SI,1                ;т.к. регистры расположены по словам
	NEG     SI                  ;т.к. регистры идут в обратном порядке
	TEST    AL,04               ;L-половинки или H-половинки регистров?
	JZ      l_reg
	INC     SI                  ;H-половинки - адрес на 1 больше
l_reg:	RET

;операнды находятся в памяти
inmem:  OR      reg_or_mem,02
	NOP
	XOR     SI,SI
	MOV     DL,AL               ;mod-reg-rm -> DL
	AND     DL,0C7h             ;обнулить поле reg
	CMP     DL,06               ;06=00-xxx-110 - это прямая адресация со смещ=0?
	JZ      word_offset         ;да - уйти
	MOV     DI,AX
	AND     DI,07h              ;иначе использовать rm как индекс в таблице
	SHL     DI,1                ;таблице слов, а не байт, т.ч. сдвинем на 1 разряд
	JMP     CS:[DI+RM_TABLE]    ;переход по таблице обработчиков rm

;обработка режимов косвенной адресации к памяти
;сюда (на разные строки) попадаем из таблицы RM_TABLE
;если затрагивается BP, бит 1 байта reg-or-mem уст в 1
RM0:	ADD     SI,[BP+offset saved_BX]       ;точка входа rm=0: BX+SI+смещ
RM4:	ADD     SI,[BP+offset saved_SI]       ;точка входа rm=4: SI+смещ
	JMP     check_offset
RM3:	OR      reg_or_mem,01       ;точка входа rm=3: BP+DI+смещ
	NOP
	ADD     SI,[BP+offset saved_BP]        ;06 - адрес BP в стеке
RM5:	ADD     SI,[BP+offset saved_DI]        ;точка входа rm=5: DI+смещ
	JMP     check_offset
RM2:	ADD     SI,[BP+offset saved_SI]        ;точка входа rm=2: BP+SI+смещ
RM6:	ADD     SI,[BP+offset saved_BP]        ;точка входа rm=6: BP+смещ
	OR      reg_or_mem,01
	NOP
	JMP     check_offset
RM1:	ADD     SI,[BP+offset saved_DI]        ;точка входа rm=1: BX+DI+смещ
RM7:	ADD     SI,[BP+offset saved_BX]       ;точка входа rm=7: BX+смещ

;общая часть обработки косвенной адресации после прибавления значений регистров
check_offset:
	TEST    AL,0C0h             ;mod 01,10? (есть смещение?)
	JZ      no_offset           ;нет - уйти
	TEST    AL,40h              ;mod 01? (один байт смещения?)
	JZ      word_offset         ;нет - уйти
;считаем, что байт смещения один
	MOV     DX,AX               ;сохраняем КОП и mod-reg-rm
	MOV     AL,ES:[BX+01]       ;читаем байт смещения
	CBW                         ;превращаем в слово с учетом знака (т.к. прибавляем к 16бит регистру)
	ADD     SI,AX               ;прибавили смещение
	MOV     AX,DX               ;восстановили КОП и mod-reg-rm
	MOV     BYTE PTR cmd_len,02
	JMP     check_pref          ;перейти к выбору сегмента

;прямая адресация со смещением =0
;два байта смещения или непосредственная словная адресация
word_offset:
	MOV     BYTE PTR cmd_len,03
	MOV     DX,ES:[BX+01]       ;прочитать слово, следующее сразу за mod-reg-rm
	ADD     SI,DX               ;прибавили его к SI (как смещение или как значение)
	JMP     check_pref          ;перейти к выбору сегмента

;сюда попадем, если нет смещения
no_offset:
	MOV     BYTE PTR cmd_len,01

;установка регистра ES правильным сегментом для доступа к операнду
check_pref:
	MOV     DL,BYTE PTR cmd_inf+1 ;прочесть байт информации о команде, считанный из 1843вг1
	TEST    DL,0Fh              ;были ли сегментные префиксы?
	JNZ     seg_pref            ;да - обработать
	TEST    reg_or_mem,01       ;использовали ли регистр BP?
	NOP
	JNZ     ss_pref             ;да - установить сегмент SS
ds_pref:
	MOV     ES,[BP+offset saved_DS]       ;установить ES значением DS, которое было до команды
	RET

;если использовался регистр BP либо был префикс SS,
;адресоваться нужно по сегменту стека, каким он был до вызова команды (в основной паре SS:SP)
ss_pref:
	RESS                        ;переключаемся на основную пару SS:SP
	MOV     DX,SS               ;сохранили стековый сегмент
	SHSS                        ;переключаемся обратно на теневую пару SS':SP'
	MOV     ES,DX               ;установить ES значением SS, которое было до вызова команды
	RET

;обработка сегментных префиксов
seg_pref:
	TEST    DL,08               ;есть префикс CS?
	NOP
	JNZ     cs_pref
	TEST    DL,04               ;есть префикс DS?
	NOP
	JNZ     ds_pref
	TEST    DL,02               ;есть префикс ES?
	NOP
	JZ      ss_pref             ;нет - значит префикс SS
	MOV     ES,[BP+offset saved_ES]        ;есть - установить ES значением ES, которое было до вызова команды
	RET
cs_pref:
	MOV     ES,[BP+offset saved_CS]        ;установить ES значением CS, которое было до вызова команды
	RET
h_ADRMODE endp


;==========================================================================
;обработчик ENTER
;команда создания стекового кадра процедуры
;формат: enter nvar, nest
;C8 iw 00 если ENTER nvar,0
;C8 iw ib если ENTER nvar,nest и nest<>0
;nvar - кол-во слов памяти под переменные
;nest - уровень вложенности процедуры

;команда ENTER предполагает следующий формат стекового кадра
;(см. Морс С.П., Алберт Д.Д. Архитектура микропроцессора 80286. М.:Радио и связь, 1990 - стр.99):
;SS:BP указывает на начало (высший адрес) для стекового кадра
;[SS:BP], первый байт стекового кадра, содержит
;"динамическую связь" - указатель на начало стекового кадра процедуры, вызвавшей данную
;[SS:BP-2] и далее содержат "индикаторы" - указатели на начало стекового кадра всех активных процедур:
;-процедура первого уровня вложенности содержит индикатор из одного слова,
;  указывающий на свое же слово динамической связи (т.е. на следующее слово [SS:BP], высшее в кадре)
;-процедура второго уровня вложенности содержит индикатор из двух слов -
;  [SS:BP-2] указывает на начало стекового кадра родительской процедуры,
;  [SS:BP-4] указывает на свое же слово динамической связи
;-процедура 3-го уровня вложенности содержит индикатор из трех слов -
;  [SS:BP-2] - начало стекового кадра процедуры-дедушки, родительской для родительской
;  [SS:BP-4] - на начало стекового кадра родительской процедуры
;  [SS:BP-6] - на свое же слово динамической связи
;и так далее. Т.е n элементов индикатора стекового кадра процедуры уровня n+1
;аналогичны индикатору родительской процедуры.
;После индикаторов в стековом кадре располагается память под переменные.
;В книге Морса все пояснено на картинках и с примерами на Паскале.

;команда ENTER обновляет BP (чтобы он указывал на начало созданного стекового кадра),
;SP (резервируя место в стеке под созданный кадр),
;и записывает в начало созданного стекового кадра "динамическую связь" и "индикатор"

h_ENTER proc near
	LES BX,[BP+offset saved_IP]     ;BX указ. на след. за опкодом байт обрабатываемой команды,ES:=CS команды
	MOV DX,ES:[BX]              ;DX:=nvar (кол-во байт памяти под переменные)
	MOV CL,ES:[BX+02]           ;CL:=nest (уровень вложенности)
	XOR CH,CH
	RESS                        ;основной стек
	MOV DI,SP                   ;DI:=SP указатель основного стека
	SHSS                        ;обратно в теневой стек
	MOV SI,[BP+offset saved_BP]     ;SI:=BP до команды ENTER (указатель на стековый кадр процедуры, вызвавшей данную)
        ;DS ранее был установлен на SS до команды ENTER (до входа в прерывание)
	LEA DI,[DI-02]              ;DI:=указатель на начало создаваемого стекового кадра
	MOV [BP+offset saved_BP],DI ;установили BP-после-команды-ENTER на начало нового стекового кадра
	RESS                        ;основной стек
	MOV BX,SS                   ;BX:=SS сегмент основного стека
	SHSS                        ;обратно в теневой стек
	MOV ES,BX                   ;ES:=SS основного стека
	MOV ES:[DI],SI              ;записали указатель на стековый кадр родительской (вызвавшей) процедуры в создаваемый стековый кадр
	MOV BX,DI                   ;BX:=указатель на начало создаваемого стекового кадра
	CMP CL,00                   ;уровень вложенности в команде ENTER =0?
	JZ var_allocate             ;да - уйти на распределение стека под переменные
;случай ненулевой вложенности
	STD                         ;строковые команды:= на уменьшение
	PUSH DS
	PUSH ES
	POP DS                      ;DS=ES:= SS основного стека
	DEC CX                      ;число элементов индикатора=уровню вложенности,
	                            ;а нам нужно скопировать все элементы индикатора родительской процедуры, у нее уровень на 1 меньше
	LEA SI,[SI-02]              ;SI:=смещение на начало индикатора родительской процедуры 
                                    ;(на 1 слово меньше начала родительского стекового кадра, на которое указывал BP до команды ENTER)
	LEA DI,[DI-02]              ;DI:=смещение в основном стеке под индикатор (еще один новый операнд уже после заталкивания туда BP)
	CMP CL,00                   ;уровень вложенности 1? (в этом случае копировать нечего)
	JZ last_indic               ;да - уйти на запись последнего элемента индикатора
	REPZ MOVSW                  ;скопировать индикатор родительской процедуры в создаваемый кадр
last_indic:
	MOV [DI],BX                 ;записать в создаваемый кадр последний элемент индикатора для вложенности >0 -
	                            ;указатель на начало создаваемого стекового кадра
	POP DS                      ;DS:=SS основного стека
var_allocate:
	SUB DI,DX                   ;продвинуть указатель основного стека (в DI) с учетом места в стековом кадре под кол-во переменных,
	                            ;указанных в команде ENTER, под дин.связь и индикаторы указатель (DI) уже модифицирован
	RESS                        ;основной стек
	MOV SP,DI                   ;обновить непосредственно указатель основного стека
	SHSS                        ;обратно в теневой стек
	ADD WORD PTR [BP+offset saved_IP],03 ;увеличить IP на длину команды
	END_CMD
h_ENTER endp


;==========================================================================
;обработчик IMUL immediate
h_IMUL proc near
	LES     BX,[BP+offset saved_IP]       ;BX указ. на след. за опкодом байт обрабатываемой команды
	MOV     CX,ES               ;ES=CX= CS обрабатываемой команды
	CALL    h_ADRMODE           ;возвращает адрес первого операнда в SI и сегмент операнда в ES
	CALL    fetch_arg2          ;возвращает второй операнд в CL или CX
	CALL    fetch_arg1          ;возвращает первый операнд в DL или DX
	XCHG    CX,AX               ;AX=второй (непосредственный) операнд, CX = первые 2 байта команды
	IMUL    DX                  ;(DX,AX)=(AX)*(DX)
	JO      set_OF_CF           ;есть переполнение?
	AND     [BP+offset saved_FLAGS],0F7FEh    ;нет - сбросить OF и CF
write:	MOV     SI,CX               ;SI=первые 2 байта команды (второй на младших адресах)
	AND     SI,38h              ;высечь поле reg из mod-reg-rm
	SHR     SI,1
	SHR     SI,1                ;сдвинуть к началу регистра, с учетом того, что адресоваться по словам
	NEG     SI                  ;т.к. регистры в поле reg идут в обратном порядке по отношению к стеку
	MOV     [BP+SI+10h],AX      ;запись результата в 16-бит регистр
        	                    ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
	MOV     AX,cmd_len          ;прочесть полную длину операндов команды
	ADD     [BP+offset saved_IP],AX        ;увеличить IP на эту длину, чтобы он указывал на след команду
	END_CMD

;если получили флаг OF
set_OF_CF:
	OR      [BP+offset saved_FLAGS],0801h    ;установить OF и CF
	JMP     write
h_IMUL endp


;==========================================================================
;обработчик BOUND
;формат команды:
;BOUND reg16 mem
;62 mod-reg-rm mem1 mem2
;поскольку команда двухадресная, mod-reg-rm указывает на ВТОРОЙ аргумент
h_BOUND proc near
	OR      AH,01                      ;установить 16-бит тип операнда
	LES     BX,[BP+offset saved_IP]              ;BX указ. на след. за опкодом байт обрабатываемой команды,ES:=CS команды
	CMP     ES:BYTE PTR [BX],0BFh      ;операнд в регистре? (mod в mod-reg-rm = 11?)
	JA      h_EXIT                     ;да - уйти на выход из команды
	CALL    h_ADRMODE                  ;возвращает адрес ВТОРОГО операнда в SI и сегмент операнда в ES
	MOV     CX,ES:[SI]                 ;CX:= операнд из памяти - нижняя граница массива
	MOV     DX,ES:[SI+02]              ;DX:= следующее за ним слово - верхняя граница массива
	MOV     SI,AX                      ;SI=первые 2 байта команды (второй на младших адресах)
	AND     SI,38h                     ;высечь поле reg из mod-reg-rm
	SHR     SI,1
	SHR     SI,1                       ;сдвинуть к началу регистра, с учетом того, что адресоваться по словам
	NEG     SI                         ;т.к. регистры в поле reg идут в обратном порядке по отношению к стеку
	MOV     AX,[BP+SI+10h]             ;чтение операнда-регистра
	                                   ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
	CMP     CX,AX                      ;сравнение с нижней границей
	JA      em_INT5                    ;если вышли за нее (н.граница>числа) - генерировать INT5
	CMP     AX,DX                      ;сравнение с верхней границей
	JA      em_INT5                    ;если вышли за нее (число>в.границв) - генерировать INT5
	MOV     AX,cmd_len                 ;иначе считать длину операндов команды
	ADD     [BP+offset saved_IP],AX    ;увеличить IP в стеке на эту длину, чтобы он указывал на начало след.команды

;обработчик ненайденной команды
;также завершающая фаза обработчика BOUND
h_EXIT: END_CMD

;BOUND: случай выхода за границу массива
;эмуляция действий процессора при вызове INT 5
em_INT5:
	MOV     AX,[BP+offset saved_IP]    ;считать IP в стеке (указывающий на второй байт эмулируемой команды)
	DEC     AX                         ;теперь IP указывает на опкод
	TEST    BYTE PTR cmd_inf+1,0Fh     ;были ли префиксы у команды?
	JZ      get_CS
	DEC     AX                         ;если были префиксы, сделать IP указывающим на байт префикса
        	                           ;теперь IP точно указывает на начало команды
get_CS: MOV     BX,[BP+offset saved_CS]    ;BX:=CS команды
	MOV     CX,[BP+offset saved_FLAGS] ;CX:=флаги команды
	RESS                               ;переключаемся на основную пару SS:SP
	PUSH    CX                         ;как бы pushf
	PUSH    BX                         ;как бы push cs
	PUSH    AX                         ;как бы push ip - все в основном стеке, как при уходе на прерывание
	SHSS                               ;обратно на теневую пару SS':SP'
	XOR     AX,AX
	MOV     ES,AX                      ;ES указывает на таблицу векторов прерываний
	MOV     AX,ES:int5_ip              ;начало записи для INT 5 в таблице векторов
	MOV     [BP+offset saved_IP],AX    ;IP стека эмулятора:= IP обработчика INT 5
	MOV     AX,ES:int5_cs
	MOV     [BP+offset saved_CS],AX    ;CS стека эмулятора:= CS обработчика INT 5
	AND     BYTE PTR [BP+offset saved_FLAGS+1],0FCh   ;сбросить IF и TF во флагах в стеке, как при уходе на прерывание
	NOP
	JMP     h_EXIT                     ;возврат из эмулятора
h_BOUND endp


;==========================================================================
;таблица адресов программ эмуляции команд
;адрес в таблице соответствует опкоду
OP_table label byte
	db	256 DUP (0)
org offset OP_table+62h
	db	02                         ;62h - BOUND
org offset OP_table+69h
	db	04                         ;69h - IMUL immediate
org offset OP_table+6bh
	db	04                         ;6bh - IMUL S immediate
org offset OP_table+0c0h
	db	06                         ;c0h - SHIFT immediate
	db	06                         ;c1h - SHIFT immediate
org offset OP_table+0c8h
	db	08                         ;c8h - ENTER
org offset OP_table+256

;таблица адресов обработчиков команд
CMD_TABLE label word
	DW      offset h_EXIT              ;обработчик ненайденной команды
	DW      offset h_BOUND             ;обрабочик BOUND (смещ.2)
	DW      offset h_IMUL              ;обработчик IMUL (смещ.4)
	DW      offset h_SHIFT             ;обработчик сдвигов (смещ.6)
	DW      offset h_ENTER             ;обработчик ENTER (смещ.8)

;таблица адресов обработчиков режимов косвенной адресации rm  (mod=00,01,10)
RM_TABLE label word
	DW      offset RM0                 ;rm=0
	DW      offset RM1                 ;rm=1
	DW      offset RM2                 ;rm=2
	DW      offset RM3                 ;rm=3
	DW      offset RM4                 ;rm=4
	DW      offset RM5                 ;rm=5
	DW      offset RM6                 ;rm=6
	DW      offset RM7                 ;rm=7

;таблица адресов обработчиков команд сдвига в 16-разрядном случае
;NB! по справочнику Морса reg=6 (010) не используется,
;а здесь reg=6 аналогично reg=4 (100)
SHIFTABLE16 label word
	DW      offset ROL16               ;000 - ROL
	DW      offset ROR16               ;001 - ROR
	DW      offset RCL16               ;010 - RCL
	DW      offset RCR16               ;011 - RCR
	DW      offset SHL16               ;100 - SHL
	DW      offset SHR16               ;101 - SHR
	DW      offset SHL16               ;110 - ничего
	DW      offset SAR16               ;111 - SAR

;таблица адресов обработчиков команд сдвига в 8-разрядном случае
;NB! по справочнику Морса reg=6 (010) не используется,
;а здесь reg=6 аналогично reg=4 (100)
SHIFTABLE8 label word
	DW      offset ROL8               ;000 - ROL
	DW      offset ROR8               ;001 - ROR
	DW      offset RCL8               ;010 - RCL
	DW      offset RCR8               ;011 - RCR
	DW      offset SHL8               ;100 - SHL
	DW      offset SHR8               ;101 - SHR
	DW      offset SHL8               ;110 - ничего
	DW      offset SAR8               ;111 - SAR

;располагается по адресу 052Fh и вероятно возник из-за выравнивания следующего сегмента по слову или параграфу
;	DB      00h

_TEXT ends

DUMMYSEG segment word public 'CODE'
;этого в памяти эмулятора уже не будет, это пойдет в E800:0
	DB	8 dup (0)
DUMMYSEG ends
end h_int6

Turbo Assembler	 Version 5.0	    04-21-22 06:08:01	    Page 1
M286_TXT.ASM



			     ;M286.TXT - эмулятор команд реального режима 80286,
			     ;не выполняемых аппаратно процессором 1810ВМ86М.
			     ;Предназнчен для работы на ЕС1842 с м/сх КА1843ВГ1.
			     ;Также выполняет "горячее" переключение тактовой
			     ;частоты с 8МГц на 4 при выполнении команд сопроцессором.

			     ;Дизассемблирование - RCgoff (Л.Ядренников), 20.04.2022

			     ;Для получения файла, полностью совпадающего с исходным,
			     ;использовал Borland Turbo Assembler 5.0 с ключами
			     ;tasm32 /m0 /l /w-LCO M286_TXT.ASM

			     .286c				 ;включить инструкции реального режима 286


      =00C8		     vg1_infport     equ     0C8h	 ;порт информации о прерванной команде 1843вг1, включая префиксы
      =00CE		     vg1_opcode	     equ     0CEh	 ;порт первого слова прерванной команды 1843вг1

			     ;информация в сегменте данных для обработчика INT6
0000			     DATA segment at 0E800h
0000  ????		     cmd_inf	     dw	     ?		 ;слово информации о прерванной команде из 1843ВГ1. Содержит сегментные префиксы
0002  ????		     cmd_word	     dw	     ?		 ;первый байт команды, считывается из 1843ВГ1, повторен в обоих байтах слова
0004  ??				     db	     ?		 ;на этот байт ссылок нет
0005  ??		     reg_or_mem	     db	     ?		 ;байт флажков информации об эмулируемой команде
								 ;бит 0: 1 - в адресации использовался регистр BP
								 ;бит 1: 1 - операнд одноадресной команды находится в памяти, 0 - в регистре
0006  ????		     cmd_len	     dw	     ?		 ;длина операндов команды

			     ;информация в сегменте данных для обработчиков INT7 и INT1
			     bckp_int1_ip    equ     cmd_inf
			     bckp_int1_cs    equ     cmd_word
0008			     DATA ends

0000			     INT_TBL segment at	0h		 ;таблица векторов прерываний
			     org 01h*4				 ;INT 01h - прерывание пошагового режима, вызывается после каждой команды, если TF=1
0004  ????		     int1_ip dw	     ?
0006  ????		     int1_cs dw	     ?
			     org 05h*4				 ;INT 05h - прерывание, генерируемое по команде BOUND
0014  ????		     int5_ip dw	     ?
0016  ????		     int5_cs dw	     ?
0018			     INT_TBL ends

			     ;расположение информации в теневом стеке для обработчика INT6
			     ;для обработчиков INT1 и INT7 расположение другое и приведено
			     ;в комментариях
0000			     SHADOW_STACK segment at 0FFFFh	 ;адрес условный, теневой стек инициализирован E800:4000
0000  ????		     saved_ES	     dw	     ?
0002  ????		     saved_DI	     dw	     ?
0004  ????		     saved_SI	     dw	     ?
0006  ????		     saved_BP	     dw	     ?
0008  ????		     saved_SP	     dw	     ?
000A  ????		     saved_BX	     dw	     ?
000C  ????		     saved_DX	     dw	     ?
000E  ????		     saved_CX	     dw	     ?
0010  ????		     saved_AX	     dw	     ?
0012  ????		     saved_DS	     dw	     ?
0014  ????		     saved_IP	     dw	     ?
0016  ????		     saved_CS	     dw	     ?
0018  ????		     saved_FLAGS     dw	     ?
001A			     SHADOW_STACK ends

			     END_CMD macro			 ;завершающий этап обработки команды, повторяется во всех четырех обработчиках
				     MOV     reg_or_mem,00	 ;очистить, т.к. не инициализируется при входе - для последующих вызовов
				     MOV     SP,BP		 ;восстановить указатель стека на сохраненные при входе регистры
				     POP     ES
				     POPA
				     POP     DS			 ;восстановить регистры
				     IRET			 ;закончить обработку команды, восстановить CS и SS
				     endm

0000			     _TEXT segment word	public 'CODE'

			     ;==========================================================================
			     ;обработчик прерывания int 06h (неизвестная команда)
			     ;оказались в стеке, адресуемом теневой парой
			     ;SS':SP'=E800:4000 (EC000h)
			     ;CS:IP, сохраненные в стеке, указывают на следующий за опкодом байт команды
			     assume cs:_TEXT
0000			     h_int6 proc far
0000  1E			     PUSH    DS
0001  60			     PUSHA			 ;AX,CX,DX,BX,SP,BP,SI,DI
0002  06			     PUSH    ES
0003  8B EC			     MOV     BP,SP		 ;BP - ук-ль стека после сохранения всех регистров
			     ;теперь смещение по адресации через BP совпадает со смещением в декларации SHADOW_STACK выше
0005  8C D0			     MOV     AX,SS
0007  8E D8			     MOV     DS,AX		 ;DS:=SS=E800,сегмент стека при входе в прерывание (установлено загрузчиком эмулятора)
			     assume DS:DATA			 ;теперь по DS можно адресоваться к области данных эмулятора E800:0 (ну и к стеку)
0009  E4 C8			     IN	     AL,vg1_infport	 ;прочли порт информации о команде 1843вг1
000B  8A E0			     MOV     AH,AL
000D  E4 C8			     IN	     AL,vg1_infport
000F  A3 0000r			     MOV     cmd_inf,AX		 ;сохранили считанное из порта информации о команде
0012  E4 CE			     IN	     AL,vg1_opcode	 ;прочли порт первого слова команды 1843вг1
0014  8A E0			     MOV     AH,AL
0016  E4 CE			     IN	     AL,vg1_opcode
0018  A3 0002r			     MOV     cmd_word,AX	 ;сохранили считанное из порта слова команды
001B  8A C4			     MOV     AL,AH		 ;оставили только первый байт
001D  BB 03F5r			     MOV     BX,offset op_table	 ;адрес таблицы опкодов
0020  2E: D7			     XLAT    CS:op_table	 ;AL:=номер обработчика в таблице обработчиков команд
0022  32 FF			     XOR     BH,BH
0024  8A D8			     MOV     BL,AL
0026  2E: FF A7	04F5r		     JMP     CS:[BX+CMD_TABLE]	 ;адрес таблицы адресов обработчиков команд
								 ;перешли на обработчик соответствующей команды
002B			     h_int6 endp

002B  B8 0000s			     MOV     AX,DUMMYSEG	 ;адрес настраивается при загрузке EXE-шника. В файле - 0053h
								 ;использован как указатель конца кода эмулятора для загрузчика

			     ;==========================================================================
			     ;обработчик INT 01h (пошаговый режим)
			     ;устанавливается при первом вызове сопроцессорной команды в обработчике INT 7
			     ;вызывается после рестарта команды, вызвавшей INT 7
			     ;восстанавливает старый вектор прерывания INT 01h,
			     ;переключает процессор обратно на 8МГц и включает прерывание INT 7
			     ;от любой сопроцессорной команды.
			     ;кроме того, если выполнившаяся команда сопроцессора вызвала аппаратное прерывание от него
			     ;(IRQ13), генерирует программное NMI
002E			     h_int1 proc far
002E  50			     PUSH    AX
002F  1E			     PUSH    DS
0030  06			     PUSH    ES
0031  33 C0			     XOR     AX,AX
0033  8E D8			     MOV     DS,AX		 ;уст DS на таблицу векторов прерываний
			     assume DS:INT_TBL
0035  B8 E800			     MOV     AX,0E800h
0038  8E C0			     MOV     ES,AX		 ;уст ES на область данных эмулятора E800
003A  26: A1 0000r		     MOV     AX,ES:bckp_int1_ip	 ;прочесть сохраненный IP INT 1
003E  A3 0004r			     MOV     int1_ip,AX		 ;записать в таблицу векторов
0041  26: A1 0002r		     MOV     AX,ES:bckp_int1_cs	 ;прочесть сохраненный CS INT 1
0045  A3 0006r			     MOV     int1_cs,AX		 ;записать в таблицу векторов
0048  26: A1 0004		     MOV     AX,ES:[0004]	 ;прочесть сохраненные флаги, бывшие до вызова INT 7
004C  07			     POP     ES
004D  1F			     POP     DS
			     assume DS:DATA
004E  87 EC			     XCHG    BP,SP
			     ;теперь распределение в стеке такое
			     ;[BP]=AX
			     ;[BP+2]=IP
			     ;[BP+4]=CS
			     ;[BP+6]=FLAGS
			     ;SP'=BP до прерывания
0050  89 46 06			     MOV     [BP+06],AX		 ;записать старые флаги
0053  87 EC			     XCHG    BP,SP		 ;восстановить BP и SP
0055  B0 0A			     MOV     AL,0Ah		 ;команда контроллеру прерываний: чтение регистра IRR (запросов на прерывание)
0057  E6 A0			     OUT     0A0h,AL		 ;A0h - второй контроллер прерываний
0059  EB 00			     JMP     $+2		 ;очистить очередь команд
005B  E4 A0			     IN	     AL,0A0h		 ;прочитать регистр запросов на прерывание 2-го контроллера
005D  A8 20			     TEST    AL,20h		 ;было прерывание от сопроцессора? (IRQ 13)
005F  75 13			     JNZ     IRQ13		 ;да - уйти
0061  9B			     WAIT			 ;иначе ждать готовности сопроцессора
				     CLM			 ;включить INT 07 на каждую ESC команду
0062  F1			     db	0F1h
0063  FD			     STD
0064  E4 62			     IN	     AL,62h
0066  0C 40			     OR	     AL,40h		 ;установить триггер блокировки очереди команд сопроцессора
0068  E6 62			     OUT     62h,AL
006A  A8 10			     TEST    AL,10h		 ;частота сопроцессора 8МГц?
006C  75 04			     JNZ     endnmi		 ;да - уйти
006E  E6 E0			     OUT     0E0h,AL		 ;иначе переключить синхронизатор
0070  EB 00			     JMP     $+2		 ;очистить очередь команд
0072  58		     endnmi: POP     AX
0073  CF			     IRET

			     ;если было прерывание от сопроцессора IRQ13
0074  B0 20		     IRQ13:  MOV     AL,20h
0076  E6 A0			     OUT     0A0h,AL		 ;команда 2-му контроллеру прерывания "обычный конец прерывания"
0078  B0 62			     MOV     AL,62h
007A  E6 20			     OUT     20h,AL		 ;команда 1-му контроллеру прерывания "специальный конец прерывания" - сброс каскадируемого IRQ2
				     CLM			 ;включить INT 07 на каждую ESC команду
007C  F1			     db	0F1h
007D  FD			     STD
007E  E4 62			     IN	     AL,62h
0080  0C 40			     OR	     AL,40h
0082  E6 62			     OUT     62h,AL		 ;установить триггер блокировки очереди команд сопроцессора
0084  A8 10			     TEST    AL,10h		 ;частота сопроцессора 8МГц?
0086  75 04			     JNZ     nmigen		 ;да - уйти
0088  E6 E0			     OUT     0E0h,AL		 ;иначе переключить синхронизатор
008A  EB 00			     JMP     $+2		 ;очистить очередь команд
008C  58		     nmigen: POP     AX
008D  CD 02			     INT     02			 ;сгенерировать NMI
008F  CF			     IRET
0090			     h_int1 endp


			     ;==========================================================================
			     ;обработчик прерывания int 07h (встречена команда сопроцессора ESC)
			     ;устанавливается загрузчиком эмулятора,
			     ;если используется сопроцессор с частотой 4МГц.

			     ;Данный обработчик совместно с обработчиком INT1 дает возможность работать с процессором
			     ;8086 на частоте 8МГц и с медленным 4-МГц 8087, автоматически переключаясь на 4МГц
			     ;только на время исполнения команд сопроцессора.
			     ;Поддерживается горячее переключение частоты 86+87 кнопкой РЕЖИМ (=TURBO) 4 <-> 8 МГц,
			     ;при работе на 4МГц обработчики не делают по командам сопроцессора переключения частоты.

			     ;Алгоритм. Если система работает на 8МГц, обработчик переключает частоту на 4МГц,
			     ;устанавливает пошаговое прерывание на свой обработчик INT1, запомнив адрес старого,
			     ;и делает рестарт команды сопроцессора, вызвавшей прерывание,
			     ;со включенным флагом пошагового режима и выключенным флагом прерывания по команде сопроцессора.
0090			     h_int7 proc far
0090  50			     PUSH    AX
0091  1E			     PUSH    DS
0092  33 C0			     XOR     AX,AX
0094  8E D8			     MOV     DS,AX		 ;установить DS на таблицу векторов прерываний
			     assume DS:INT_TBL
0096  A1 0004r			     MOV     AX,int1_ip		;прочесть IP обработчика INT 1 (пошаговый режим)
0099  36: A3 0000r		     MOV     SS:bckp_int1_ip,AX	;сохранить IP INT 1 в области данных эмулятора (E800:0000)
009D  A1 0006r			     MOV     AX,int1_cs		;прочесть CS обработчика INT 1 (пошаговый режим)
00A0  36: A3 0002r		     MOV     SS:bckp_int1_cs,AX	;сохранить CS INT 1 в области данных эмулятора (E800:0002)
00A4  B8 002Er			     MOV     AX,offset h_int1
00A7  A3 0004r			     MOV     int1_ip,AX
00AA  8C 0E 0006r		     MOV     int1_cs,CS		;установить обработчик прерывания пошагового режима INT1 на h_int1
00AE  1F			     POP     DS
			     assume DS:DATA
00AF  87 E5			     XCHG    SP,BP
			     ;теперь распределение в стеке такое
			     ;[BP]=AX
			     ;[BP+2]=IP
			     ;[BP+4]=CS
			     ;[BP+6]=FLAGS
			     ;SP'=BP до прерывания
00B1  8B 46 06			     MOV     AX,[BP+06]		 ;прочесть флаги, бывшие до прерывания
00B4  36: A3 0004		     MOV     SS:[0004],AX	 ;сохранить старые флаги в E800:0004
00B8  C6 46 07 F1		     MOV     BYTE PTR [BP+07],0F1h ;уст старшие флаги: БЕЗ int 07h на ESC, TF=1 (пошаговый режим ВКЛ), режим реальный, OF,DF,IF=0
00BC  FF 4E 02			     DEC     WORD PTR [BP+02]	 ;уст IP на байт опкода, вызвавшего прерывание
00BF  E4 C8			     IN	     AL,vg1_infport	 ;прочли порт информации о команде 1843вг1
00C1  8A E0			     MOV     AH,AL
00C3  E4 C8			     IN	     AL,vg1_infport
00C5  F6 C4 0F			     TEST    AH,0Fh		 ;были ли сегментные префиксы?
00C8  74 03			     JZ	     nopref		 ;нет - уйти
00CA  FF 4E 02			     DEC     WORD PTR [BP+02]	 ;были - сделать IP указывающим на префикс (начало команды)
00CD  87 E5		     nopref: XCHG    SP,BP
00CF  E4 62			     IN	     AL,62h		 ;2-й порт конфигурации компьютера
00D1  24 D7			     AND     AL,0D7h		 ;сбросить бит 5 (разрешить переключение синхронизации кнопкой TURBO)
								 ;и бит 3 - ошибочно (в него нет записи)
00D3  E6 62			     OUT     62h,AL
00D5  A8 10			     TEST    AL,10h		 ;частота сопроцессора 8МГц?
00D7  75 0A			     JNZ     exit7		 ;да - уйти
00D9  E4 61			     IN	     AL,61h		 ;иначе прочесть 1-й порт конфигурации компьютера
00DB  A8 10			     TEST    AL,10h		 ;режим синхронизатора 8МГц?
00DD  74 04			     JZ	     exit7		 ;нет - уйти
00DF  E6 E0			     OUT     0E0h,AL		 ;иначе переключить синхронизатор
00E1  EB 00			     JMP     $+2		 ;очистить очередь команд
00E3			     exit7:  STM			 ;ОТКЛЮЧИТЬ int 07h на каждую ESC команду
00E3  F1			     db	0F1h
00E4  FC			     CLD
00E5  58			     POP     AX
00E6  CF			     IRET			 ;рестарт команды (теперь ее исполнит сопроцессор)
00E7			     h_int7 endp


			     ;==========================================================================
			     ;обработчик сдвигов SHIFT immediate
			     ;формат команд:
			     ;(SHIFT) reg/mem,immed8
			     ;первый байт:
			     ;C0 - сдвигаемый операнд 8 бит
			     ;С1 - сдвигаемый операнд 16 бит
			     ;второй байт: mod-reg-rm
			     ;тип сдвига определяется reg:
			     ;000 - ROL
			     ;001 - ROR
			     ;010 - RCL
			     ;011 - RCR
			     ;100 - SHL
			     ;101 - SHR
			     ;110 - SHL, как и для 100 (а по справочникам - ничего)
			     ;111 - SAR
			     ;mod и rm аналогичны обычной кодировке для одноадресных команд
			     ;последний байт - число, на которое нужно сдвинуть
			     assume ss:SHADOW_STACK
00E7			     h_SHIFT proc near
00E7  80 CC 02			     OR	     AH,02		 ;установить, что это команда SHIFT, для дальнейшей обработки
00EA  C4 9E 0014r		     LES     BX,[BP+offset saved_IP]	;BX указ. на след. за опкодом байт обрабатываемой команды
00EE  8C C1			     MOV     CX,ES		 ;ES=CX:= CS обрабатываемой команды
00F0  E8 0108			     CALL    h_ADRMODE		 ;возвращает адрес первого операнда в SI и сегмент операнда в ES
00F3  E8 00D5			     CALL    fetch_arg2		 ;возвращает второй операнд в CL или CX
00F6  E8 00B0			     CALL    fetch_arg1		 ;возвращает первый операнд в DL или DX
00F9  80 E1 1F			     AND     CL,01Fh		 ;ограничить величину сдвига
00FC  8B F8			     MOV     DI,AX
00FE  83 E7 38			     AND     DI,38h		 ;вычленяем из mod-reg-rm команды только reg
0101  D1 EF			     SHR     DI,1
0103  D1 EF			     SHR     DI,1		 ;превратили reg в указатель при переходе
0105  F6 C4 01			     TEST    AH,01		 ;8 или 16 бит команда? (переходы чуть дальше)
0108  50			     PUSH    AX
0109  8A A6 0018r		     MOV     AH,[BP+offset saved_FLAGS]	      ;старые флаги
010D  74 06			     JZ	     shft8		 ;8 бит - уйти
010F  9E			     SAHF			 ;записать старые флаги (мл.часть)
0110  2E: FF A5	050Fr		     JMP     CS:[DI+SHIFTABLE16] ;переход по таблице сдвига в 16-разрядном случае

							 ;8-разр. случай
0115  9E		     shft8:  SAHF			 ;записать старые флаги (мл.часть)
0116  2E: FF A5	051Fr		     JMP     CS:[DI+SHIFTABLE8]	 ;переход по таблице сдвига в 8-разрядном случае

			     ;8-битный операнд		      ;rm:
011B  D2 C2		     ROL8:   ROL     DL,CL		 ;000
011D  EB 3F 90			     JMP     set_flag
0120  D2 CA		     ROR8:   ROR     DL,CL		 ;001
0122  EB 3A 90			     JMP     set_flag
0125  D2 D2		     RCL8:   RCL     DL,CL		 ;010
0127  EB 35 90			     JMP     set_flag
012A  D2 DA		     RCR8:   RCR     DL,CL		 ;011
012C  EB 30 90			     JMP     set_flag
012F  D2 E2		     SHL8:   SHL     DL,CL		 ;100 и 110
0131  EB 2B 90			     JMP     set_flag
0134  D2 EA		     SHR8:   SHR     DL,CL		 ;101
0136  EB 26 90			     JMP     set_flag
0139  D2 FA		     SAR8:   SAR     DL,CL		 ;111
013B  EB 21 90			     JMP     set_flag

			     ;16-битный операнд		      ;rm:
013E  D3 C2		     ROL16:  ROL     DX,CL		 ;000
0140  EB 1C 90			     JMP     set_flag
0143  D3 CA		     ROR16:  ROR     DX,CL		 ;001
0145  EB 17 90			     JMP     set_flag
0148  D3 D2		     RCL16:  RCL     DX,CL		 ;010
014A  EB 12 90			     JMP     set_flag
014D  D3 DA		     RCR16:  RCR     DX,CL		 ;011
014F  EB 0D 90			     JMP     set_flag
0152  D3 E2		     SHL16:  SHL     DX,CL		 ;100 и 110
0154  EB 08 90			     JMP     set_flag
0157  D3 EA		     SHR16:  SHR     DX,CL		 ;101
0159  EB 03 90			     JMP     set_flag
015C  D3 FA		     SAR16:  SAR     DX,CL		 ;111

			     ;запись в сохраненный в теневом стеке регистр флагов, запись результата и выход
015E			     set_flag:
015E  9F			     LAHF			 ;выгрузить младшие флаги после сдвига в AH
015F  8A 86 0019r		     MOV     AL,[BP+offset saved_FLAGS+1]	;прочесть старшие флаги из стека (какие были до команды)
0163  70 1E			     JO	     set_OF		 ;OF хранится в старших флагах, он уст? да - уйти
0165  24 F7			     AND     AL,0F7h		 ;нет - сбросить OF=0
0167  86 E0		     wr_fl:  XCHG    AH,AL
0169  89 86 0018r		     MOV     [BP+offset	saved_FLAGS],AX	      ;записать в стек правильное значение флагов после сдвига
016D  58			     POP     AX			 ;восстановить первый байт команды в AL и AH (с уст. битом 1)
016E  E8 0016			     CALL    write_result	 ;записать результат сдвига в память или регистр
0171  A1 0006r			     MOV     AX,cmd_len		 ;прочесть полную длину операндов команды
0174  01 86 0014r		     ADD     [BP+offset	saved_IP],AX	   ;увеличить IP на эту длину, чтобы он указывал на след команду
				     END_CMD
0178  C6 06 0005r 00		     MOV     reg_or_mem,00	 ;очистить, т.к. не инициализируется при входе - для последующих вызовов
017D  8B E5			     MOV     SP,BP		 ;восстановить указатель стека на сохраненные при входе регистры
017F  07			     POP     ES
0180  61			     POPA
0181  1F			     POP     DS			 ;восстановить регистры
0182  CF			     IRET			 ;закончить обработку команды, восстановить CS и SS

0183  0C 08		     set_of: OR	     AL,08		 ;установить OF=1
0185  EB E0			     JMP     wr_fl

0187			     write_result:
			     ;запись результата сдвига в требуемое место (туда же, где был и источник)
0187  F6 06 0005r 02		     TEST    reg_or_mem,02	 ;операнд находится в памяти или в регистре?
018C  90			     NOP
018D  75 0D			     JNZ     wr_mem		 ;в памяти - уйти
018F  F6 C4 01			     TEST    AH,01		 ;8 или 16 бит операнд?
0192  74 04			     JZ	     wr8reg		 ;8 бит - уйти
0194  89 52 10			     MOV     [BP+SI+10h],DX	 ;запись результата в 16-бит регистр
								 ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
0197  C3			     RET

0198  88 52 10		     wr8reg: MOV     [BP+SI+10h],DL	 ;запись результата в 8-бит регистр
								 ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
019B  C3			     RET
019C			     wr_mem:				 ;запись в память
019C  F6 C4 01			     TEST    AH,01		 ;8 или 16 бит операнд?
019F  74 04			     JZ	     wr8mem		 ;8 бит - уйти
01A1  26: 89 14			     MOV     ES:[SI],DX		 ;запись слова результата в память
01A4  C3			     RET

01A5  26: 88 14		     wr8mem: MOV     ES:[SI],DL		 ;запись байта результата в память
01A8  C3			     RET
01A9			     h_SHIFT endp


			     ;==========================================================================
			     ;fetch_arg1
			     ;осуществляет выборку операнда в регистр DL либо DX
			     ;вызывается третьим после h_ADRMODE и fetch_arg2 в обработчиках SHIFT и IMUL
			     ;при вызове:
			     ;ES указывает на правильный сегмент в памяти с учетом префиксов команды
			     ;SI - адрес операнда
01A9			     fetch_arg1	proc near
01A9  F6 06 0005r 02		     TEST    reg_or_mem,02	 ;операнд находится в памяти или в регистре?
01AE  90			     NOP
01AF  75 0D			     JNZ     rd_mem		 ;в памяти - уйти
								 ;операнд в регистре
01B1  F6 C4 01			     TEST    AH,01		 ;8 или 16 бит операнд?
01B4  75 04			     JNZ     rd16reg		 ;16 бит - уйти
01B6  8A 52 10			     MOV     DL,[BP+SI+10h]	 ;выборка операнда из 8-бит регистра
								 ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
01B9  C3			     RET

01BA			     rd16reg:
01BA  8B 52 10			     MOV     DX,[BP+SI+10h]	 ;выборка операнда из 16-бит регистра
01BD  C3			     RET
								 ;выборка из памяти
01BE  F6 C4 01		     rd_mem: TEST    AH,01		 ;8 или 16 бит операнд?
01C1  75 04			     JNZ     rd16mem		 ;16 бит - уйти
01C3  26: 8A 14			     MOV     DL,ES:[SI]		 ;выборка 8-бит операнда из памяти
01C6  C3			     RET

01C7			     rd16mem:
01C7  26: 8B 14			     MOV     DX,ES:[SI]		 ;выборка 16-бит операнда из памяти
01CA  C3			     RET
01CB			     fetch_arg1	endp


			     ;==========================================================================
			     ;fetch_arg2
			     ;выборка второго операнда команды в регистр CX или CL
			     ;вызывается после h_ADRMODE в обработчиках SHIFT и IMUL
			     ;при вызове:
			     ;AL - первый байт команды, AH - первый байт команды с правками
			     ;CX - CS команды, BX - указывает на следующий за опкодом байт команды
			     ;плюс см. возвращаемое h_ADRMODE
			     ;при возврате:
			     ;cmd_len - реальная длина команды (увеличенная на байт или слово)
			     ;CL/CX - второй операнд
01CB			     fetch_arg2	proc near
01CB  06			     PUSH    ES
01CC  8E C1			     MOV     ES,CX
01CE  03 1E 0006r		     ADD     BX,cmd_len		 ;передвинуть BX на байт, следующий за первым операндом команды
01D2  F6 C4 01			     TEST    AH,01		 ;8 или 16 бит операнд? (для SHIFT)
01D5  75 09			     JNZ     arg16bit		 ;16 бит - уйти
01D7  FE 06 0006r		     INC     BYTE PTR cmd_len	 ;увеличить длину команды на байт
01DB  26: 8A 0F			     MOV     CL,ES:[BX]		 ;прочесть байтовый второй операнд в CL
01DE  07			     POP     ES
01DF  C3			     RET
01E0			     arg16bit:
01E0  F6 C4 02			     TEST    AH,02		 ;это команда SHIFT?
01E3  74 0C			     JZ	     no_sft		 ;нет - уйти
01E5  FE 06 0006r		     INC     BYTE PTR cmd_len	 ;увеличить длину команды на байт
01E9  26: 8A 0F			     MOV     CL,ES:[BX]		 ;прочесть байтовый второй операнд в CL
01EC  91			     XCHG    CX,AX
01ED  98			     CBW
01EE  91			     XCHG    CX,AX		 ;превратить операнд в слово, сохраняя знак
01EF  07			     POP     ES
01F0  C3			     RET

			     ;не SHIFT и 16-бит
01F1  80 06 0006r 02	     no_sft: ADD     BYTE PTR cmd_len,2	 ;увеличить длину команды на 2 байта
01F6  26: 8B 0F			     MOV     CX,ES:[BX]		 ;прочесть слово второго операнда в CL
01F9  07			     POP     ES
01FA  C3			     RET
01FB			     fetch_arg2	endp


			     ;==========================================================================
			     ;h_ADRMODE
			     ;выборка адреса операнда
			     ;вызывается во всех обработчиках, кроме ENTER
			     ;при вызове:
			     ;BX указывает на следующий за опкодом байт команды,
			     ;в ES и CX - CS команды
			     ;при возврате:
			     ;SI - смещение операнда, если он в памяти,
			     ;и полуфабрикат для выборки регистра, если он в регистре
			     ;ES - сегмент операнда
			     ;AL - второй (mod-reg-rm) байт команды
			     ;AH - первый (опкод) байт команды
			     ;В reg_or_mem:
			     ;бит 0 установлен - адресация по регистру BP
			     ;бит 1 установлен - операнд в памяти (не в регистре)
			     ;В cmd_len:
			     ;1=регистровый операнд, непосредственный операнд
			     ;2=байт смещения
			     ;3=слово смещения
			     ;позже это будет использоваться как информация о длине команды

01FB			     h_ADRMODE proc near
01FB  26: 8A 07			     MOV     AL,ES:[BX]		 ;прочитали второй (mod-reg-rm) байт команды, т.к. IP указывает на следующий за опкодом
01FE  3C C0			     CMP     AL,0C0h		 ;операнды находятся в памяти? (если да, то два старших бита не могут быть 11, т.е. меньше C0h)
0200  72 21			     JB	     inmem		 ;да - уйти

								 ;нет - случай регистровых операндов
								 ;формируем адрес нужного регистра, сохраненного в стеке, по полю rm
								 ;порядок регистров обратен по отношению к тому, как они сохранены по PUSHA
								 ;важно, что здесь мы НЕ получим истинного адреса регистра, а только полуфабрикат
0202  C6 06 0006r 01		     MOV     BYTE PTR cmd_len,01
0207  8B F0			     MOV     SI,AX
0209  F6 C4 01			     TEST    AH,01		 ;8 или 16 разрядный операнд?
020C  74 08			     JZ	     inreg8		 ;8 - уйти
020E  83 E6 07			     AND     SI,07h		 ;оставить только три младших бита rm
0211  D1 E6			     SHL     SI,1		 ;т.к. регистры в стеке расположены по словам
0213  F7 DE			     NEG     SI			 ;т.к. регистры идут в обратном порядке
0215  C3			     RET

			     ;8-разрядный операнд в регистре
0216			     inreg8:
0216  83 E6 03			     AND     SI,03h		 ;оставить только 2 младших бита rm
0219  D1 E6			     SHL     SI,1		 ;т.к. регистры расположены по словам
021B  F7 DE			     NEG     SI			 ;т.к. регистры идут в обратном порядке
021D  A8 04			     TEST    AL,04		 ;L-половинки или H-половинки регистров?
021F  74 01			     JZ	     l_reg
0221  46			     INC     SI			 ;H-половинки - адрес на 1 больше
0222  C3		     l_reg:  RET

			     ;операнды находятся в памяти
0223  80 0E 0005r 02	     inmem:  OR	     reg_or_mem,02
0228  90			     NOP
0229  33 F6			     XOR     SI,SI
022B  8A D0			     MOV     DL,AL		 ;mod-reg-rm -> DL
022D  80 E2 C7			     AND     DL,0C7h		 ;обнулить поле reg
0230  80 FA 06			     CMP     DL,06		 ;06=00-xxx-110 - это прямая адресация со смещ=0?
0233  74 5C			     JZ	     word_offset	 ;да - уйти
0235  8B F8			     MOV     DI,AX
0237  83 E7 07			     AND     DI,07h		 ;иначе использовать rm как индекс в таблице
023A  D1 E7			     SHL     DI,1		 ;таблице слов, а не байт, т.ч. сдвинем на 1 разряд
023C  2E: FF A5	04FFr		     JMP     CS:[DI+RM_TABLE]	 ;переход по таблице обработчиков rm

			     ;обработка режимов косвенной адресации к памяти
			     ;сюда (на разные строки) попадаем из таблицы RM_TABLE
			     ;если затрагивается BP, бит 1 байта reg-or-mem уст в 1
0241  03 B6 000Ar	     RM0:    ADD     SI,[BP+offset saved_BX]	   ;точка входа rm=0: BX+SI+смещ
0245  03 B6 0004r	     RM4:    ADD     SI,[BP+offset saved_SI]	   ;точка входа rm=4: SI+смещ
0249  EB 2B 90			     JMP     check_offset

024C  80 0E 0005r 01	     RM3:    OR	     reg_or_mem,01		   ;точка входа rm=3: BP+DI+смещ
0251  90			     NOP
0252  03 B6 0006r		     ADD     SI,[BP+offset saved_BP]
0256  03 B6 0002r	     RM5:    ADD     SI,[BP+offset saved_DI]	   ;точка входа rm=5: DI+смещ
025A  EB 1A 90			     JMP     check_offset

025D  03 B6 0004r	     RM2:    ADD     SI,[BP+offset saved_SI]	   ;точка входа rm=2: BP+SI+смещ
0261  03 B6 0006r	     RM6:    ADD     SI,[BP+offset saved_BP]	   ;точка входа rm=6: BP+смещ
0265  80 0E 0005r 01		     OR	     reg_or_mem,01
026A  90			     NOP
026B  EB 09 90			     JMP     check_offset

026E  03 B6 0002r	     RM1:    ADD     SI,[BP+offset saved_DI]	   ;точка входа rm=1: BX+DI+смещ
0272  03 B6 000Ar	     RM7:    ADD     SI,[BP+offset saved_BX]	   ;точка входа rm=7: BX+смещ

			     ;общая часть обработки косвенной адресации после прибавления значений регистров
0276			     check_offset:
0276  A8 C0			     TEST    AL,0C0h		 ;mod 01,10? (есть смещение?)
0278  74 25			     JZ	     no_offset		 ;нет - уйти
027A  A8 40			     TEST    AL,40h		 ;mod 01? (один байт смещения?)
027C  74 13			     JZ	     word_offset	 ;нет - уйти
			     ;считаем, что байт смещения один
027E  8B D0			     MOV     DX,AX		 ;сохраняем КОП и mod-reg-rm
0280  26: 8A 47	01		     MOV     AL,ES:[BX+01]	 ;читаем байт смещения
0284  98			     CBW			 ;превращаем в слово с учетом знака (т.к. прибавляем к 16бит регистру)
0285  03 F0			     ADD     SI,AX		 ;прибавили смещение
0287  8B C2			     MOV     AX,DX		 ;восстановили КОП и mod-reg-rm
0289  C6 06 0006r 02		     MOV     BYTE PTR cmd_len,02
028E  EB 14 90			     JMP     check_pref		 ;перейти к выбору сегмента

			     ;прямая адресация со смещением =0
			     ;два байта смещения или непосредственная словная адресация
0291			     word_offset:
0291  C6 06 0006r 03		     MOV     BYTE PTR cmd_len,03
0296  26: 8B 57	01		     MOV     DX,ES:[BX+01]	 ;прочитать слово, следующее сразу за mod-reg-rm
029A  03 F2			     ADD     SI,DX		 ;прибавили его к SI (как смещение или как значение)
029C  EB 06 90			     JMP     check_pref		 ;перейти к выбору сегмента

			     ;сюда попадем, если нет смещения
029F			     no_offset:
029F  C6 06 0006r 01		     MOV     BYTE PTR cmd_len,01

			     ;установка регистра ES правильным сегментом для доступа к операнду
02A4			     check_pref:
02A4  8A 16 0001r		     MOV     DL,BYTE PTR cmd_inf+1 ;прочесть байт информации о команде, считанный из 1843вг1
02A8  F6 C2 0F			     TEST    DL,0Fh		 ;были ли сегментные префиксы?
02AB  75 16			     JNZ     seg_pref		 ;да - обработать
02AD  F6 06 0005r 01		     TEST    reg_or_mem,01	 ;использовали ли регистр BP?
02B2  90			     NOP
02B3  75 05			     JNZ     ss_pref		 ;да - установить сегмент SS
02B5			     ds_pref:
02B5  8E 86 0012r		     MOV     ES,[BP+offset saved_DS]	   ;установить ES значением DS, которое было до команды
02B9  C3			     RET

			     ;если использовался регистр BP либо был префикс SS,
			     ;адресоваться нужно по сегменту стека, каким он был до вызова команды (в основной паре SS:SP)
02BA			     ss_pref:
				     RESS			 ;переключаемся на основную пару SS:SP
02BA  F1			     db	0f1h
02BB  FA			     CLI
02BC  8C D2			     MOV     DX,SS		 ;сохранили стековый сегмент
				     SHSS			 ;переключаемся обратно на теневую пару SS':SP'
02BE  F1			     db	0F1h
02BF  FB			     STI
02C0  8E C2			     MOV     ES,DX		 ;установить ES значением SS, которое было до вызова команды
02C2  C3			     RET

			     ;обработка сегментных префиксов
02C3			     seg_pref:
02C3  F6 C2 08			     TEST    DL,08		 ;есть префикс CS?
02C6  90			     NOP
02C7  75 11			     JNZ     cs_pref
02C9  F6 C2 04			     TEST    DL,04		 ;есть префикс DS?
02CC  90			     NOP
02CD  75 E6			     JNZ     ds_pref
02CF  F6 C2 02			     TEST    DL,02		 ;есть префикс ES?
02D2  90			     NOP
02D3  74 E5			     JZ	     ss_pref		 ;нет - значит префикс SS
02D5  8E 86 0000r		     MOV     ES,[BP+offset saved_ES]	    ;есть - установить ES значением ES, которое было до вызова команды
02D9  C3			     RET
02DA			     cs_pref:
02DA  8E 86 0016r		     MOV     ES,[BP+offset saved_CS]	    ;установить ES значением CS, которое было до вызова команды
02DE  C3			     RET
02DF			     h_ADRMODE endp


			     ;==========================================================================
			     ;обработчик ENTER
			     ;команда создания стекового кадра процедуры
			     ;формат: enter nvar, nest
			     ;C8 iw 00 если ENTER nvar,0
			     ;C8 iw ib если ENTER nvar,nest и nest<>0
			     ;nvar - кол-во слов памяти под переменные
			     ;nest - уровень вложенности процедуры

			     ;команда ENTER предполагает следующий формат стекового кадра
			     ;(см. Морс С.П., Алберт Д.Д. Архитектура микропроцессора 80286. М.:Радио и связь, 1990 - стр.99):
			     ;SS:BP указывает на начало (высший адрес) для стекового кадра
			     ;[SS:BP], первый байт стекового кадра, содержит
			     ;"динамическую связь" - указатель на начало стекового кадра процедуры, вызвавшей данную
			     ;[SS:BP-2] и далее содержат "индикаторы" - указатели на начало стекового кадра всех активных процедур:
			     ;-процедура первого уровня вложенности содержит индикатор из одного слова,
			     ; указывающий на свое же слово динамической связи (т.е. на следующее слово [SS:BP], высшее в кадре)
			     ;-процедура второго уровня вложенности содержит индикатор из двух слов -
			     ; [SS:BP-2] указывает на начало стекового кадра родительской процедуры,
			     ; [SS:BP-4] указывает на свое же слово динамической связи
			     ;-процедура 3-го уровня вложенности содержит индикатор из трех слов -
			     ; [SS:BP-2] - начало стекового кадра процедуры-дедушки, родительской для родительской
			     ; [SS:BP-4] - на начало стекового кадра родительской процедуры
			     ; [SS:BP-6] - на свое же слово динамической связи
			     ;и так далее. Т.е n элементов индикатора стекового кадра процедуры уровня n+1
			     ;аналогичны индикатору родительской процедуры.
			     ;После индикаторов в стековом кадре располагается память под переменные.
			     ;В книге Морса все пояснено на картинках и с примерами на Паскале.

			     ;команда ENTER обновляет BP (чтобы он указывал на начало созданного стекового кадра),
			     ;SP (резервируя место в стеке под созданный кадр),
			     ;и записывает в начало созданного стекового кадра "динамическую связь" и "индикатор"

02DF			     h_ENTER proc near
02DF  C4 9E 0014r		     LES BX,[BP+offset saved_IP] ;BX указ. на след. за опкодом байт обрабатываемой команды,ES:=CS команды
02E3  26: 8B 17			     MOV DX,ES:[BX]		 ;DX:=nvar (кол-во байт памяти под переменные)
02E6  26: 8A 4F	02		     MOV CL,ES:[BX+02]		 ;CL:=nest (уровень вложенности)
02EA  32 ED			     XOR CH,CH
				     RESS			 ;основной стек
02EC  F1			     db	0f1h
02ED  FA			     CLI
02EE  8B FC			     MOV DI,SP			 ;DI:=SP указатель основного стека
				     SHSS			 ;обратно в теневой стек
02F0  F1			     db	0F1h
02F1  FB			     STI
02F2  8B B6 0006r		     MOV SI,[BP+offset saved_BP] ;SI:=BP до команды ENTER (указатель на стековый кадр процедуры, вызвавшей данную)
				     ;DS ранее был установлен на SS до команды ENTER (до входа в прерывание)
02F6  8D 7D FE			     LEA DI,[DI-02]		 ;DI:=указатель на начало создаваемого стекового кадра
02F9  89 BE 0006r		     MOV [BP+offset saved_BP],DI ;установили BP-после-команды-ENTER на начало нового стекового кадра
				     RESS			 ;основной стек
02FD  F1			     db	0f1h
02FE  FA			     CLI
02FF  8C D3			     MOV BX,SS			 ;BX:=SS сегмент основного стека
				     SHSS			 ;обратно в теневой стек
0301  F1			     db	0F1h
0302  FB			     STI
0303  8E C3			     MOV ES,BX			 ;ES:=SS основного стека
0305  26: 89 35			     MOV ES:[DI],SI		 ;записали указатель на стековый кадр родительской (вызвавшей) процедуры в создаваемый стековый кадр
0308  8B DF			     MOV BX,DI			 ;BX:=указатель на начало создаваемого стекового кадра
030A  80 F9 00			     CMP CL,00			 ;уровень вложенности в команде ENTER =0?
030D  74 15			     JZ	var_allocate		 ;да - уйти на распределение стека под переменные
			     ;случай ненулевой вложенности
030F  FD			     STD			 ;строковые команды:= на уменьшение
0310  1E			     PUSH DS
0311  06			     PUSH ES
0312  1F			     POP DS			 ;DS=ES:= SS основного стека
0313  49			     DEC CX			 ;число элементов индикатора=уровню вложенности,
								 ;а нам нужно скопировать все элементы индикатора родительской процедуры, у нее уровень на 1 меньше
0314  8D 74 FE			     LEA SI,[SI-02]		 ;SI:=смещение на начало индикатора родительской процедуры
								 ;(на 1 слово меньше начала родительского стекового кадра, на которое указывал BP до команды ENTER)
0317  8D 7D FE			     LEA DI,[DI-02]		 ;DI:=смещение в основном стеке под индикатор (еще один новый операнд уже после заталкивания туда BP)
031A  80 F9 00			     CMP CL,00			 ;уровень вложенности 1? (в этом случае копировать нечего)
031D  74 02			     JZ	last_indic		 ;да - уйти на запись последнего элемента индикатора
031F  F3> A5			     REPZ MOVSW			 ;скопировать индикатор родительской процедуры в создаваемый кадр
0321			     last_indic:
0321  89 1D			     MOV [DI],BX		 ;записать в создаваемый кадр последний элемент индикатора для вложенности >0 -
								 ;указатель на начало создаваемого стекового кадра
0323  1F			     POP DS			 ;DS:=SS основного стека
0324			     var_allocate:
0324  2B FA			     SUB DI,DX			 ;продвинуть указатель основного стека (в DI) с учетом места в стековом кадре под кол-во переменных,
								 ;указанных в команде ENTER, под дин.связь и индикаторы указатель (DI) уже модифицирован
				     RESS			 ;основной стек
0326  F1			     db	0f1h
0327  FA			     CLI
0328  8B E7			     MOV SP,DI			 ;обновить непосредственно указатель основного стека
				     SHSS			 ;обратно в теневой стек
032A  F1			     db	0F1h
032B  FB			     STI
032C  83 86 0014r 03		     ADD WORD PTR [BP+offset saved_IP],03 ;увеличить IP на длину команды
				     END_CMD
0331  C6 06 0005r 00		     MOV     reg_or_mem,00	 ;очистить, т.к. не инициализируется при входе - для последующих вызовов
0336  8B E5			     MOV     SP,BP		 ;восстановить указатель стека на сохраненные при входе регистры
0338  07			     POP     ES
0339  61			     POPA
033A  1F			     POP     DS			 ;восстановить регистры
033B  CF			     IRET			 ;закончить обработку команды, восстановить CS и SS
033C			     h_ENTER endp


			     ;==========================================================================
			     ;обработчик IMUL immediate
033C			     h_IMUL proc near
033C  C4 9E 0014r		     LES     BX,[BP+offset saved_IP]	   ;BX указ. на след. за опкодом байт обрабатываемой команды
0340  8C C1			     MOV     CX,ES		 ;ES=CX= CS обрабатываемой команды
0342  E8 FEB6			     CALL    h_ADRMODE		 ;возвращает адрес первого операнда в SI и сегмент операнда в ES
0345  E8 FE83			     CALL    fetch_arg2		 ;возвращает второй операнд в CL или CX
0348  E8 FE5E			     CALL    fetch_arg1		 ;возвращает первый операнд в DL или DX
034B  91			     XCHG    CX,AX		 ;AX=второй (непосредственный) операнд, CX = первые 2 байта команды
034C  F7 EA			     IMUL    DX			 ;(DX,AX)=(AX)*(DX)
034E  70 26			     JO	     set_OF_CF		 ;есть переполнение?
0350  81 A6 0018r F7FE		     AND     [BP+offset	saved_FLAGS],0F7FEh    ;нет - сбросить OF и CF
0356  8B F1		     write:  MOV     SI,CX		 ;SI=первые 2 байта команды (второй на младших адресах)
0358  83 E6 38			     AND     SI,38h		 ;высечь поле reg из mod-reg-rm
035B  D1 EE			     SHR     SI,1
035D  D1 EE			     SHR     SI,1		 ;сдвинуть к началу регистра, с учетом того, что адресоваться по словам
035F  F7 DE			     NEG     SI			 ;т.к. регистры в поле reg идут в обратном порядке по отношению к стеку
0361  89 42 10			     MOV     [BP+SI+10h],AX	 ;запись результата в 16-бит регистр
								 ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
0364  A1 0006r			     MOV     AX,cmd_len		 ;прочесть полную длину операндов команды
0367  01 86 0014r		     ADD     [BP+offset	saved_IP],AX	    ;увеличить IP на эту длину, чтобы он указывал на след команду
				     END_CMD
036B  C6 06 0005r 00		     MOV     reg_or_mem,00	 ;очистить, т.к. не инициализируется при входе - для последующих вызовов
0370  8B E5			     MOV     SP,BP		 ;восстановить указатель стека на сохраненные при входе регистры
0372  07			     POP     ES
0373  61			     POPA
0374  1F			     POP     DS			 ;восстановить регистры
0375  CF			     IRET			 ;закончить обработку команды, восстановить CS и SS

			     ;если получили флаг OF
0376			     set_OF_CF:
0376  81 8E 0018r 0801		     OR	     [BP+offset	saved_FLAGS],0801h    ;установить OF и CF
037C  EB D8			     JMP     write
037E			     h_IMUL endp


			     ;==========================================================================
			     ;обработчик BOUND
			     ;формат команды:
			     ;BOUND reg16 mem
			     ;62 mod-reg-rm mem1 mem2
			     ;поскольку команда двухадресная, mod-reg-rm указывает на ВТОРОЙ аргумент
037E			     h_BOUND proc near
037E  80 CC 01			     OR	     AH,01			;установить 16-бит тип операнда
0381  C4 9E 0014r		     LES     BX,[BP+offset saved_IP]	;BX указ. на след. за опкодом байт обрабатываемой команды,ES:=CS команды
0385  26: 80 3F	BF		     CMP     ES:BYTE PTR [BX],0BFh	;операнд в регистре? (mod в mod-reg-rm = 11?)
0389  77 27			     JA	     h_EXIT			;да - уйти на выход из команды
038B  E8 FE6D			     CALL    h_ADRMODE			;возвращает адрес ВТОРОГО операнда в SI и сегмент операнда в ES
038E  26: 8B 0C			     MOV     CX,ES:[SI]			;CX:= операнд из памяти - нижняя граница массива
0391  26: 8B 54	02		     MOV     DX,ES:[SI+02]		;DX:= следующее за ним слово - верхняя граница массива
0395  8B F0			     MOV     SI,AX			;SI=первые 2 байта команды (второй на младших адресах)
0397  83 E6 38			     AND     SI,38h			;высечь поле reg из mod-reg-rm
039A  D1 EE			     SHR     SI,1
039C  D1 EE			     SHR     SI,1			;сдвинуть к началу регистра, с учетом того, что адресоваться по словам
039E  F7 DE			     NEG     SI				;т.к. регистры в поле reg идут в обратном порядке по отношению к стеку
03A0  8B 42 10			     MOV     AX,[BP+SI+10h]		;чтение операнда-регистра
									;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
03A3  3B C8			     CMP     CX,AX			;сравнение с нижней границей
03A5  77 16			     JA	     em_INT5			;если вышли за нее (н.граница>числа) - генерировать INT5
03A7  3B C2			     CMP     AX,DX			;сравнение с верхней границей
03A9  77 12			     JA	     em_INT5			;если вышли за нее (число>в.границы) - генерировать INT5
03AB  A1 0006r			     MOV     AX,cmd_len			;иначе считать длину операндов команды
03AE  01 86 0014r		     ADD     [BP+offset	saved_IP],AX	;увеличить IP в стеке на эту длину, чтобы он указывал на начало след.команды

			     ;обработчик ненайденной команды
			     ;также завершающая фаза обработчика BOUND
03B2			     h_EXIT: END_CMD
03B2  C6 06 0005r 00		     MOV     reg_or_mem,00	 ;очистить, т.к. не инициализируется при входе - для последующих вызовов
03B7  8B E5			     MOV     SP,BP		 ;восстановить указатель стека на сохраненные при входе регистры
03B9  07			     POP     ES
03BA  61			     POPA
03BB  1F			     POP     DS			 ;восстановить регистры
03BC  CF			     IRET			 ;закончить обработку команды, восстановить CS и SS

			     ;BOUND: случай выхода за границу массива
			     ;эмуляция действий процессора при вызове INT 5
03BD			     em_INT5:
03BD  8B 86 0014r		     MOV     AX,[BP+offset saved_IP]	;считать IP в стеке (указывающий на второй байт эмулируемой команды)
03C1  48			     DEC     AX				;теперь IP указывает на опкод
03C2  F6 06 0001r 0F		     TEST    BYTE PTR cmd_inf+1,0Fh	;были ли префиксы у команды?
03C7  74 01			     JZ	     get_CS
03C9  48			     DEC     AX				;если были префиксы, сделать IP указывающим на байт префикса
									;теперь IP точно указывает на начало команды
03CA  8B 9E 0016r	     get_CS: MOV     BX,[BP+offset saved_CS]	;BX:=CS команды
03CE  8B 8E 0018r		     MOV     CX,[BP+offset saved_FLAGS]	;CX:=флаги команды
				     RESS				;переключаемся на основную пару SS:SP
03D2  F1			     db	0f1h
03D3  FA			     CLI
03D4  51			     PUSH    CX				;как бы pushf
03D5  53			     PUSH    BX				;как бы push cs
03D6  50			     PUSH    AX				;как бы push ip - все в основном стеке, как при уходе на прерывание
				     SHSS				;обратно на теневую пару SS':SP'
03D7  F1			     db	0F1h
03D8  FB			     STI
03D9  33 C0			     XOR     AX,AX
03DB  8E C0			     MOV     ES,AX			;ES указывает на таблицу векторов прерываний
03DD  26: A1 0014r		     MOV     AX,ES:int5_ip		;начало записи для INT 5 в таблице векторов
03E1  89 86 0014r		     MOV     [BP+offset	saved_IP],AX	;IP стека эмулятора:= IP обработчика INT 5
03E5  26: A1 0016r		     MOV     AX,ES:int5_cs
03E9  89 86 0016r		     MOV     [BP+offset	saved_CS],AX	;CS стека эмулятора:= CS обработчика INT 5
03ED  80 A6 0019r FC		     AND     BYTE PTR [BP+offset saved_FLAGS+1],0FCh   ;сбросить IF и TF во флагах в стеке, как при уходе на прерывание
03F2  90			     NOP
03F3  EB BD			     JMP     h_EXIT			;возврат из эмулятора
03F5			     h_BOUND endp


			     ;==========================================================================
			     ;таблица адресов программ эмуляции команд
			     ;адрес в таблице соответствует опкоду
03F5			     OP_table label byte
03F5  0100*(00)			     db	     256 DUP (0)
			     org offset	OP_table+62h
0457  02			     db	     02				;62h - BOUND
			     org offset	OP_table+69h
045E  04			     db	     04				;69h - IMUL immediate
			     org offset	OP_table+6bh
0460  04			     db	     04				;6bh - IMUL S immediate
			     org offset	OP_table+0c0h
04B5  06			     db	     06				;c0h - SHIFT immediate
04B6  06			     db	     06				;c1h - SHIFT immediate
			     org offset	OP_table+0c8h
04BD  08			     db	     08				;c8h - ENTER
			     org offset	OP_table+256

			     ;таблица адресов обработчиков команд
04F5			     CMD_TABLE label word
04F5  03B2r			     DW	     offset h_EXIT		;обработчик ненайденной команды
04F7  037Er			     DW	     offset h_BOUND		;обрабочик BOUND (смещ.2)
04F9  033Cr			     DW	     offset h_IMUL		;обработчик IMUL (смещ.4)
04FB  00E7r			     DW	     offset h_SHIFT		;обработчик сдвигов (смещ.6)
04FD  02DFr			     DW	     offset h_ENTER		;обработчик ENTER (смещ.8)

			     ;таблица адресов обработчиков режимов косвенной адресации rm  (mod=00,01,10)
04FF			     RM_TABLE label word
04FF  0241r			     DW	     offset RM0			;rm=0
0501  026Er			     DW	     offset RM1			;rm=1
0503  025Dr			     DW	     offset RM2			;rm=2
0505  024Cr			     DW	     offset RM3			;rm=3
0507  0245r			     DW	     offset RM4			;rm=4
0509  0256r			     DW	     offset RM5			;rm=5
050B  0261r			     DW	     offset RM6			;rm=6
050D  0272r			     DW	     offset RM7			;rm=7

			     ;таблица адресов обработчиков команд сдвига в 16-разрядном случае
			     ;NB! по справочнику Морса reg=6 (010) не используется,
			     ;а здесь reg=6 аналогично reg=4 (100)
050F			     SHIFTABLE16 label word
050F  013Er			     DW	     offset ROL16		;000 - ROL
0511  0143r			     DW	     offset ROR16		;001 - ROR
0513  0148r			     DW	     offset RCL16		;010 - RCL
0515  014Dr			     DW	     offset RCR16		;011 - RCR
0517  0152r			     DW	     offset SHL16		;100 - SHL
0519  0157r			     DW	     offset SHR16		;101 - SHR
051B  0152r			     DW	     offset SHL16		;110 - ничего
051D  015Cr			     DW	     offset SAR16		;111 - SAR

			     ;таблица адресов обработчиков команд сдвига в 8-разрядном случае
			     ;NB! по справочнику Морса reg=6 (010) не используется,
			     ;а здесь reg=6 аналогично reg=4 (100)
051F			     SHIFTABLE8	label word
051F  011Br			     DW	     offset ROL8	       ;000 - ROL
0521  0120r			     DW	     offset ROR8	       ;001 - ROR
0523  0125r			     DW	     offset RCL8	       ;010 - RCL
0525  012Ar			     DW	     offset RCR8	       ;011 - RCR
0527  012Fr			     DW	     offset SHL8	       ;100 - SHL
0529  0134r			     DW	     offset SHR8	       ;101 - SHR
052B  012Fr			     DW	     offset SHL8	       ;110 - ничего
052D  0139r			     DW	     offset SAR8	       ;111 - SAR

			     ;располагается по адресу 052Fh и вероятно возник из-за выравнивания следующего сегмента по слову или параграфу
			     ;      DB      00h

052F			     _TEXT ends

0000			     DUMMYSEG segment word public 'CODE'
			     ;этого в памяти эмулятора уже не будет, это пойдет в E800:0
0000  08*(00)			     DB	     8 dup (0)
0008			     DUMMYSEG ends
			     end h_int6

Symbol Name			  Type	 Value

??DATE				  Text	 "04-21-22"
??FILENAME			  Text	 "M286_TXT"
??TIME				  Text	 "06:08:01"
??VERSION			  Number 0500
@CPU				  Text	 0707H
@CURSEG				  Text	 DUMMYSEG
@FILENAME			  Text	 M286_TXT
@WORDSIZE			  Text	 2
ARG16BIT			  Near16 _TEXT:01E0
BCKP_INT1_CS			  Alias	 CMD_WORD
BCKP_INT1_IP			  Alias	 CMD_INF
CHECK_OFFSET			  Near16 _TEXT:0276
CHECK_PREF			  Near16 _TEXT:02A4
CMD_INF				  Word	 DATA:0000
CMD_LEN				  Word	 DATA:0006
CMD_TABLE			  Word	 _TEXT:04F5
CMD_WORD			  Word	 DATA:0002
CS_PREF				  Near16 _TEXT:02DA
DS_PREF				  Near16 _TEXT:02B5
EM_INT5				  Near16 _TEXT:03BD
ENDNMI				  Near16 _TEXT:0072
EXIT7				  Near16 _TEXT:00E3
FETCH_ARG1			  Near16 _TEXT:01A9
FETCH_ARG2			  Near16 _TEXT:01CB
GET_CS				  Near16 _TEXT:03CA
H_ADRMODE			  Near16 _TEXT:01FB
H_BOUND				  Near16 _TEXT:037E
H_ENTER				  Near16 _TEXT:02DF
H_EXIT				  Near16 _TEXT:03B2
H_IMUL				  Near16 _TEXT:033C
H_INT1				  Far16	 _TEXT:002E
H_INT6				  Far16	 _TEXT:0000
H_INT7				  Far16	 _TEXT:0090
H_SHIFT				  Near16 _TEXT:00E7
INMEM				  Near16 _TEXT:0223
INREG8				  Near16 _TEXT:0216
INT1_CS				  Word	 INT_TBL:0006
INT1_IP				  Word	 INT_TBL:0004
INT5_CS				  Word	 INT_TBL:0016
INT5_IP				  Word	 INT_TBL:0014
IRQ13				  Near16 _TEXT:0074
LAST_INDIC			  Near16 _TEXT:0321
L_REG				  Near16 _TEXT:0222
NMIGEN				  Near16 _TEXT:008C
NOPREF				  Near16 _TEXT:00CD
NO_OFFSET			  Near16 _TEXT:029F
NO_SFT				  Near16 _TEXT:01F1
OP_TABLE			  Byte	 _TEXT:03F5
RCL16				  Near16 _TEXT:0148
RCL8				  Near16 _TEXT:0125
RCR16				  Near16 _TEXT:014D
RCR8				  Near16 _TEXT:012A
RD16MEM				  Near16 _TEXT:01C7
RD16REG				  Near16 _TEXT:01BA
RD_MEM				  Near16 _TEXT:01BE
REG_OR_MEM			  Byte	 DATA:0005
RM0				  Near16 _TEXT:0241
RM1				  Near16 _TEXT:026E
RM2				  Near16 _TEXT:025D
RM3				  Near16 _TEXT:024C
RM4				  Near16 _TEXT:0245
RM5				  Near16 _TEXT:0256
RM6				  Near16 _TEXT:0261
RM7				  Near16 _TEXT:0272
RM_TABLE			  Word	 _TEXT:04FF
ROL16				  Near16 _TEXT:013E
ROL8				  Near16 _TEXT:011B
ROR16				  Near16 _TEXT:0143
ROR8				  Near16 _TEXT:0120
SAR16				  Near16 _TEXT:015C
SAR8				  Near16 _TEXT:0139
SAVED_AX			  Word	 SHADOW_STACK:0010
SAVED_BP			  Word	 SHADOW_STACK:0006
SAVED_BX			  Word	 SHADOW_STACK:000A
SAVED_CS			  Word	 SHADOW_STACK:0016
SAVED_CX			  Word	 SHADOW_STACK:000E
SAVED_DI			  Word	 SHADOW_STACK:0002
SAVED_DS			  Word	 SHADOW_STACK:0012
SAVED_DX			  Word	 SHADOW_STACK:000C
SAVED_ES			  Word	 SHADOW_STACK:0000
SAVED_FLAGS			  Word	 SHADOW_STACK:0018
SAVED_IP			  Word	 SHADOW_STACK:0014
SAVED_SI			  Word	 SHADOW_STACK:0004
SAVED_SP			  Word	 SHADOW_STACK:0008
SEG_PREF			  Near16 _TEXT:02C3
SET_FLAG			  Near16 _TEXT:015E
SET_OF				  Near16 _TEXT:0183
SET_OF_CF			  Near16 _TEXT:0376
SHFT8				  Near16 _TEXT:0115
SHIFTABLE16			  Word	 _TEXT:050F
SHIFTABLE8			  Word	 _TEXT:051F
SHL16				  Near16 _TEXT:0152
SHL8				  Near16 _TEXT:012F
SHR16				  Near16 _TEXT:0157
SHR8				  Near16 _TEXT:0134
SS_PREF				  Near16 _TEXT:02BA
VAR_ALLOCATE			  Near16 _TEXT:0324
VG1_INFPORT			  Number 00C8
VG1_OPCODE			  Number 00CE
WORD_OFFSET			  Near16 _TEXT:0291
WR8MEM				  Near16 _TEXT:01A5
WR8REG				  Near16 _TEXT:0198
WRITE				  Near16 _TEXT:0356
WRITE_RESULT			  Near16 _TEXT:0187
WR_FL				  Near16 _TEXT:0167
WR_MEM				  Near16 _TEXT:019C

Macro Name

CLM
END_CMD
RESS
SHSS
STM

Groups & Segments		  Bit Size Align  Combine Class

DATA				  16  0008  AT E800
DUMMYSEG			  16  0008 Word	  Public  CODE
INT_TBL				  16  0018  AT 0000
SHADOW_STACK			  16  001A  AT FFFF
_TEXT				  16  052F Word	  Public  CODE


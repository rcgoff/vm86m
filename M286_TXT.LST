Turbo Assembler	 Version 5.0	    04-20-22 00:13:15	    Page 1
M286_TXT.ASM



			     .286c				 ;включить инструкции	реального  +
			     режима 286


0000			     DATA segment at 0E800h
0000  ????		     cmd_inf	     dw	     ?		 ;слово информации о прерванной   +
			     команде из 1843ВГ1. Содержит сегментные префиксы
0002  ????		     cmd_word	     dw	     ?		 ;два первых байта команды,	    +
			     считываются из 1843ВГ1
0004  ??				     db	     ?		 ;на этот	байт ссылок нет
0005  ??		     reg_or_mem	     db	     ?		 ;байт флажков информации об	    +
			     эмулируемой команде
0006  ????		     cmd_len	     dw	     ?		 ;длина операндов	команды

			     bckp_int1_ip    equ     cmd_inf
			     bckp_int1_cs    equ     cmd_word
0008			     DATA ends

0000			     INT_TBL segment at	0h		 ;таблица векторов прерываний
			     org 01h*4				 ;INT 01h - прерывание пошагового	    +
			     режима, вызывается	после каждой	команды,	если TF=1
0004  ????		     int1_ip dw	     ?
0006  ????		     int1_cs dw	     ?
			     org 05h*4				 ;INT 05h - прерывание, генерируемое  +
			     по команде BOUND
0014  ????		     int5_ip dw	     ?
0016  ????		     int5_cs dw	     ?
0018			     INT_TBL ends

0000			     SHADOW_STACK segment at 0EC00h
0000  ????		     saved_ES	     dw	     ?
0002  ????		     saved_DI	     dw	     ?
0004  ????		     saved_SI	     dw	     ?
0006  ????		     saved_BP	     dw	     ?
0008  ????		     saved_SP	     dw	     ?
000A  ????		     saved_BX	     dw	     ?
000C  ????		     saved_DX	     dw	     ?
000E  ????		     saved_CX	     dw	     ?
0010  ????		     saved_AX	     dw	     ?
0012  ????		     saved_DS	     dw	     ?
0014  ????		     saved_IP	     dw	     ?
0016  ????		     saved_CS	     dw	     ?
0018  ????		     saved_FLAGS     dw	     ?
001A			     SHADOW_STACK ends

			     END_CMD macro			 ;завершающий этап обработки	    +
			     команды, повторяется во всех четырех обработчиках
				     MOV     reg_or_mem,00	 ;очистить E800:5, т.к. не			    +
			     инициализируется при входе	- для последующих	команд
				     MOV     SP,BP		 ;восстановить указатель стека    +
			     на сохраненные при	входе регистры
				     POP     ES
				     POPA
				     POP     DS			 ;восстановить регистры
				     IRET			 ;закончить обработку	команды,	    +
			     восстановить CS и SS
				     endm

0000			     _TEXT segment word	public 'CODE'

			     ;обработчик прерывания	int 06h	(неизвестная	команда)
			     ;оказались в стеке,	адресуемом теневой парой
			     ;SS':SP'=E800:4000	(EC000h)
			     ;CS:IP, сохраненные в стеке, указывают на следующий за  +
			     опкодом байт команды
			     assume cs:_TEXT
0000			     h_int6 proc far
0000  1E			     PUSH    DS
0001  60			     PUSHA			 ;AX,CX,DX,BX,SP,BP,SI,DI
0002  06			     PUSH    ES
0003  8B EC			     MOV     BP,SP		 ;BP - ук-ль стека после сохранения +
			     всех регистров
			     ;теперь имеем
			     ;[BP]=ES
			     ;[BP+2]=DI
			     ;[BP+4]=SI
			     ;[BP+6]=BP
			     ;[BP+8]=SP
			     ;[BP+0Ah]=BX
			     ;[BP+0Ch]=DX
			     ;[BP+0Eh]=CX
			     ;[BP+10h]=AX
			     ;[BP+12h]=DS
			     ;[BP+14h]=IP
			     ;[BP+16h]=CS
			     ;[BP+18h]=FLAGS
0005  8C D0			     MOV     AX,SS
0007  8E D8			     MOV     DS,AX		 ;DS:=SS=E800,сегмент стека	при входе в+
			     прерывание (установлено загрузчиком эмулятора)
			     assume DS:DATA			 ;теперь по DS можно адресоваться  +
			     к	области данных эмулятора E800:0 (ну и к стеку)
0009  E4 C8			     IN	     AL,0C8h		 ;c8h -	порт информации о команде	    +
			     1843вг1
000B  8A E0			     MOV     AH,AL
000D  E4 C8			     IN	     AL,0C8h
000F  A3 0000r			     MOV     cmd_inf,AX		 ;сохранили считанное	из порта	    +
			     информации о команде в DS:0 (E800:0)
0012  E4 CE			     IN	     AL,0CEh		 ;ceh -	порт первого	слова команды   +
			     1843вг1
0014  8A E0			     MOV     AH,AL
0016  E4 CE			     IN	     AL,0CEh
0018  A3 0002r			     MOV     cmd_word,AX	 ;сохранили считанное	из порта	    +
			     слова	команды в DS:2 (E800:2)
001B  8A C4			     MOV     AL,AH		 ;оставили только	первый байт
001D  BB 03D7r			     MOV     BX,offset op_table	 ;адрес таблицы опкодов
0020  2E: D7			     XLAT    CS:op_table	 ;AL:=номер обработчика	в таблице   +
			     обработчиков команд
0022  32 FF			     XOR     BH,BH
0024  8A D8			     MOV     BL,AL
0026  2E: FF A7	04D7r		     JMP     CS:[BX+CMD_TABLE]	 ;адрес таблицы адресов		    +
			     обработчиков команд
								 ;перешли на обработчик		    +
			     соответствующей команды
002B			     h_int6 endp

002B  B8 0000s			     MOV     AX,STACK		 ;адрес настраивается	при		    +
			     загрузке EXE-шника - т.е. это был сегмент. В файле - 0053h
								 ;возможно, использован как	    +
			     указатель	конца кода эмулятора для загрузчика

			     ;обработчик INT 01h (пошаговый режим)
			     ;устанавливается при первом вызове сопроцессорной  +
			     команды в обработчике INT 7
			     ;вызывается после рестарта команды, вызвавшей INT 7
			     ;восстанавливает старый вектор прерывания INT	01h,
			     ;переключает процессор	обратно на 8МГц и включает	    +
			     прерывание INT 7
			     ;от любой сопроцессорной команды.
			     ;кроме того, если выполнившаяся команда			    +
			     сопроцессора вызвала аппаратное прерывание от него
			     ;(IRQ13), генерирует программное NMI
002E			     h_int1 proc far
002E  50			     PUSH    AX
002F  1E			     PUSH    DS
0030  06			     PUSH    ES
0031  33 C0			     XOR     AX,AX
0033  8E D8			     MOV     DS,AX		 ;уст DS на таблицу	векторов	    +
			     прерываний
			     assume DS:INT_TBL
0035  B8 E800			     MOV     AX,0E800h
0038  8E C0			     MOV     ES,AX		 ;уст ES на область	данных		    +
			     эмулятора	E800
003A  26: A1 0000r		     MOV     AX,ES:bckp_int1_ip	 ;прочесть сохраненный IP INT 1
003E  A3 0004r			     MOV     int1_ip,AX		 ;записать в таблицу векторов
0041  26: A1 0002r		     MOV     AX,ES:bckp_int1_cs	 ;прочесть сохраненный CS INT 1
0045  A3 0006r			     MOV     int1_cs,AX		 ;записать в таблицу векторов
0048  26: A1 0004		     MOV     AX,ES:[0004]	 ;прочесть сохраненные флаги,	    +
			     бывшие до вызова INT	7
004C  07			     POP     ES
004D  1F			     POP     DS
			     assume DS:DATA
004E  87 EC			     XCHG    BP,SP
			     ;теперь распределение в стеке такое
			     ;[BP]=AX
			     ;[BP+2]=IP
			     ;[BP+4]=CS
			     ;[BP+6]=FLAGS
			     ;SP'=BP до прерывания
0050  89 46 06			     MOV     [BP+06],AX		 ;записать старые	флаги
0053  87 EC			     XCHG    BP,SP		 ;восстановить BP и SP
0055  B0 0A			     MOV     AL,0Ah		 ;команда контроллеру			    +
			     прерываний: чтение	регистра IRR (запросов на		    +
			     прерывание)
0057  E6 A0			     OUT     0A0h,AL		 ;A0h -	второй контроллер		    +
			     прерываний
0059  EB 00			     JMP     $+2		 ;очистить очередь команд
005B  E4 A0			     IN	     AL,0A0h		 ;прочитать регистр запросов на   +
			     прерывание 2-го контроллера
005D  A8 20			     TEST    AL,20h		 ;было прерывание	от			    +
			     сопроцессора? (IRQ 13)
005F  75 13			     JNZ     IRQ13		 ;да - уйти на 0074
0061  9B			     WAIT			 ;иначе ждать	готовности		    +
			     сопроцессора
				     CLM			 ;включить INT 07 на каждую ESC		    +
			     команду
0062  F1			     db	0F1h
0063  FD			     STD
0064  E4 62			     IN	     AL,62h
0066  0C 40			     OR	     AL,40h		 ;установить триггер блокировки  +
			     очереди команд процессора
0068  E6 62			     OUT     62h,AL
006A  A8 10			     TEST    AL,10h		 ;частота сопроцессора 8мгц?
006C  75 04			     JNZ     endnmi		 ;да - уйти на 72
006E  E6 E0			     OUT     0E0h,AL		 ;иначе переключить			    +
			     синхронизатор
0070  EB 00			     JMP     $+2		 ;очистить очередь команд
0072  58		     endnmi: POP     AX
0073  CF			     IRET

			     ;если было	прерывание от сопроцессора IRQ13
0074  B0 20		     IRQ13:  MOV     AL,20h
0076  E6 A0			     OUT     0A0h,AL		 ;команда 2-му	контроллеру		    +
			     прерывания "обычный конец прерывания"
0078  B0 62			     MOV     AL,62h
007A  E6 20			     OUT     20h,AL		 ;команда 1-му	контроллеру		    +
			     прерывания "специальный конец прерывания" - сброс	    +
			     каскадируемого IRQ2
				     CLM			 ;включить INT 07 на каждую ESC		    +
			     команду
007C  F1			     db	0F1h
007D  FD			     STD
007E  E4 62			     IN	     AL,62h
0080  0C 40			     OR	     AL,40h
0082  E6 62			     OUT     62h,AL		 ;установить триггер блокировки  +
			     очереди команд процессора
0084  A8 10			     TEST    AL,10h		 ;частота сопроцессора 8мгц?
0086  75 04			     JNZ     nmigen		 ;да - уйти на 8C
0088  E6 E0			     OUT     0E0h,AL		 ;иначе переключить			    +
			     синхронизатор
008A  EB 00			     JMP     $+2		 ;очистить очередь команд
008C  58		     nmigen: POP     AX
008D  CD 02			     INT     02			 ;вновь сгенерировать	NMI уже с	    +
			     настоящим	обработчиком (сохраненным по первому	    +
			     вызову int07h)
008F  CF			     IRET
0090			     h_int1 endp


			     ;обработчик прерывания	int 07h	(встречена команда	    +
			     сопроцессора ESC)
			     ;устанавливается загрузчиком эмулятора,
			     ;если используется	сопроцессор с частотой 4МГц.

			     ;Данный обработчик	совместно с обработчиком INT1 дает+
			     возможность работать с	процессором
			     ;8086 на	частоте 8МГц и с медленным	4-МГц 8087,			    +
			     автоматически	переключаясь на 4МГц
			     ;только на	время исполнения	команд сопроцессора.
			     ;Поддерживается горячее переключение частоты 86+87	    +
			     кнопкой РЕЖИМ (=TURBO)	4 <-> 8	МГц,
			     ;при работе на 4МГц обработчики не делают	по		    +
			     командам сопроцессора переключения	частоты.

			     ;Алгоритм.	Если система	работает на 8МГц, обработчик +
			     переключает частоту на	4МГц,
			     ;устанавливает пошаговое прерывание на свой		    +
			     обработчик INT1,	запомнив адрес старого,
			     ;и делает рестарт команды сопроцессора, вызвавшей    +
			     прерывание,
			     ;со включенным	флагом пошагового режима и		    +
			     выключенным флагом прерывания по команде		    +
			     сопроцессора.
0090			     h_int7 proc far
0090  50			     PUSH    AX
0091  1E			     PUSH    DS
0092  33 C0			     XOR     AX,AX
0094  8E D8			     MOV     DS,AX		 ;установить DS на таблицу		    +
			     векторов прерываний
			     assume DS:INT_TBL
0096  A1 0004r			     MOV     AX,int1_ip		;прочесть IP обработчика INT	1	    +
			     (пошаговый режим)
0099  36: A3 0000r		     MOV     SS:bckp_int1_ip,AX	;сохранить IP INT 1 в	области данных +
			     эмулятора	(E800:0000)
009D  A1 0006r			     MOV     AX,int1_cs		;прочесть CS обработчика INT	1	    +
			     (пошаговый режим)
00A0  36: A3 0002r		     MOV     SS:bckp_int1_cs,AX	;сохранить CS INT 1 в	области данных +
			     эмулятора	(E800:0002)
00A4  B8 002Er			     MOV     AX,offset h_int1
00A7  A3 0004r			     MOV     int1_ip,AX
00AA  8C 0E 0006r		     MOV     int1_cs,CS		;установить обработчик		    +
			     прерывания пошагового режима INT1  на E000:02Eh
00AE  1F			     POP     DS
			     assume DS:DATA
00AF  87 E5			     XCHG    SP,BP
			     ;теперь распределение в стеке такое
			     ;[BP]=AX
			     ;[BP+2]=IP
			     ;[BP+4]=CS
			     ;[BP+6]=FLAGS
			     ;SP'=BP до прерывания
00B1  8B 46 06			     MOV     AX,[BP+06]		 ;прочесть флаги, бывшие до	    +
			     прерывания
00B4  36: A3 0004		     MOV     SS:[0004],AX	 ;сохранить старые флаги в	E800:0004
00B8  C6 46 07 F1		     MOV     BYTE PTR [BP+07],0F1h ;уст старшие флаги: режим без	int +
			     07h на ESC, реальный, OF,DF,IF=0, TF=1 (пошаговый режим ВКЛ)
00BC  FF 4E 02			     DEC     WORD PTR [BP+02]	 ;уст IP на байт опкода,	вызвавшего+
			     прерывание
00BF  E4 C8			     IN	     AL,0C8h		 ;c8h -	порт информации о команде	    +
			     1843вг1
00C1  8A E0			     MOV     AH,AL
00C3  E4 C8			     IN	     AL,0C8h
00C5  F6 C4 0F			     TEST    AH,0Fh		 ;были ли	сегментные префиксы?
00C8  74 03			     JZ	     nopref		 ;нет - уйти на CD
00CA  FF 4E 02			     DEC     WORD PTR [BP+02]	 ;были - сделать IP указывающим на  +
			     префикс (начало команды)
00CD  87 E5		     nopref: XCHG    SP,BP
00CF  E4 62			     IN	     AL,62h		 ;2-й порт	конфигурации компьютера
00D1  24 D7			     AND     AL,0D7h		 ;сбросить бит 5 (разрешить		    +
			     переключение синхронизации кнопкой	TURBO)
								 ;и бит 3 -	ошибочно (в него нет	    +
			     записи)
00D3  E6 62			     OUT     62h,AL
00D5  A8 10			     TEST    AL,10h		 ;частота сопроцессора 8МГц?
00D7  75 0A			     JNZ     exit7		 ;да - уйти на 0E3
00D9  E4 61			     IN	     AL,61h		 ;иначе прочесть 1-й порт		    +
			     конфигурации компьютера
00DB  A8 10			     TEST    AL,10h		 ;режим синхронизатора 8МГц?
00DD  74 04			     JZ	     exit7		 ;нет - уйти на 0E3
00DF  E6 E0			     OUT     0E0h,AL		 ;иначе переключить			    +
			     синхронизатор
00E1  EB 00			     JMP     $+2		 ;очистить очередь команд
00E3			     exit7:  STM			 ;ОТКЛЮЧИТЬ int 07 на каждую ESC	    +
			     команду
00E3  F1			     db	0F1h
00E4  FC			     CLD
00E5  58			     POP     AX
00E6  CF			     IRET			 ;рестарт команды	(теперь ее	    +
			     исполнит сопроцессор)
00E7			     h_int7 endp

			     ;обработчик сдвигов SHIFT	immediate
			     ;формат команд:
			     ;(SHIFT) reg/mem,immed8
			     ;первый байт:
			     ;C0 - сдвигаемый	операнд 8 бит
			     ;С1 - сдвигаемый операнд	16 бит
			     ;второй байт: mod-reg-rm
			     ;тип сдвига определяется reg:
			     ;000 - ROL
			     ;001 - ROR
			     ;010 - RCL
			     ;011 - RCR
			     ;100 - SHL
			     ;101 - SHR
			     ;110 - SHL, как	и для 100 (а по справочникам	- ничего)
			     ;111 - SAR
			     ;mod и rm	аналогичны обычной кодировке для			    +
			     одноадресных команд
			     ;последний байт - число,	на которое нужно сдвинуть
			     assume ss:SHADOW_STACK
00E7			     h_SHIFT proc near
00E7  80 CC 02			     OR	     AH,02		 ;установить,	что это команда SHIFT, +
			     для дальнейшей обработки
00EA  C4 9E 0014r		     LES     BX,[BP+offset saved_IP]	;BX указ. на след. за опкодом    +
			     байт обрабатываемой команды
00EE  8C C1			     MOV     CX,ES		 ;ES=CX= CS обрабатываемой команды
00F0  E8 0105			     CALL    h_ADRMODE		 ;возвращает адрес первого	    +
			     операнда в SI и сегмент операнда в ES
00F3  E8 00D2			     CALL    fetch_arg2		 ;возвращает второй операнд в CL    +
			     или CX
00F6  E8 00AD			     CALL    fetch_arg1		 ;возвращает первый операнд в DL    +
			     или DX
00F9  80 E1 1F			     AND     CL,01Fh		 ;ограничить величину	сдвига
00FC  8B F8			     MOV     DI,AX
00FE  83 E7 38			     AND     DI,+38h		  ;вычленяем из mod-reg-rm команды	    +
			     только reg
0101  D1 EF			     SHR     DI,1
0103  D1 EF			     SHR     DI,1		 ;превратили reg в указатель при	    +
			     переходе
0105  F6 C4 01			     TEST    AH,01		 ;8 или 16 бит команда?
0108  50			     PUSH    AX
0109  8A A6 0018r		     MOV     AH,[BP+offset saved_FLAGS]	      ;старые флаги
010D  74 06			     JZ	     shft8		 ;8 бит - уйти на 115
010F  9E			     SAHF			 ;записать старые	флаги (мл.часть)
0110  2E: FF A5	04F1r		     JMP     CS:[DI+SHIFTABLE16] ;переход по таблице сдвига в	    +
			     16-разрядном случае

							 ;8-разр. случай
0115  9E		     shft8:  SAHF			 ;записать старые	флаги (мл.часть)
0116  2E: FF A5	0501r		     JMP     CS:[DI+SHIFTABLE8]	 ;переход по таблице сдвига в	    +
			     8-разрядном случае

			     ;8-битный операнд
011B  D2 C2		     ROL8:   ROL     DL,CL		 ;000
011D  EB 3F 90			     JMP     set_flag
0120  D2 CA		     ROR8:   ROR     DL,CL		 ;001
0122  EB 3A 90			     JMP     set_flag
0125  D2 D2		     RCL8:   RCL     DL,CL		 ;010
0127  EB 35 90			     JMP     set_flag
012A  D2 DA		     RCR8:   RCR     DL,CL		 ;011
012C  EB 30 90			     JMP     set_flag
012F  D2 E2		     SHL8:   SHL     DL,CL		 ;100 и 110
0131  EB 2B 90			     JMP     set_flag
0134  D2 EA		     SHR8:   SHR     DL,CL		 ;101
0136  EB 26 90			     JMP     set_flag
0139  D2 FA		     SAR8:   SAR     DL,CL		 ;111
013B  EB 21 90			     JMP     set_flag

			     ;16-битный операнд
013E  D3 C2		     ROL16:  ROL     DX,CL		 ;000
0140  EB 1C 90			     JMP     set_flag
0143  D3 CA		     ROR16:  ROR     DX,CL		 ;001
0145  EB 17 90			     JMP     set_flag
0148  D3 D2		     RCL16:  RCL     DX,CL		 ;010
014A  EB 12 90			     JMP     set_flag
014D  D3 DA		     RCR16:  RCR     DX,CL		 ;011
014F  EB 0D 90			     JMP     set_flag
0152  D3 E2		     SHL16:  SHL     DX,CL		 ;100 и 110
0154  EB 08 90			     JMP     set_flag
0157  D3 EA		     SHR16:  SHR     DX,CL		 ;101
0159  EB 03 90			     JMP     set_flag
015C  D3 FA		     SAR16:  SAR     DX,CL		 ;111

			     ;запись в сохраненный в	теневом стеке регистр	    +
			     флагов, запись	результата и	выход
015E			     set_flag:
015E  9F			     LAHF			 ;выгрузить младшие флаги после   +
			     сдвига в AH
015F  8A 46 19			     MOV     AL,[BP+0019h]	 ;прочесть старшие флаги из стека+
			     (какие были до команды)
0162  70 1C			     JO	     set_OF		 ;OF хранится в старших	флагах, он  +
			     уст? да - 183
0164  24 F7			     AND     AL,0F7h		 ;нет - сбросить OF=0
0166  86 E0		     wr_fl:  XCHG    AH,AL
0168  89 46 18			     MOV     [BP+0018h],AX	 ;записать в стек правильное	    +
			     значение флагов после сдвига
016B  58			     POP     AX			 ;восстановить первый	байт	    +
			     команды в AL и AH	(с уст. битом 1)
016C  E8 0015			     CALL    write_result	 ;записать результат сдвига в	    +
			     память или регистр
016F  A1 0006r			     MOV     AX,cmd_len		 ;прочесть полную	длину		    +
			     операндов	команды из E800:6
0172  01 46 14			     ADD     [BP+0014h],AX	 ;увеличить IP	на эту длину,	чтобы  +
			     он указывал на	след команду
				     END_CMD
0175  C6 06 0005r 00		     MOV     reg_or_mem,00	 ;очистить E800:5, т.к. не			    +
			     инициализируется при входе	- для последующих	команд
017A  8B E5			     MOV     SP,BP		 ;восстановить указатель стека    +
			     на сохраненные при	входе регистры
017C  07			     POP     ES
017D  61			     POPA
017E  1F			     POP     DS			 ;восстановить регистры
017F  CF			     IRET			 ;закончить обработку	команды,	    +
			     восстановить CS и SS

0180  0C 08		     set_of: OR	     AL,08		 ;установить OF=1
0182  EB E2			     JMP     wr_fl

0184			     write_result:
			     ;запись результата	сдвига в	требуемое место (туда	    +
			     же, где был и источник)
0184  F6 06 0005r 02		     TEST    reg_or_mem,02	 ;операнд находится в памяти или  +
			     в	регистре?
0189  90			     NOP
018A  75 0D			     JNZ     wr_mem		 ;в памяти - уйти на 019С
018C  F6 C4 01			     TEST    AH,01		 ;8 или 16 бит операнд?
018F  74 04			     JZ	     wr8reg		 ;8 бит - уйти на 0198
0191  89 52 10			     MOV     [BP+SI+10h],DX	 ;запись результата в 16-бит	    +
			     регистр
								 ;(смещение в SI - отрицательное,	с  +
			     10h и менее в стеке располагаются	РОН,	BP - вершина	    +
			     стека)
0194  C3			     RET

0195  88 52 10		     wr8reg: MOV     [BP+SI+10h],DL	  ;запись	результата в	8-бит	    +
			     регистр
								 ;(смещение в SI - отрицательное,	с  +
			     10h и менее в стеке располагаются	РОН,	BP - вершина	    +
			     стека)
0198  C3			     RET
0199			     wr_mem:				 ;запись в память
0199  F6 C4 01			     TEST    AH,01		 ;8 или 16 бит операнд?
019C  74 04			     JZ	     wr8mem		 ;8 бит - уйти на 01A5
019E  26: 89 14			     MOV     ES:[SI],DX		 ;запись слова результата в	    +
			     память
01A1  C3			     RET

01A2  26: 88 14		     wr8mem: MOV     ES:[SI],DL		 ;запись байта результата в	    +
			     память
01A5  C3			     RET
01A6			     h_SHIFT endp


			     ;осуществляет выборку операнда в регистр DL либо DX
			     ;вызывается третьим после 01FB, 01CB	в обработчиках SHIFT и+
			     IMUL
			     ;при вызове:
			     ;ES указывает на правильный сегмент в	памяти с	учетом+
			     префиксов	команды
			     ;SI - адрес операнда
01A6			     fetch_arg1	proc near
01A6  F6 06 0005r 02		     TEST    reg_or_mem,02	 ;операнд находится в памяти или  +
			     в	регистре?
01AB  90			     NOP
01AC  75 0D			     JNZ     rd_mem		 ;в памяти - уйти на 01BE
								 ;операнд в регистре
01AE  F6 C4 01			     TEST    AH,01		 ;8 или 16 бит операнд?
01B1  75 04			     JNZ     rd16reg		 ;16 бит - уйти на 01BA
01B3  8A 52 10			     MOV     DL,[BP+SI+10h]	 ;выборка операнда из 8-бит		    +
			     регистра
								 ;(смещение в SI - отрицательное,	с  +
			     10h и менее в стеке располагаются	РОН,	BP - вершина	    +
			     стека)
01B6  C3			     RET

01B7			     rd16reg:
01B7  8B 52 10			     MOV     DX,[BP+SI+10h]	 ;выборка операнда из 16-бит	    +
			     регистра
01BA  C3			     RET
								 ;выборка из памяти
01BB  F6 C4 01		     rd_mem: TEST    AH,01		 ;8 или 16 бит операнд?
01BE  75 04			     JNZ     rd16mem		 ;16 бит - уйти на 01BA
01C0  26: 8A 14			     MOV     DL,ES:[SI]		 ;выборка 8-бит операнда из	памяти
01C3  C3			     RET

01C4			     rd16mem:
01C4  26: 8B 14			     MOV     DX,ES:[SI]		 ;выборка 16-бит операнда из памяти
01C7  C3			     RET
01C8			     fetch_arg1	endp

			     ;выборка второго операнда команды в регистр CX или	CL
			     ;вызывается после h_ADRMODE	в обработчиках SHIFT и IMUL
			     ;при вызове:
			     ;AL - первый	байт команды, AH - первый байт команды с	    +
			     правками
			     ;CX - CS команды, BX - указывает на следующий за опкодом   +
			     байт команды
			     ;плюс см. возвращаемое h_ADRMODE
			     ;при возврате:
			     ;E800:6 - реальная	длина команды (увеличенная на байт	    +
			     или слово)
			     ;CL/CX - второй операнд
01C8			     fetch_arg2	proc near
01C8  06			     PUSH    ES
01C9  8E C1			     MOV     ES,CX
01CB  03 1E 0006r		     ADD     BX,cmd_len		 ;передвинуть BX на байт,		    +
			     следующий	за первым операндом команды
01CF  F6 C4 01			     TEST    AH,01		 ;8 или 16 бит операнд? (для SHIFT)
01D2  75 09			     JNZ     arg16bit		 ;16 бит - уйти на 1E0
01D4  FE 06 0006r		     INC     BYTE PTR cmd_len	 ;увеличить длину	команды на байт
01D8  26: 8A 0F			     MOV     CL,ES:[BX]		 ;прочесть байтовый второй	    +
			     операнд в CL
01DB  07			     POP     ES
01DC  C3			     RET
01DD			     arg16bit:
01DD  F6 C4 02			     TEST    AH,02		 ;это команда	SHIFT?
01E0  74 0C			     JZ	     no_sft		 ;нет - уйти на 1F1
01E2  FE 06 0006r		     INC     BYTE PTR cmd_len	 ;увеличить длину	команды на байт
01E6  26: 8A 0F			     MOV     CL,ES:[BX]		 ;прочесть байтовый второй	    +
			     операнд в CL
01E9  91			     XCHG    CX,AX
01EA  98			     CBW
01EB  91			     XCHG    CX,AX		 ;превратить операнд в слово,	    +
			     сохраняя знак
01EC  07			     POP     ES
01ED  C3			     RET

			     ;не SHIFT и 16-бит
01EE  80 06 0006r 00	     no_sft: ADD     BYTE PTR cmd_len,0	 ;увеличить длину	команды на 2	    +
			     байта
01F3  26: 8B 0F			     MOV     CX,ES:[BX]		 ;прочесть слово второго		    +
			     операнда в CL
01F6  07			     POP     ES
01F7  C3			     RET
01F8			     fetch_arg2	endp

			     ;выборка адреса операнда
			     ;вызывается во	всех обработчиках, кроме ENTER
			     ;при вызове:
			     ;BX указывает на следующий за опкодом	байт команды,
			     ;в ES и CX - CS команды
			     ;DS указывает на E800, стек	с E800:4000
			     ;при возврате:
			     ;SI - смещение операнда, если он в памяти,
			     ;и полуфабрикат для выборки	регистра, если он	в	    +
			     регистре
			     ;ES - сегмент операнда
			     ;AL - второй	(mod-reg-rm) байт команды
			     ;AH - первый	(опкод) байт команды
			     ;по адресу	E800:5 значение:
			     ;бит 0 установлен - адресация по регистру BP
			     ;бит 1 установлен - операнд в	памяти (не в регистре)
			     ;по адресу	E800:6 значение:
			     ;1=регистровый операнд, непосредственный	операнд
			     ;2=слово смещения
			     ;3=байт смещения
			     ;позже это	будет использоваться	как информация о	    +
			     длине	команды

01F8			     h_ADRMODE proc near
01F8  26: 8A 07			     MOV     AL,ES:[BX]		 ;прочитали второй (mod-reg-rm) байт	    +
			     команды, т.к. IP указывает на следующий за опкодом
01FB  3C C0			     CMP     AL,0C0h		 ;операнды находятся в памяти?	    +
			     (если да, то два старших	бита не могут быть 11, т.е.	    +
			     меньше C0h)
01FD  72 21			     JB	     inmem		 ;да - уйти на 223
								 ;нет - случай	регистровых		    +
			     операндов
								 ;формируем адрес	нужного		    +
			     регистра, сохраненного	в стеке, по полю rm
								 ;порядок регистров обратен по	    +
			     отношению	к тому, как они сохранены по PUSHA
								 ;важно, что здесь	мы НЕ получим    +
			     истинного	адреса регистра, а только полуфабрикат
01FF  C6 06 0006r 01		     MOV     BYTE PTR cmd_len,01
0204  8B F0			     MOV     SI,AX
0206  F6 C4 01			     TEST    AH,01		 ;8 или 16 разрядный операнд?
0209  74 08			     JZ	     inreg8		 ;8 - уйти на 216
020B  83 E6 07			     AND     SI,07h		 ;оставить только	три младших	    +
			     бита rm
020E  D1 E6			     SHL     SI,1		 ;т.к. регистры в стеке			    +
			     расположены по словам
0210  F7 DE			     NEG     SI			 ;т.к. регистры идут в обратном	    +
			     порядке
0212  C3			     RET

			     ;8-разрядный операнд в регистре
0213			     inreg8:
0213  83 E6 03			     AND     SI,03h		 ;оставить только	2 младших бита rm
0216  D1 E6			     SHL     SI,1		 ;т.к. регистры расположены по	    +
			     словам
0218  F7 DE			     NEG     SI			 ;т.к. регистры идут в обратном	    +
			     порядке
021A  A8 04			     TEST    AL,04		 ;L-половинки или H-половинки	    +
			     регистров?
021C  74 01			     JZ	     l_reg
021E  46			     INC     SI			 ;H-половинки - адрес на 1 больше
021F  C3		     l_reg:  RET

			     ;операнды находятся в памяти
0220  80 0E 0005r 02	     inmem:  OR	     reg_or_mem,02
0225  90			     NOP
0226  33 F6			     XOR     SI,SI
0228  8A D0			     MOV     DL,AL		 ;mod-reg-rm ->	DL
022A  80 E2 C7			     AND     DL,0C7h		 ;обнулить поле reg
022D  80 FA 06			     CMP     DL,06		 ;06=00-xxx-110	- это прямая адресация    +
			     со смещ=0?
0230  74 54			     JZ	     word_offset	 ;да - уйти на 291
0232  8B F8			     MOV     DI,AX
0234  83 E7 07			     AND     DI,07h		 ;иначе использовать rm как	индекс+
			     в	таблице
0237  D1 E7			     SHL     DI,1		 ;таблице слов, а не байт, т.ч.	    +
			     сдвинем на 1 разряд
0239  2E: FF A5	04E1r		     JMP     CS:[DI+RM_TABLE]	 ;переход по таблице			    +
			     обработчиков rm

			     ;обработка режимов	косвенной адресации к памяти
			     ;сюда (на разные строки)	попадаем из таблицы на 04ffh
			     ;если затрагивается BP, бит 1 E800:5 уст в	1
023E  03 76 0A		     RM0:    ADD     SI,[BP+000Ah]	 ;точка входа	rm=0: BX+SI+смещ (0A -	    +
			     адрес	BX в стеке)
0241  03 76 04		     RM4:    ADD     SI,[BP+0004]	 ;точка входа	rm=4: SI+смещ (04 -	адрес  +
			     SI	в стеке)
0244  EB 25 90			     JMP     check_offset
0247  80 0E 0005r 01	     RM3:    OR	     reg_or_mem,01	 ;точка входа	rm=3: BP+DI+смещ
024C  90			     NOP
024D  03 76 06			     ADD     SI,[BP+0006]	 ;06 - адрес BP в	стеке
0250  03 76 02		     RM5:    ADD     SI,[BP+0002]	 ;точка входа	rm=5: DI+смещ (02 -	адрес  +
			     DI	в стеке)
0253  EB 16 90			     JMP     check_offset
0256  03 76 04		     RM2:    ADD     SI,[BP+0004]	 ;точка входа	rm=2: BP+SI+смещ (04 -	    +
			     адрес	SI в стеке)
0259  03 76 06		     RM6:    ADD     SI,[BP+0006]	 ;точка входа	rm=6: BP+смещ (06 -	адрес  +
			     BP	в стеке)
025C  80 0E 0005r 01		     OR	     reg_or_mem,01
0261  90			     NOP
0262  EB 07 90			     JMP     check_offset
0265  03 76 02		     RM1:    ADD     SI,[BP+0002]	 ;точка входа	rm=1: BX+DI+смещ (02 -	    +
			     адрес	DI в стеке)
0268  03 76 0A		     RM7:    ADD     SI,[BP+000Ah]	 ;точка входа	rm=7: BX+смещ (0A -	адрес  +
			     BX	в стеке)

			     ;общая часть обработки косвенной адресации после	    +
			     прибавления значений регистров
026B			     check_offset:
026B  A8 C0			     TEST    AL,0C0h		 ;mod 01,10? (есть смещение?)
026D  74 25			     JZ	     no_offset		 ;нет - уйти на 29F
026F  A8 28			     TEST    AL,40		 ;mod 01? (один байт смещения?)
0271  74 13			     JZ	     word_offset	 ;нет - уйти на 291
			     ;считаем, что байт смещения один
0273  8B D0			     MOV     DX,AX		 ;сохраняем КОП и mod-reg-rm
0275  26: 8A 47	01		     MOV     AL,ES:[BX+01]	 ;читаем байт	смещения
0279  98			     CBW			 ;превращаем в слово с	учетом	    +
			     знака	(т.к.	прибавляем к	16бит регистру)
027A  03 F0			     ADD     SI,AX		 ;прибавили смещение
027C  8B C2			     MOV     AX,DX		 ;восстановили КОП и mod-reg-rm
027E  C6 06 0006r 02		     MOV     BYTE PTR cmd_len,02
0283  EB 14 90			     JMP     check_pref		 ;перейти к выбору сегмента

			     ;прямая адресация со смещением =0
			     ;два байта	смещения или	непосредственная словная	    +
			     адресация
0286			     word_offset:
0286  C6 06 0006r 03		     MOV     BYTE PTR cmd_len,03
028B  26: 8B 57	01		     MOV     DX,ES:[BX+01]	 ;прочитать слово, следующее	    +
			     сразу	за mod-reg-rm
028F  03 F2			     ADD     SI,DX		 ;прибавили его к SI (как смещение  +
			     или как значение)
0291  EB 06 90			     JMP     check_pref		 ;перейти к выбору сегмента

			     ;сюда попадем, если	нет смещения
0294			     no_offset:
0294  C6 06 0006r 01		     MOV     BYTE PTR cmd_len,01

			     ;установка регистра ES правильным сегментом для	    +
			     доступа к операнду
0299			     check_pref:
0299  8A 16 0000r		     MOV     DL,BYTE PTR cmd_inf ;прочесть байт информации о	    +
			     команде, считанный	из 1843вг1
029D  F6 C2 0F			     TEST    DL,0Fh		 ;были ли	сегментные префиксы?
02A0  75 15			     JNZ     seg_pref		 ;да - обработать
02A2  F6 06 0005r 01		     TEST    reg_or_mem,01	 ;использовали ли	регистр BP?
02A7  90			     NOP
02A8  75 04			     JNZ     ss_pref		 ;да - установить сегмент SS
02AA			     ds_pref:
02AA  8E 46 12			     MOV     ES,[BP+0012h]	 ;установить ES значением DS,	    +
			     которое было до команды
02AD  C3			     RET

			     ;если использовался регистр BP либо был префикс SS,
			     ;адресоваться нужно по сегменту	стека, каким он был  +
			     до вызова команды (в основной паре SS:SP)
02AE			     ss_pref:
				     RESS			 ;F1 FA	- переключаемся на основную  +
			     пару SS:SP
02AE  F1			     db	0f1h
02AF  FA			     CLI
02B0  8C D2			     MOV     DX,SS		 ;сохранили стековый сегмент
				     SHSS			 ;F1 FB	- переключаемся обратно на    +
			     теневую пару SS':SP'
02B2  F1			     db	0F1h
02B3  FB			     STI
02B4  8E C2			     MOV     ES,DX		 ;установить ES значением SS,	    +
			     которое было до вызова команды
02B6  C3			     RET

			     ;обработка сегментных префиксов
02B7			     seg_pref:
02B7  F6 C2 08			     TEST    DL,08		 ;есть префикс CS?
02BA  90			     NOP
02BB  75 10			     JNZ     cs_pref
02BD  F6 C2 04			     TEST    DL,04		 ;есть префикс DS?
02C0  90			     NOP
02C1  75 E7			     JNZ     ds_pref
02C3  F6 C2 02			     TEST    DL,02		 ;есть префикс ES?
02C6  90			     NOP
02C7  74 E5			     JZ	     ss_pref		 ;нет - значит	префикс SS
02C9  8E 46 00			     MOV     ES,[BP+0000]	 ;есть - установить ES значением	ES, +
			     которое было до вызова команды
02CC  C3			     RET
02CD			     cs_pref:
02CD  8E 46 16			     MOV     ES,[BP+0016h]	  ;установить	ES значением CS,	    +
			     которое было до вызова команды
02D0  C3			     RET
02D1			     h_ADRMODE endp

			     ;обработчик ENTER
			     ;команда создания стекового кадра процедуры
			     ;формат: enter nvar,	nest
			     ;C8 iw 00 если	ENTER nvar,0
			     ;C8 iw ib если	ENTER nvar,nest	и nest<>0
			     ;nvar - кол-во слов памяти под переменные
			     ;nest - уровень вложенности процедуры

			     ;команда ENTER предполагает следующий формат		    +
			     стекового	кадра
			     ;(см. Морс С.П., Алберт Д.Д. Архитектура			    +
			     микропроцессора 80286. М.:Радио и связь, 1990 -	стр.99):
			     ;SS:BP указывает на начало (высший адрес) для стекового+
			     кадра
			     ;[SS:BP], первый байт стекового	кадра, содержит
			     ;"динамическую	связь" - указатель на начало		    +
			     стекового	кадра процедуры, вызвавшей данную
			     ;[SS:BP-2]	и далее содержат "индикаторы" -	указатели на	    +
			     начало стекового кадра	всех активных процедур:
			     ;-процедура первого уровня вложенности содержит	    +
			     индикатор	из одного слова,
			     ;	указывающий на свое же слово динамической связи    +
			     (т.е. на следующее слово	[SS:BP], высшее в кадре)
			     ;-процедура второго уровня вложенности содержит	    +
			     индикатор	из двух слов -
			     ;	[SS:BP-2] указывает на начало стекового кадра		    +
			     родительской процедуры,
			     ;	[SS:BP-4] указывает на свое же	слово динамической	    +
			     связи
			     ;-процедура 3-го уровня вложенности содержит		    +
			     индикатор	из трех слов -
			     ;	[SS:BP-2] - начало стекового кадра процедуры-дедушки,   +
			     родительской для родительской
			     ;	[SS:BP-4] - на начало стекового кадра родительской	    +
			     процедуры
			     ;	[SS:BP-6] - на свое же слово динамической связи
			     ;и так	далее. Т.е n элементов индикатора стекового	    +
			     кадра	процедуры уровня	n+1
			     ;аналогичны индикатору	родительской процедуры.
			     ;После индикаторов	в стековом кадре располагается   +
			     память под переменные.
			     ;В книге Морса все пояснено на картинках и с		    +
			     примерами	на Паскале.

			     ;команда ENTER обновляет BP (чтобы он указывал на	начало+
			     созданного стекового кадра),
			     ;SP (резервируя место в стеке	под созданный кадр),
			     ;и записывает в начало созданного стекового кадра    +
			     "динамическую связь" и "индикатор"

02D1			     h_ENTER proc near
02D1  C4 5E 14			     LES BX,[BP+0014h]	   ;BX указ. на след.	за опкодом байт	    +
			     обрабатываемой команды,ES:=CS	команды
02D4  26: 8B 17			     MOV DX,ES:[BX]	  ;DX:=nvar (кол-во байт памяти под		    +
			     переменные)
02D7  26: 8A 4F	02		     MOV CL,ES:[BX+02]	  ;CL:=nest (уровень вложенности)
02DB  32 ED			     XOR CH,CH
				     RESS		   ;основной стек
02DD  F1			     db	0f1h
02DE  FA			     CLI
02DF  8B FC			     MOV DI,SP		  ;DI:=SP указатель основного	стека
				     SHSS		   ;обратно в теневой стек
02E1  F1			     db	0F1h
02E2  FB			     STI
02E3  8B 76 06			     MOV SI,[BP+0006]	  ;SI:=BP до команды ENTER (указатель	на	    +
			     стековый кадр процедуры, вызвавшей данную)
				  ;DS ранее был	установлен на SS до команды ENTER (до	    +
			     входа	в прерывание)
02E6  8D 7D FE			     LEA DI,[DI-02]	  ;DI:=указатель на начало создаваемого+
			     стекового	кадра
02E9  89 7E 06			     MOV [BP+0006],DI	  ;установили	BP-после-команды-ENTER на	    +
			     начало нового стекового кадра
				     RESS		  ;основной стек
02EC  F1			     db	0f1h
02ED  FA			     CLI
02EE  8C D3			     MOV BX,SS		  ;BX:=SS сегмент основного стека
				     SHSS		  ;обратно в теневой стек
02F0  F1			     db	0F1h
02F1  FB			     STI
02F2  8E C3			     MOV ES,BX		  ;ES:=SS основного стека
02F4  26: 89 35			     MOV ES:[DI],SI	     ;записали указатель на стековый	    +
			     кадр родительской (вызвавшей) процедуры в		    +
			     создаваемый стековый кадр
02F7  8B DF			     MOV BX,DI		  ;BX:=указатель на начало создаваемого+
			     стекового	кадра
02F9  80 F9 00			     CMP CL,00		  ;уровень вложенности в команде ENTER =0?
02FC  74 15			     JZ	var_allocate	  ;да	- уйти на	распределение стека под+
			     переменные
				  ;случай	ненулевой вложенности
02FE  FD			     STD		  ;строковые команды:= на уменьшение
02FF  1E			     PUSH DS
0300  06			     PUSH ES
0301  1F			     POP DS		  ;DS=ES:= SS основного стека
0302  49			     DEC CX		  ;число элементов индикатора=уровню  +
			     вложенности,
							  ;а нам нужно	скопировать все		    +
			     элементы индикатора родительской процедуры,	у нее   +
			     уровень на 1 меньше
0303  8D 74 FE			     LEA SI,[SI-02]	  ;SI:=смещение	на начало индикатора	    +
			     родительской процедуры
							  ;(на 1 слово меньше начала			    +
			     родительского	стекового кадра, на которое указывал +
			     BP	до команды ENTER)
0306  8D 7D FE			     LEA DI,[DI-02]	  ;DI:=смещение	в основном стеке под	    +
			     индикатор	(еще	один новый операнд уже после		    +
			     заталкивания туда BP)
0309  80 F9 00			     CMP CL,00		  ;уровень вложенности 1? (в	этом	    +
			     случае копировать нечего)
030C  74 02			     JZ	last_indic	  ;да	- уйти на	запись последнего	    +
			     элемента индикатора
030E  F3> A5			     REPZ MOVSW		  ;скопировать индикатор			    +
			     родительской процедуры в создаваемый кадр
0310			     last_indic:
0310  89 1D			     MOV [DI],BX	  ;записать в создаваемый кадр		    +
			     последний	элемент индикатора для вложенности >0 -
							  ;указатель на начало	создаваемого    +
			     стекового	кадра
0312  1F			     POP DS		  ;DS:=SS основного стека
0313			     var_allocate:
0313  2B FA			     SUB DI,DX		  ;продвинуть	указатель основного	    +
			     стека	(в DI)	с учетом	места в стековом кадре под кол-во+
			     переменных,
							  ;указанных в команде	ENTER, под		    +
			     дин.связь и индикаторы указатель (DI) уже			    +
			     модифицирован
				     RESS		  ;основной стек
0315  F1			     db	0f1h
0316  FA			     CLI
0317  8B E7			     MOV SP,DI		  ;обновить непосредственно		    +
			     указатель	основного стека
				     SHSS		  ;обратно в теневой стек
0319  F1			     db	0F1h
031A  FB			     STI
031B  83 46 14 03		     ADD WORD PTR [BP+0014h],+03 ;увеличить IP	на длину	команды
				     END_CMD
031F  C6 06 0005r 00		     MOV     reg_or_mem,00	 ;очистить E800:5, т.к. не			    +
			     инициализируется при входе	- для последующих	команд
0324  8B E5			     MOV     SP,BP		 ;восстановить указатель стека    +
			     на сохраненные при	входе регистры
0326  07			     POP     ES
0327  61			     POPA
0328  1F			     POP     DS			 ;восстановить регистры
0329  CF			     IRET			 ;закончить обработку	команды,	    +
			     восстановить CS и SS
032A			     h_ENTER endp

			     ;обработчик IMUL	immediate
032A			     h_IMUL proc near
032A  C4 5E 14			     LES     BX,[BP+0014h]	 ;BX указ. на след. за опкодом байт  +
			     обрабатываемой команды
032D  8C C1			     MOV     CX,ES		 ;ES=CX= CS обрабатываемой команды
032F  E8 FEC6			     CALL    h_ADRMODE		 ;возвращает адрес первого	    +
			     операнда в SI и сегмент операнда в ES
0332  E8 FE93			     CALL    fetch_arg2		 ;возвращает второй операнд в CL    +
			     или CX
0335  E8 FE6E			     CALL    fetch_arg1		 ;возвращает первый операнд в DL    +
			     или DX
0338  91			     XCHG    CX,AX		 ;AX=второй (непосредственный)	    +
			     операнд, CX	= первые 2 байта команды
0339  F7 EA			     IMUL    DX			 ;(DX,AX)=(AX)*(DX)
033B  70 24			     JO	     set_OF_CF		 ;есть переполнение?
033D  81 66 18 F7FE		     AND     WORD PTR [BP+0018h],0F7FEh	   ;нет - сбросить OF и CF
0342  8B F1		     write:  MOV     SI,CX		 ;SI=первые 2 байта команды (второй +
			     на младших адресах)
0344  83 E6 38			     AND     SI,38h		 ;высечь поле	reg из mod-reg-rm
0347  D1 EE			     SHR     SI,1
0349  D1 EE			     SHR     SI,1		 ;сдвинуть к началу регистра, с	    +
			     учетом того, что адресоваться по словам
034B  F7 DE			     NEG     SI			 ;т.к. регистры в поле reg идут в	    +
			     обратном порядке по отношению к	стеку
034D  89 42 10			     MOV     [BP+SI+10h],AX	 ;запись результата в 16-бит	    +
			     регистр
								 ;(смещение в SI - отрицательное,	с  +
			     10h и менее в стеке располагаются	РОН,	BP - вершина	    +
			     стека)
0350  A1 0006r			     MOV     AX,cmd_len	       ;прочесть полную длину операндов +
			     команды из E800:6
0353  01 46 14			     ADD     [BP+0014h],AX	  ;увеличить IP на эту длину, чтобы +
			     он указывал на	след команду
				     END_CMD
0356  C6 06 0005r 00		     MOV     reg_or_mem,00	 ;очистить E800:5, т.к. не			    +
			     инициализируется при входе	- для последующих	команд
035B  8B E5			     MOV     SP,BP		 ;восстановить указатель стека    +
			     на сохраненные при	входе регистры
035D  07			     POP     ES
035E  61			     POPA
035F  1F			     POP     DS			 ;восстановить регистры
0360  CF			     IRET			 ;закончить обработку	команды,	    +
			     восстановить CS и SS

			     ;если получили	флаг OF
0361			     set_OF_CF:
0361  81 4E 18 0801		     OR	     WORD PTR [BP+0018h],0801h	  ;установить	OF и CF
0366  EB DA			     JMP     write
0368			     h_IMUL endp

			     ;обработчик BOUND
			     ;формат команды:
			     ;BOUND reg16 mem
			     ;62 mod-reg-rm mem1 mem2
			     ;поскольку команда	двухадресная, mod-reg-rm указывает	на+
			     второй аргумент
0368			     h_BOUND proc near
0368  80 CC 01			     OR	     AH,01			;установить 16-бит	тип		    +
			     операнда
036B  C4 5E 14			     LES     BX,[BP+0014h]		;BX указ. на след. за опкодом    +
			     байт обрабатываемой команды,ES:=CS команды
036E  26: 80 3F	BF		     CMP     ES:BYTE PTR [BX],0BFh	;операнд	в регистре? (mod в	    +
			     mod-reg-rm	= 11?)
0372  77 26			     JA	     h_EXIT			;да -	уйти на 3B2 (выход из	    +
			     команды)
0374  E8 FE81			     CALL    h_ADRMODE			;возвращает адрес (???второго)+
			     операнда в SI и сегмент операнда в ES
0377  26: 8B 0C			     MOV     CX,ES:[SI]			;CX:= операнд из памяти -	    +
			     нижняя граница массива
037A  26: 8B 54	02		     MOV     DX,ES:[SI+02]		;DX:= следующее за ним слово	-   +
			     верхняя граница массива
037E  8B F0			     MOV     SI,AX			;SI=первые 2 байта команды	    +
			     (второй на	младших адресах)
0380  83 E6 26			     AND     SI,+38			;высечь поле reg из	mod-reg-rm
0383  D1 EE			     SHR     SI,1
0385  D1 EE			     SHR     SI,1			;сдвинуть к началу регистра, +
			     с	учетом того, что адресоваться по словам
0387  F7 DE			     NEG     SI				;т.к.	регистры в поле reg идут в+
			     обратном порядке по отношению к	стеку
0389  8B 42 0A			     MOV     AX,[BP+SI+10]		;чтение операнда-регистра
									;(смещение в SI -			    +
			     отрицательное, с 10h	и менее в стеке располагаются	    +
			     РОН, BP	- вершина стека)
038C  3B C8			     CMP     CX,AX			;сравнение с нижней границей
038E  77 15			     JA	     em_INT5			;если вышли за нее		    +
			     (н.граница>числа) - уйти на 3BD
0390  3B C2			     CMP     AX,DX			;сравнение с верхней		    +
			     границей
0392  77 11			     JA	     em_INT5			;если вышли за нее		    +
			     (число>в.границв) - уйти на 3BD
0394  A1 0006r			     MOV     AX,cmd_len			;иначе считать длину		    +
			     операндов	команды
0397  01 46 14			     ADD     [BP+0014h],AX		;увеличить IP в стеке на эту    +
			     длину, чтобы он указывал на начало след.команды

			     ;обработчик ненайденной команды
			     ;также завершающая	фаза обработчика	BOUND
039A			     h_EXIT: END_CMD
039A  C6 06 0005r 00		     MOV     reg_or_mem,00	 ;очистить E800:5, т.к. не			    +
			     инициализируется при входе	- для последующих	команд
039F  8B E5			     MOV     SP,BP		 ;восстановить указатель стека    +
			     на сохраненные при	входе регистры
03A1  07			     POP     ES
03A2  61			     POPA
03A3  1F			     POP     DS			 ;восстановить регистры
03A4  CF			     IRET			 ;закончить обработку	команды,	    +
			     восстановить CS и SS

			     ;BOUND: случай выхода за границу массива
			     ;эмуляция действий	процессора при вызове INT 5
03A5			     em_INT5:
03A5  8B 46 14			     MOV     AX,[BP+0014h]		;считать	IP в стеке		    +
			     (указывающий на второй байт	эмулируемой команды)
03A8  48			     DEC     AX				;теперь IP указывает на опкод
03A9  F6 06 0001r 0F		     TEST    BYTE PTR cmd_inf+1,0Fh	;были ли префиксы	у команды?
03AE  74 01			     JZ	     get_CS
03B0  48			     DEC     AX				;если были префиксы, сделать +
			     IP	указывающим на байт префикса
									;теперь IP точно указывает на +
			     начало команды
03B1  8B 5E 16		     get_CS: MOV     BX,[BP+0016h]		;BX:=CS	команды
03B4  8B 4E 18			     MOV     CX,[BP+0018h]		;CX:=флаги	команды
				     RESS				;переключаемся на основную   +
			     пару SS:SP
03B7  F1			     db	0f1h
03B8  FA			     CLI
03B9  51			     PUSH    CX				;как	бы pushf
03BA  53			     PUSH    BX				;как	бы push cs
03BB  50			     PUSH    AX				;как	бы push ip - все в основном   +
			     стеке, как	при уходе на прерывание
				     SHSS				;обратно	на теневую пару SS':SP'
03BC  F1			     db	0F1h
03BD  FB			     STI
03BE  33 C0			     XOR     AX,AX
03C0  8E C0			     MOV     ES,AX			;ES указывает на таблицу	    +
			     векторов прерываний
03C2  26: A1 0014r		     MOV     AX,ES:int5_ip		;14h=20=5*4, начало записи для INT 5 +
			     в	таблице векторов
03C6  89 46 14			     MOV     [BP+0014h],AX		;IP стека эмулятора:= IP		    +
			     обработчика INT	5
03C9  26: A1 0016r		     MOV     AX,ES:int5_cs
03CD  89 46 16			     MOV     [BP+0016h],AX		;CS стека эмулятора:= CS		    +
			     обработчика INT	5
03D0  80 66 19 FC		     AND     BYTE PTR [BP+0019h],0FCh	;сбросить IF и	TF во	флагах в	    +
			     стеке, как	при уходе на прерывание
03D4  90			     NOP
03D5  EB C3			     JMP     h_EXIT			;возврат	из эмулятора
03D7			     h_BOUND endp

			     ;таблица адресов программ эмуляции команд
			     ;адрес в таблице соответствует опкоду
03D7			     OP_table label byte
03D7  0100*(00)			     db	     256 DUP (0)
			     org offset	OP_table+62h
0439  02			     db	     02				;62h - BOUND
			     org offset	OP_table+69h
0440  04			     db	     04				;69h - IMUL immediate
			     org offset	OP_table+6bh
0442  04			     db	     04				;6bh - IMUL S immediate
			     org offset	OP_table+0c0h
0497  06			     db	     06				;c0h - SHIFT immediate
0498  06			     db	     06				;c1h - SHIFT immediate
			     org offset	OP_table+0c8h
049F  08			     db	     08				;c8h - ENTER
			     org offset	OP_table+256

			     ;таблица адресов обработчиков команд
04D7			     CMD_TABLE label word
04D7  039Ar			     DW	     offset h_EXIT		;обработчик ненайденной	    +
			     команды
04D9  0368r			     DW	     offset h_BOUND		;обрабочик BOUND (смещ.2)
04DB  032Ar			     DW	     offset h_IMUL		;обработчик IMUL (смещ.4)
04DD  00E7r			     DW	     offset h_SHIFT		;обработчик сдвигов (смещ.6)
04DF  02D1r			     DW	     offset h_ENTER		;обработчик ENTER (смещ.8)

			     ;таблица адресов обработчиков режимов косвенной	    +
			     адресации	rm  (mod=00,01,10)
04E1			     RM_TABLE label word
04E1  023Er			     DW	     offset RM0			;rm=0
04E3  0265r			     DW	     offset RM1			;rm=1
04E5  0256r			     DW	     offset RM2			;rm=2
04E7  0247r			     DW	     offset RM3			;rm=3
04E9  0241r			     DW	     offset RM4			;rm=4
04EB  0250r			     DW	     offset RM5			;rm=5
04ED  0259r			     DW	     offset RM6			;rm=6
04EF  0268r			     DW	     offset RM7			;rm=7

			     ;таблица адресов обработчиков команд сдвига в	    +
			     16-разрядном случае
			     ;NB! по справочнику Морса reg=6 (010) не используется,
			     ;а здесь reg=6 аналогично reg=4 (100)
04F1			     SHIFTABLE16 label word
04F1  013Er			     DW	     offset ROL16		;000 - ROL
04F3  0143r			     DW	     offset ROR16		;001 - ROR
04F5  0148r			     DW	     offset RCL16		;010 - RCL
04F7  014Dr			     DW	     offset RCR16		;011 - RCR
04F9  0152r			     DW	     offset SHL16		;100 - SHL
04FB  0157r			     DW	     offset SHR16		;101 - SHR
04FD  0152r			     DW	     offset SHL16		;110 - ничего
04FF  015Cr			     DW	     offset SAR16		;111 - SAR

			     ;таблица адресов обработчиков команд сдвига в	    +
			     8-разрядном случае
			     ;NB! по справочнику Морса reg=6 (010) не используется,
			     ;а здесь reg=6 аналогично reg=4 (100)
0501			     SHIFTABLE8	label word
0501  011Br			     DW	     offset ROL8	       ;000 - ROL
0503  0120r			     DW	     offset ROR8	       ;001 - ROR
0505  0125r			     DW	     offset RCL8	       ;010 - RCL
0507  012Ar			     DW	     offset RCR8	       ;011 - RCR
0509  012Fr			     DW	     offset SHL8	       ;100 - SHL
050B  0134r			     DW	     offset SHR8	       ;101 - SHR
050D  012Fr			     DW	     offset SHL8	       ;110 - ничего
050F  0139r			     DW	     offset SAR8	       ;111 - SAR

			     ;располагается по адресу 052Fh и вероятно возник из-за +
			     выравнивания следующего сегмента по слову или	    +
			     параграфу
0511  00			     DB	     00h

0512			     _TEXT ends

0000			     STACK segment para	stack 'STACK'
* M286_TXT.ASM(795) Reserved word used as symbol: STACK
			     ;этого в памяти эмулятора уже не	будет, это пойдет	в  +
			     E800:0
0000  08*(00)			     DB	     8 dup (0)
0008			     STACK ends
			     end h_int6

Symbol Name			  Type	 Value

??DATE				  Text	 "04-20-22"
??FILENAME			  Text	 "M286_TXT"
??TIME				  Text	 "00:13:15"
??VERSION			  Number 0500
@CPU				  Text	 0707H
@CURSEG				  Text	 STACK
@FILENAME			  Text	 M286_TXT
@WORDSIZE			  Text	 2
ARG16BIT			  Near16 _TEXT:01DD
BCKP_INT1_CS			  Alias	 CMD_WORD
BCKP_INT1_IP			  Alias	 CMD_INF
CHECK_OFFSET			  Near16 _TEXT:026B
CHECK_PREF			  Near16 _TEXT:0299
CMD_INF				  Word	 DATA:0000
CMD_LEN				  Word	 DATA:0006
CMD_TABLE			  Word	 _TEXT:04D7
CMD_WORD			  Word	 DATA:0002
CS_PREF				  Near16 _TEXT:02CD
DS_PREF				  Near16 _TEXT:02AA
EM_INT5				  Near16 _TEXT:03A5
ENDNMI				  Near16 _TEXT:0072
EXIT7				  Near16 _TEXT:00E3
FETCH_ARG1			  Near16 _TEXT:01A6
FETCH_ARG2			  Near16 _TEXT:01C8
GET_CS				  Near16 _TEXT:03B1
H_ADRMODE			  Near16 _TEXT:01F8
H_BOUND				  Near16 _TEXT:0368
H_ENTER				  Near16 _TEXT:02D1
H_EXIT				  Near16 _TEXT:039A
H_IMUL				  Near16 _TEXT:032A
H_INT1				  Far16	 _TEXT:002E
H_INT6				  Far16	 _TEXT:0000
H_INT7				  Far16	 _TEXT:0090
H_SHIFT				  Near16 _TEXT:00E7
INMEM				  Near16 _TEXT:0220
INREG8				  Near16 _TEXT:0213
INT1_CS				  Word	 INT_TBL:0006
INT1_IP				  Word	 INT_TBL:0004
INT5_CS				  Word	 INT_TBL:0016
INT5_IP				  Word	 INT_TBL:0014
IRQ13				  Near16 _TEXT:0074
LAST_INDIC			  Near16 _TEXT:0310
L_REG				  Near16 _TEXT:021F
NMIGEN				  Near16 _TEXT:008C
NOPREF				  Near16 _TEXT:00CD
NO_OFFSET			  Near16 _TEXT:0294
NO_SFT				  Near16 _TEXT:01EE
OP_TABLE			  Byte	 _TEXT:03D7
RCL16				  Near16 _TEXT:0148
RCL8				  Near16 _TEXT:0125
RCR16				  Near16 _TEXT:014D
RCR8				  Near16 _TEXT:012A
RD16MEM				  Near16 _TEXT:01C4
RD16REG				  Near16 _TEXT:01B7
RD_MEM				  Near16 _TEXT:01BB
REG_OR_MEM			  Byte	 DATA:0005
RM0				  Near16 _TEXT:023E
RM1				  Near16 _TEXT:0265
RM2				  Near16 _TEXT:0256
RM3				  Near16 _TEXT:0247
RM4				  Near16 _TEXT:0241
RM5				  Near16 _TEXT:0250
RM6				  Near16 _TEXT:0259
RM7				  Near16 _TEXT:0268
RM_TABLE			  Word	 _TEXT:04E1
ROL16				  Near16 _TEXT:013E
ROL8				  Near16 _TEXT:011B
ROR16				  Near16 _TEXT:0143
ROR8				  Near16 _TEXT:0120
SAR16				  Near16 _TEXT:015C
SAR8				  Near16 _TEXT:0139
SAVED_AX			  Word	 SHADOW_STACK:0010
SAVED_BP			  Word	 SHADOW_STACK:0006
SAVED_BX			  Word	 SHADOW_STACK:000A
SAVED_CS			  Word	 SHADOW_STACK:0016
SAVED_CX			  Word	 SHADOW_STACK:000E
SAVED_DI			  Word	 SHADOW_STACK:0002
SAVED_DS			  Word	 SHADOW_STACK:0012
SAVED_DX			  Word	 SHADOW_STACK:000C
SAVED_ES			  Word	 SHADOW_STACK:0000
SAVED_FLAGS			  Word	 SHADOW_STACK:0018
SAVED_IP			  Word	 SHADOW_STACK:0014
SAVED_SI			  Word	 SHADOW_STACK:0004
SAVED_SP			  Word	 SHADOW_STACK:0008
SEG_PREF			  Near16 _TEXT:02B7
SET_FLAG			  Near16 _TEXT:015E
SET_OF				  Near16 _TEXT:0180
SET_OF_CF			  Near16 _TEXT:0361
SHFT8				  Near16 _TEXT:0115
SHIFTABLE16			  Word	 _TEXT:04F1
SHIFTABLE8			  Word	 _TEXT:0501
SHL16				  Near16 _TEXT:0152
SHL8				  Near16 _TEXT:012F
SHR16				  Near16 _TEXT:0157
SHR8				  Near16 _TEXT:0134
SS_PREF				  Near16 _TEXT:02AE
VAR_ALLOCATE			  Near16 _TEXT:0313
WORD_OFFSET			  Near16 _TEXT:0286
WR8MEM				  Near16 _TEXT:01A2
WR8REG				  Near16 _TEXT:0195
WRITE				  Near16 _TEXT:0342
WRITE_RESULT			  Near16 _TEXT:0184
WR_FL				  Near16 _TEXT:0166
WR_MEM				  Near16 _TEXT:0199

Macro Name

CLM
END_CMD
RESS
SHSS
STM

Groups & Segments		  Bit Size Align  Combine Class

DATA				  16  0008  AT E800
INT_TBL				  16  0018  AT 0000
SHADOW_STACK			  16  001A  AT EC00
STACK				  16  0008 Para	  Stack	  STACK
_TEXT				  16  0512 Word	  Public  CODE
*Warning* M286_TXT.ASM(795) Reserved word used as symbol: STACK


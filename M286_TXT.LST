 	 	 	 	.286c                               ;включить инструкции реального режима 286
 	 	 	 	
 	 	 	 	.LIST
 	 	 	 	
 0000	 	 	 	DATA segment at 0E800h
 0000  ????	 	 	cmd_inf	 	dw	?           ;слово информации о прерванной команде из 1843ВГ1. Содержит сегментные префиксы
 0002  ????	 	 	cmd_word	dw	?           ;два первых байта команды, считываются из 1843ВГ1
 0004  ??	 	 	 	 	db	?           ;на этот байт ссылок нет
 0005  ??	 	 	reg_or_mem	db	?           ;байт флажков информации об эмулируемой команде
 0006  ????	 	 	cmd_len	 	dw	?           ;длина операндов команды
 	 	 	 	
 =	 	 	 	bckp_int1_ip	equ	cmd_inf
 =	 	 	 	bckp_int1_cs	equ	cmd_word
 0008	 	 	 	DATA ends
 	 	 	 	
 0000	 	 	 	INT_TBL segment at 0h               ;таблица векторов прерываний
 0004	 	 	 	org 01h*4                           ;INT 01h - прерывание пошагового режима, вызывается после каждой команды, если TF=1
 0004  ????	 	 	int1_ip	dw	?
 0006  ????	 	 	int1_cs	dw	?
 0014	 	 	 	org 05h*4                           ;INT 05h - прерывание, генерируемое по команде BOUND
 0014  ????	 	 	int5_ip	dw	?
 0016  ????	 	 	int5_cs	dw	?
 0018	 	 	 	INT_TBL ends
 	 	 	 	
 0000	 	 	 	SHADOW_STACK segment at 0EC00h
 0000  ????	 	 	saved_ES	dw	?
 0002  ????	 	 	saved_DI	dw	?
 0004  ????	 	 	saved_SI	dw	?
 0006  ????	 	 	saved_BP	dw	?
 0008  ????	 	 	saved_SP	dw	?
 000A  ????	 	 	saved_BX	dw	?
 000C  ????	 	 	saved_DX	dw	?
 000E  ????	 	 	saved_CX	dw	?
 0010  ????	 	 	saved_AX	dw	?
 0012  ????	 	 	saved_DS	dw	?
 0014  ????	 	 	saved_IP	dw	?
 0016  ????	 	 	saved_CS	dw	?
 0018  ????	 	 	saved_FLAGS	dw	?
 001A	 	 	 	SHADOW_STACK ends
 	 	 	 	
 	 	 	 	END_CMD macro                       ;завершающий этап обработки команды, повторяется во всех четырех обработчиках
 	 	 	 	 	MOV     reg_or_mem,00       ;очистить E800:5, т.к. не инициализируется при входе - для последующих команд
 	 	 	 	 	MOV     SP,BP               ;восстановить указатель стека на сохраненные при входе регистры
 	 	 	 	 	POP     ES
 	 	 	 	 	POPA
 	 	 	 	 	POP     DS                  ;восстановить регистры
 	 	 	 	 	IRET                        ;закончить обработку команды, восстановить CS и SS
 	 	 	 	 	endm
 	 	 	 	
 0000	 	 	 	_TEXT segment word public 'CODE'
 	 	 	 	
 	 	 	 	;обработчик прерывания int 06h (неизвестная команда)
 	 	 	 	;оказались в стеке, адресуемом теневой парой
 	 	 	 	;SS':SP'=E800:4000 (EC000h)
 	 	 	 	;CS:IP, сохраненные в стеке, указывают на следующий за опкодом байт команды
 	 	 	 	assume cs:_TEXT
 0000	 	 	 	h_int6 proc far
 0000  1E	 	 	 	PUSH    DS
 0001  60	 	 	 	PUSHA                       ;AX,CX,DX,BX,SP,BP,SI,DI
 0002  06	 	 	 	PUSH    ES
 0003  8B EC	 	 	 	MOV     BP,SP               ;BP - ук-ль стека после сохранения всех регистров
 	 	 	 	;теперь имеем
 	 	 	 	;[BP]=ES
 	 	 	 	;[BP+2]=DI
 	 	 	 	;[BP+4]=SI
 	 	 	 	;[BP+6]=BP
 	 	 	 	;[BP+8]=SP
 	 	 	 	;[BP+0Ah]=BX
 	 	 	 	;[BP+0Ch]=DX
 	 	 	 	;[BP+0Eh]=CX
 	 	 	 	;[BP+10h]=AX
 	 	 	 	;[BP+12h]=DS
 	 	 	 	;[BP+14h]=IP
 	 	 	 	;[BP+16h]=CS
 	 	 	 	;[BP+18h]=FLAGS
 0005  8C D0	 	 	 	MOV     AX,SS
 0007  8E D8	 	 	 	MOV     DS,AX               ;DS:=SS=E800,сегмент стека при входе в прерывание (установлено загрузчиком эмулятора)
 	 	 	 	assume DS:DATA                      ;теперь по DS можно адресоваться к области данных эмулятора E800:0 (ну и к стеку)
 0009  E4 C8	 	 	 	IN      AL,0C8h             ;c8h - порт информации о команде 1843вг1
 000B  8A E0	 	 	 	MOV     AH,AL
 000D  E4 C8	 	 	 	IN      AL,0C8h
 000F  A3 0000 R	 	 	MOV     cmd_inf,AX          ;сохранили считанное из порта информации о команде в DS:0 (E800:0)
 0012  E4 CE	 	 	 	IN      AL,0CEh             ;ceh - порт первого слова команды 1843вг1
 0014  8A E0	 	 	 	MOV     AH,AL
 0016  E4 CE	 	 	 	IN      AL,0CEh
 0018  A3 0002 R	 	 	MOV     cmd_word,AX         ;сохранили считанное из порта слова команды в DS:2 (E800:2)
 001B  8A C4	 	 	 	MOV     AL,AH               ;оставили только первый байт
 001D  BB 03DD R	 	 	MOV     BX,offset op_table  ;адрес таблицы опкодов
 0020  2E: D7	 	 	 	XLAT    CS:op_table         ;AL:=номер обработчика в таблице обработчиков команд
 0022  32 FF	 	 	 	XOR     BH,BH
 0024  8A D8	 	 	 	MOV     BL,AL
 0026  2E: FF A7 04DD R	 	 	JMP     CS:[BX+CMD_TABLE]   ;адрес таблицы адресов обработчиков команд
 	 	 	 	                                    ;перешли на обработчик соответствующей команды
 002B	 	 	 	h_int6 endp
 	 	 	 	
 002B  B8 ---- R	 	 	MOV     AX,STACK            ;адрес настраивается при загрузке EXE-шника - т.е. это был сегмент. В файле - 0053h
 	 	 	 	                                    ;возможно, использован как указатель конца кода эмулятора для загрузчика
 	 	 	 	
 	 	 	 	;обработчик INT 01h (пошаговый режим)
 	 	 	 	;устанавливается при первом вызове сопроцессорной команды в обработчике INT 7
 	 	 	 	;вызывается после рестарта команды, вызвавшей INT 7
 	 	 	 	;восстанавливает старый вектор прерывания INT 01h,
 	 	 	 	;переключает процессор обратно на 8МГц и включает прерывание INT 7
 	 	 	 	;от любой сопроцессорной команды.
 	 	 	 	;кроме того, если выполнившаяся команда сопроцессора вызвала аппаратное прерывание от него
 	 	 	 	;(IRQ13), генерирует программное NMI
 002E	 	 	 	h_int1 proc far
 002E  50	 	 	 	PUSH    AX
 002F  1E	 	 	 	PUSH    DS
 0030  06	 	 	 	PUSH    ES
 0031  33 C0	 	 	 	XOR     AX,AX
 0033  8E D8	 	 	 	MOV     DS,AX               ;уст DS на таблицу векторов прерываний
 	 	 	 	assume DS:INT_TBL
 0035  B8 E800	 	 	 	MOV     AX,0E800h
 0038  8E C0	 	 	 	MOV     ES,AX               ;уст ES на область данных эмулятора E800
 003A  26: A1 0000 R	 	 	MOV     AX,ES:bckp_int1_ip  ;прочесть сохраненный IP INT 1
 003E  A3 0004 R	 	 	MOV     int1_ip,AX          ;записать в таблицу векторов
 0041  26: A1 0002 R	 	 	MOV     AX,ES:bckp_int1_cs  ;прочесть сохраненный CS INT 1
 0045  A3 0006 R	 	 	MOV     int1_cs,AX          ;записать в таблицу векторов
 0048  26: A1 0004	 	 	MOV     AX,ES:[0004]        ;прочесть сохраненные флаги, бывшие до вызова INT 7
 004C  07	 	 	 	POP     ES
 004D  1F	 	 	 	POP     DS
 	 	 	 	assume DS:DATA
 004E  87 EC	 	 	 	XCHG    BP,SP
 	 	 	 	;теперь распределение в стеке такое
 	 	 	 	;[BP]=AX
 	 	 	 	;[BP+2]=IP
 	 	 	 	;[BP+4]=CS
 	 	 	 	;[BP+6]=FLAGS
 	 	 	 	;SP'=BP до прерывания
 0050  89 46 06	 	 	 	MOV     [BP+06],AX          ;записать старые флаги
 0053  87 EC	 	 	 	XCHG    BP,SP               ;восстановить BP и SP
 0055  B0 0A	 	 	 	MOV     AL,0Ah              ;команда контроллеру прерываний: чтение регистра IRR (запросов на прерывание)
 0057  E6 A0	 	 	 	OUT     0A0h,AL             ;A0h - второй контроллер прерываний
 0059  EB 00	 	 	 	JMP     $+2                 ;очистить очередь команд
 005B  E4 A0	 	 	 	IN      AL,0A0h             ;прочитать регистр запросов на прерывание 2-го контроллера
 005D  A8 20	 	 	 	TEST    AL,20h              ;было прерывание от сопроцессора? (IRQ 13)
 005F  75 13	 	 	 	JNZ     IRQ13               ;да - уйти на 0074
 0061  9B	 	 	 	WAIT                        ;иначе ждать готовности сопроцессора
 	 	 	 	 	CLM                         ;включить INT 07 на каждую ESC команду
 0062  F1                     +	 	db 0F1h
 0063  FD                     +	 	STD
 0064  E4 62	 	 	 	IN      AL,62h
 0066  0C 40	 	 	 	OR      AL,40h              ;установить триггер блокировки очереди команд процессора
 0068  E6 62	 	 	 	OUT     62h,AL
 006A  A8 10	 	 	 	TEST    AL,10h              ;частота сопроцессора 8мгц?
 006C  75 04	 	 	 	JNZ     endnmi              ;да - уйти на 72
 006E  E6 E0	 	 	 	OUT     0E0h,AL             ;иначе переключить синхронизатор
 0070  EB 00	 	 	 	JMP     $+2                 ;очистить очередь команд
 0072  58	 	 	endnmi:	POP     AX
 0073  CF	 	 	 	IRET
 	 	 	 	
 	 	 	 	;если было прерывание от сопроцессора IRQ13
 0074  B0 20	 	 	IRQ13:	MOV     AL,20h
 0076  E6 A0	 	 	 	OUT     0A0h,AL             ;команда 2-му контроллеру прерывания "обычный конец прерывания"
 0078  B0 62	 	 	 	MOV     AL,62h
 007A  E6 20	 	 	 	OUT     20h,AL              ;команда 1-му контроллеру прерывания "специальный конец прерывания" - сброс каскадируемого IRQ2
 	 	 	 	 	CLM                         ;включить INT 07 на каждую ESC команду
 007C  F1                     +	 	db 0F1h
 007D  FD                     +	 	STD
 007E  E4 62	 	 	 	IN      AL,62h
 0080  0C 40	 	 	 	OR      AL,40h
 0082  E6 62	 	 	 	OUT     62h,AL              ;установить триггер блокировки очереди команд процессора
 0084  A8 10	 	 	 	TEST    AL,10h              ;частота сопроцессора 8мгц?
 0086  75 04	 	 	 	JNZ     nmigen              ;да - уйти на 8C
 0088  E6 E0	 	 	 	OUT     0E0h,AL             ;иначе переключить синхронизатор
 008A  EB 00	 	 	 	JMP     $+2                 ;очистить очередь команд
 008C  58	 	 	nmigen:	POP     AX
 008D  CD 02	 	 	 	INT     02                  ;вновь сгенерировать NMI уже с настоящим обработчиком (сохраненным по первому вызову int07h)
 008F  CF	 	 	 	IRET
 0090	 	 	 	h_int1 endp
 	 	 	 	
 	 	 	 	
 	 	 	 	;обработчик прерывания int 07h (встречена команда сопроцессора ESC)
 	 	 	 	;устанавливается загрузчиком эмулятора,
 	 	 	 	;если используется сопроцессор с частотой 4МГц.
 	 	 	 	
 	 	 	 	;Данный обработчик совместно с обработчиком INT1 дает возможность работать с процессором
 	 	 	 	;8086 на частоте 8МГц и с медленным 4-МГц 8087, автоматически переключаясь на 4МГц
 	 	 	 	;только на время исполнения команд сопроцессора.
 	 	 	 	;Поддерживается горячее переключение частоты 86+87 кнопкой РЕЖИМ (=TURBO) 4 <-> 8 МГц,
 	 	 	 	;при работе на 4МГц обработчики не делают по командам сопроцессора переключения частоты.
 	 	 	 	
 	 	 	 	;Алгоритм. Если система работает на 8МГц, обработчик переключает частоту на 4МГц,
 	 	 	 	;устанавливает пошаговое прерывание на свой обработчик INT1, запомнив адрес старого,
 	 	 	 	;и делает рестарт команды сопроцессора, вызвавшей прерывание,
 	 	 	 	;со включенным флагом пошагового режима и выключенным флагом прерывания по команде сопроцессора.
 0090	 	 	 	h_int7 proc far
 0090  50	 	 	 	PUSH    AX
 0091  1E	 	 	 	PUSH    DS
 0092  33 C0	 	 	 	XOR     AX,AX
 0094  8E D8	 	 	 	MOV     DS,AX               ;установить DS на таблицу векторов прерываний
 	 	 	 	assume DS:INT_TBL
 0096  A1 0004 R	 	 	MOV     AX,int1_ip         ;прочесть IP обработчика INT 1 (пошаговый режим)
 0099  36: A3 0000 R	 	 	MOV     SS:bckp_int1_ip,AX ;сохранить IP INT 1 в области данных эмулятора (E800:0000)
 009D  A1 0006 R	 	 	MOV     AX,int1_cs         ;прочесть CS обработчика INT 1 (пошаговый режим)
 00A0  36: A3 0002 R	 	 	MOV     SS:bckp_int1_cs,AX ;сохранить CS INT 1 в области данных эмулятора (E800:0002)
 00A4  B8 002E R	 	 	MOV     AX,offset h_int1
 00A7  A3 0004 R	 	 	MOV     int1_ip,AX
 00AA  8C 0E 0006 R	 	 	MOV     int1_cs,CS         ;установить обработчик прерывания пошагового режима INT1  на E000:02Eh
 00AE  1F	 	 	 	POP     DS
 	 	 	 	assume DS:DATA
 00AF  87 E5	 	 	 	XCHG    SP,BP
 	 	 	 	;теперь распределение в стеке такое
 	 	 	 	;[BP]=AX
 	 	 	 	;[BP+2]=IP
 	 	 	 	;[BP+4]=CS
 	 	 	 	;[BP+6]=FLAGS
 	 	 	 	;SP'=BP до прерывания
 00B1  8B 46 06	 	 	 	MOV     AX,[BP+06]          ;прочесть флаги, бывшие до прерывания
 00B4  36: A3 0004	 	 	MOV     SS:[0004],AX        ;сохранить старые флаги в E800:0004
 00B8  C6 46 07 F1	 	 	MOV     BYTE PTR [BP+07],0F1h ;уст старшие флаги: режим без int 07h на ESC, реальный, OF,DF,IF=0, TF=1 (пошаговый режим ВКЛ)
 00BC  FF 4E 02	 	 	 	DEC     WORD PTR [BP+02]    ;уст IP на байт опкода, вызвавшего прерывание
 00BF  E4 C8	 	 	 	IN      AL,0C8h             ;c8h - порт информации о команде 1843вг1
 00C1  8A E0	 	 	 	MOV     AH,AL
 00C3  E4 C8	 	 	 	IN      AL,0C8h
 00C5  F6 C4 0F	 	 	 	TEST    AH,0Fh              ;были ли сегментные префиксы?
 00C8  74 03	 	 	 	JZ      nopref              ;нет - уйти на CD
 00CA  FF 4E 02	 	 	 	DEC     WORD PTR [BP+02]    ;были - сделать IP указывающим на префикс (начало команды)
 00CD  87 E5	 	 	nopref: XCHG    SP,BP
 00CF  E4 62	 	 	 	IN      AL,62h              ;2-й порт конфигурации компьютера
 00D1  24 D7	 	 	 	AND     AL,0D7h             ;сбросить бит 5 (разрешить переключение синхронизации кнопкой TURBO) 
 	 	 	 	                                    ;и бит 3 - ошибочно (в него нет записи)
 00D3  E6 62	 	 	 	OUT     62h,AL
 00D5  A8 10	 	 	 	TEST    AL,10h              ;частота сопроцессора 8МГц?
 00D7  75 0A	 	 	 	JNZ     exit7               ;да - уйти на 0E3
 00D9  E4 61	 	 	 	IN      AL,61h              ;иначе прочесть 1-й порт конфигурации компьютера
 00DB  A8 10	 	 	 	TEST    AL,10h              ;режим синхронизатора 8МГц?
 00DD  74 04	 	 	 	JZ      exit7               ;нет - уйти на 0E3
 00DF  E6 E0	 	 	 	OUT     0E0h,AL             ;иначе переключить синхронизатор
 00E1  EB 00	 	 	 	JMP     $+2                 ;очистить очередь команд
 00E3	 	 	 	exit7:	STM                         ;ОТКЛЮЧИТЬ int 07 на каждую ESC команду
 00E3  F1                     +	 	db 0F1h
 00E4  FC                     +	 	CLD
 00E5  58	 	 	 	POP     AX
 00E6  CF	 	 	 	IRET                        ;рестарт команды (теперь ее исполнит сопроцессор)
 00E7	 	 	 	h_int7 endp
 	 	 	 	
 	 	 	 	;обработчик сдвигов SHIFT immediate
 	 	 	 	;формат команд:
 	 	 	 	;(SHIFT) reg/mem,immed8
 	 	 	 	;первый байт:
 	 	 	 	;C0 - сдвигаемый операнд 8 бит
 	 	 	 	;С1 - сдвигаемый операнд 16 бит
 	 	 	 	;второй байт: mod-reg-rm
 	 	 	 	;тип сдвига определяется reg:
 	 	 	 	;000 - ROL
 	 	 	 	;001 - ROR
 	 	 	 	;010 - RCL
 	 	 	 	;011 - RCR
 	 	 	 	;100 - SHL
 	 	 	 	;101 - SHR
 	 	 	 	;110 - SHL, как и для 100 (а по справочникам - ничего)
 	 	 	 	;111 - SAR
 	 	 	 	;mod и rm аналогичны обычной кодировке для одноадресных команд
 	 	 	 	;последний байт - число, на которое нужно сдвинуть
 	 	 	 	assume ss:SHADOW_STACK
 00E7	 	 	 	h_SHIFT proc near
 00E7  80 CC 02	 	 	 	OR      AH,02               ;установить, что это команда SHIFT, для дальнейшей обработки
 00EA  C4 9E 0014 R	 	 	LES     BX,[BP+offset saved_IP]    ;BX указ. на след. за опкодом байт обрабатываемой команды
 00EE  8C C1	 	 	 	MOV     CX,ES               ;ES=CX= CS обрабатываемой команды
 00F0  E8 01F9 R	 	 	CALL    h_ADRMODE           ;возвращает адрес первого операнда в SI и сегмент операнда в ES
 00F3  E8 01C9 R	 	 	CALL    fetch_arg2          ;возвращает второй операнд в CL или CX
 00F6  E8 01A7 R	 	 	CALL    fetch_arg1          ;возвращает первый операнд в DL или DX
 00F9  80 E1 1F	 	 	 	AND     CL,01Fh             ;ограничить величину сдвига
 00FC  8B F8	 	 	 	MOV     DI,AX
 00FE  81 E7 0038	 	 	AND     DI,+38h              ;вычленяем из mod-reg-rm команды только reg
 0102  D1 EF	 	 	 	SHR     DI,1
 0104  D1 EF	 	 	 	SHR     DI,1                ;превратили reg в указатель при переходе
 0106  F6 C4 01	 	 	 	TEST    AH,01               ;8 или 16 бит команда?
 0109  50	 	 	 	PUSH    AX
 010A  8A A6 0018 R	 	 	MOV     AH,[BP+offset saved_FLAGS]       ;старые флаги
 010E  74 06	 	 	 	JZ      shft8               ;8 бит - уйти на 115
 0110  9E	 	 	 	SAHF                        ;записать старые флаги (мл.часть)
 0111  2E: FF A5 04F7 R	 	 	JMP     CS:[DI+SHIFTABLE16] ;переход по таблице сдвига в 16-разрядном случае
 	 	 	 	
 	 	 	 	                            ;8-разр. случай
 0116  9E	 	 	shft8:	SAHF                        ;записать старые флаги (мл.часть)
 0117  2E: FF A5 0507 R	 	 	JMP     CS:[DI+SHIFTABLE8]  ;переход по таблице сдвига в 8-разрядном случае
 	 	 	 	
 	 	 	 	;8-битный операнд
 011C  D2 C2	 	 	ROL8:	ROL     DL,CL               ;000
 011E  EB 3F 90	 	 	 	JMP     set_flag
 0121  D2 CA	 	 	ROR8:	ROR     DL,CL               ;001
 0123  EB 3A 90	 	 	 	JMP     set_flag
 0126  D2 D2	 	 	RCL8:	RCL     DL,CL               ;010
 0128  EB 35 90	 	 	 	JMP     set_flag
 012B  D2 DA	 	 	RCR8:	RCR     DL,CL               ;011
 012D  EB 30 90	 	 	 	JMP     set_flag
 0130  D2 E2	 	 	SHL8:	SHL     DL,CL               ;100 и 110
 0132  EB 2B 90	 	 	 	JMP     set_flag
 0135  D2 EA	 	 	SHR8:	SHR     DL,CL               ;101
 0137  EB 26 90	 	 	 	JMP     set_flag
 013A  D2 FA	 	 	SAR8:	SAR     DL,CL               ;111
 013C  EB 21 90	 	 	 	JMP     set_flag
 	 	 	 	
 	 	 	 	;16-битный операнд
 013F  D3 C2	 	 	ROL16:	ROL     DX,CL               ;000
 0141  EB 1C 90	 	 	 	JMP     set_flag
 0144  D3 CA	 	 	ROR16:	ROR     DX,CL               ;001
 0146  EB 17 90	 	 	 	JMP     set_flag
 0149  D3 D2	 	 	RCL16:	RCL     DX,CL               ;010
 014B  EB 12 90	 	 	 	JMP     set_flag
 014E  D3 DA	 	 	RCR16:	RCR     DX,CL               ;011
 0150  EB 0D 90	 	 	 	JMP     set_flag
 0153  D3 E2	 	 	SHL16:	SHL     DX,CL               ;100 и 110
 0155  EB 08 90	 	 	 	JMP     set_flag
 0158  D3 EA	 	 	SHR16:	SHR     DX,CL               ;101
 015A  EB 03 90	 	 	 	JMP     set_flag
 015D  D3 FA	 	 	SAR16:	SAR     DX,CL               ;111
 	 	 	 	 	
 	 	 	 	;запись в сохраненный в теневом стеке регистр флагов, запись результата и выход
 015F	 	 	 	set_flag:
 015F  9F	 	 	 	LAHF                        ;выгрузить младшие флаги после сдвига в AH
 0160  8A 46 19	 	 	 	MOV     AL,[BP+0019h]       ;прочесть старшие флаги из стека (какие были до команды)
 0163  70 1C	 	 	 	JO      set_OF              ;OF хранится в старших флагах, он уст? да - 183
 0165  24 F7	 	 	 	AND     AL,0F7h             ;нет - сбросить OF=0
 0167  86 E0	 	 	wr_fl:	XCHG    AH,AL
 0169  89 46 18	 	 	 	MOV     [BP+0018h],AX       ;записать в стек правильное значение флагов после сдвига
 016C  58	 	 	 	POP     AX                  ;восстановить первый байт команды в AL и AH (с уст. битом 1)
 016D  E8 0185 R	 	 	CALL    write_result        ;записать результат сдвига в память или регистр
 0170  A1 0006 R	 	 	MOV     AX,cmd_len          ;прочесть полную длину операндов команды из E800:6
 0173  01 46 14	 	 	 	ADD     [BP+0014h],AX       ;увеличить IP на эту длину, чтобы он указывал на след команду
 	 	 	 	 	END_CMD
 0176  C6 06 0005 R 00        +	 	MOV     reg_or_mem,00       ;очистить E800:5, т.к. не инициализируется при входе - для последующих команд
 017B  8B E5                  +	 	MOV     SP,BP               ;восстановить указатель стека на сохраненные при входе регистры
 017D  07                     +	 	POP     ES
 017E  61                     +	 	POPA
 017F  1F                     +	 	POP     DS                  ;восстановить регистры
 0180  CF                     +	 	IRET                        ;закончить обработку команды, восстановить CS и SS
 	 	 	 	
 0181  0C 08	 	 	set_of: OR      AL,08               ;установить OF=1
 0183  EB E2	 	 	 	JMP     wr_fl
 	 	 	 	
 0185	 	 	 	write_result:
 	 	 	 	;запись результата сдвига в требуемое место (туда же, где был и источник)
 0185  F6 06 0005 R 02	 	 	TEST    reg_or_mem,02       ;операнд находится в памяти или в регистре?
 018A  90	 	 	 	NOP
 018B  75 0D	 	 	 	JNZ     wr_mem              ;в памяти - уйти на 019С
 018D  F6 C4 01	 	 	 	TEST    AH,01               ;8 или 16 бит операнд?
 0190  74 04	 	 	 	JZ      wr8reg              ;8 бит - уйти на 0198
 0192  89 52 10	 	 	 	MOV     [BP+SI+10h],DX      ;запись результата в 16-бит регистр
 	 	 	 	 	                            ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
 0195  C3	 	 	 	RET
 	 	 	 	
 0196  88 52 10	 	 	wr8reg: MOV     [BP+SI+10h],DL       ;запись результата в 8-бит регистр
 	 	 	 	 	                            ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
 0199  C3	 	 	 	RET
 019A	 	 	 	wr_mem:	                            ;запись в память
 019A  F6 C4 01	 	 	 	TEST    AH,01               ;8 или 16 бит операнд?
 019D  74 04	 	 	 	JZ      wr8mem              ;8 бит - уйти на 01A5
 019F  26: 89 14	 	 	MOV     ES:[SI],DX          ;запись слова результата в память
 01A2  C3	 	 	 	RET
 	 	 	 	
 01A3  26: 88 14	 	wr8mem:	MOV     ES:[SI],DL          ;запись байта результата в память
 01A6  C3	 	 	 	RET
 01A7	 	 	 	h_SHIFT endp
 	 	 	 	
 	 	 	 	
 	 	 	 	;осуществляет выборку операнда в регистр DL либо DX
 	 	 	 	;вызывается третьим после 01FB, 01CB в обработчиках SHIFT и IMUL
 	 	 	 	;при вызове:
 	 	 	 	;ES указывает на правильный сегмент в памяти с учетом префиксов команды
 	 	 	 	;SI - адрес операнда
 01A7	 	 	 	fetch_arg1 proc near
 01A7  F6 06 0005 R 02	 	 	TEST    reg_or_mem,02       ;операнд находится в памяти или в регистре?
 01AC  90	 	 	 	NOP
 01AD  75 0D	 	 	 	JNZ     rd_mem              ;в памяти - уйти на 01BE
 	 	 	 	 	                            ;операнд в регистре
 01AF  F6 C4 01	 	 	 	TEST    AH,01               ;8 или 16 бит операнд?
 01B2  75 04	 	 	 	JNZ     rd16reg             ;16 бит - уйти на 01BA
 01B4  8A 52 10	 	 	 	MOV     DL,[BP+SI+10h]      ;выборка операнда из 8-бит регистра
 	 	 	 	 	                            ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
 01B7  C3	 	 	 	RET
 	 	 	 	
 01B8	 	 	 	rd16reg:
 01B8  8B 52 10	 	 	 	MOV     DX,[BP+SI+10h]      ;выборка операнда из 16-бит регистра
 01BB  C3	 	 	 	RET
 	 	 	 	        	                    ;выборка из памяти
 01BC  F6 C4 01	 	 	rd_mem:	TEST    AH,01               ;8 или 16 бит операнд?
 01BF  75 04	 	 	 	JNZ     rd16mem             ;16 бит - уйти на 01BA
 01C1  26: 8A 14	 	 	MOV     DL,ES:[SI]          ;выборка 8-бит операнда из памяти
 01C4  C3	 	 	 	RET
 	 	 	 	
 01C5	 	 	 	rd16mem:
 01C5  26: 8B 14	 	 	MOV     DX,ES:[SI]          ;выборка 16-бит операнда из памяти
 01C8  C3	 	 	 	RET
 01C9	 	 	 	fetch_arg1 endp
 	 	 	 	
 	 	 	 	;выборка второго операнда команды в регистр CX или CL
 	 	 	 	;вызывается после h_ADRMODE в обработчиках SHIFT и IMUL
 	 	 	 	;при вызове:
 	 	 	 	;AL - первый байт команды, AH - первый байт команды с правками
 	 	 	 	;CX - CS команды, BX - указывает на следующий за опкодом байт команды
 	 	 	 	;плюс см. возвращаемое h_ADRMODE
 	 	 	 	;при возврате:
 	 	 	 	;E800:6 - реальная длина команды (увеличенная на байт или слово)
 	 	 	 	;CL/CX - второй операнд
 01C9	 	 	 	fetch_arg2 proc near
 01C9  06	 	 	        PUSH    ES
 01CA  8E C1	 	 	 	MOV     ES,CX
 01CC  03 1E 0006 R	 	 	ADD     BX,cmd_len          ;передвинуть BX на байт, следующий за первым операндом команды
 01D0  F6 C4 01	 	 	 	TEST    AH,01               ;8 или 16 бит операнд? (для SHIFT)
 01D3  75 09	 	 	 	JNZ     arg16bit            ;16 бит - уйти на 1E0
 01D5  FE 06 0006 R	 	 	INC     BYTE PTR cmd_len    ;увеличить длину команды на байт
 01D9  26: 8A 0F	 	 	MOV     CL,ES:[BX]          ;прочесть байтовый второй операнд в CL
 01DC  07	 	 	 	POP     ES
 01DD  C3	 	 	 	RET
 01DE	 	 	 	arg16bit:
 01DE  F6 C4 02	 	 	 	TEST    AH,02               ;это команда SHIFT?
 01E1  74 0C	 	 	 	JZ      no_sft              ;нет - уйти на 1F1
 01E3  FE 06 0006 R	 	 	INC     BYTE PTR cmd_len    ;увеличить длину команды на байт
 01E7  26: 8A 0F	 	 	MOV     CL,ES:[BX]          ;прочесть байтовый второй операнд в CL
 01EA  91	 	 	 	XCHG    CX,AX
 01EB  98	 	 	 	CBW
 01EC  91	 	 	 	XCHG    CX,AX               ;превратить операнд в слово, сохраняя знак
 01ED  07	 	 	 	POP     ES
 01EE  C3	 	 	 	RET
 	 	 	 	
 	 	 	 	;не SHIFT и 16-бит
 01EF  80 06 0006 R 00	 	no_sft:	ADD     BYTE PTR cmd_len,0  ;увеличить длину команды на 2 байта
 01F4  26: 8B 0F	 	 	MOV     CX,ES:[BX]          ;прочесть слово второго операнда в CL
 01F7  07	 	 	 	POP     ES
 01F8  C3	 	 	 	RET
 01F9	 	 	 	fetch_arg2 endp
 	 	 	 	
 	 	 	 	;выборка адреса операнда
 	 	 	 	;вызывается во всех обработчиках, кроме ENTER
 	 	 	 	;при вызове:
 	 	 	 	;BX указывает на следующий за опкодом байт команды,
 	 	 	 	;в ES и CX - CS команды
 	 	 	 	;DS указывает на E800, стек с E800:4000
 	 	 	 	;при возврате:
 	 	 	 	;SI - смещение операнда, если он в памяти,
 	 	 	 	;и полуфабрикат для выборки регистра, если он в регистре
 	 	 	 	;ES - сегмент операнда
 	 	 	 	;AL - второй (mod-reg-rm) байт команды
 	 	 	 	;AH - первый (опкод) байт команды
 	 	 	 	;по адресу E800:5 значение:
 	 	 	 	;бит 0 установлен - адресация по регистру BP
 	 	 	 	;бит 1 установлен - операнд в памяти (не в регистре)
 	 	 	 	;по адресу E800:6 значение:
 	 	 	 	;1=регистровый операнд, непосредственный операнд
 	 	 	 	;2=слово смещения
 	 	 	 	;3=байт смещения
 	 	 	 	;позже это будет использоваться как информация о длине команды
 	 	 	 	
 01F9	 	 	 	h_ADRMODE proc near
 01F9  26: 8A 07	 	 	MOV     AL,ES:[BX]          ;прочитали второй (mod-reg-rm) байт команды, т.к. IP указывает на следующий за опкодом
 01FC  3C C0	 	 	 	CMP     AL,0C0h             ;операнды находятся в памяти? (если да, то два старших бита не могут быть 11, т.е. меньше C0h)
 01FE  72 23	 	 	 	JB      inmem               ;да - уйти на 223
 	 	 	 	        	                    ;нет - случай регистровых операндов
 	 	 	 	                	            ;формируем адрес нужного регистра, сохраненного в стеке, по полю rm
 	 	 	 	 	                            ;порядок регистров обратен по отношению к тому, как они сохранены по PUSHA
 	 	 	 	        	                    ;важно, что здесь мы НЕ получим истинного адреса регистра, а только полуфабрикат
 0200  C6 06 0006 R 01	 	 	MOV     BYTE PTR cmd_len,01
 0205  8B F0	 	 	 	MOV     SI,AX
 0207  F6 C4 01	 	 	 	TEST    AH,01               ;8 или 16 разрядный операнд?
 020A  74 09	 	 	 	JZ      inreg8              ;8 - уйти на 216
 020C  81 E6 0007	 	 	AND     SI,07h              ;оставить только три младших бита rm
 0210  D1 E6	 	 	 	SHL     SI,1                ;т.к. регистры в стеке расположены по словам
 0212  F7 DE	 	 	 	NEG     SI                  ;т.к. регистры идут в обратном порядке
 0214  C3	 	 	 	RET
 	 	 	 	
 	 	 	 	;8-разрядный операнд в регистре
 0215	 	 	 	inreg8:
 0215  81 E6 0003	 	 	AND     SI,03h              ;оставить только 2 младших бита rm
 0219  D1 E6	 	 	 	SHL     SI,1                ;т.к. регистры расположены по словам
 021B  F7 DE	 	 	 	NEG     SI                  ;т.к. регистры идут в обратном порядке
 021D  A8 04	 	 	 	TEST    AL,04               ;L-половинки или H-половинки регистров?
 021F  74 01	 	 	 	JZ      l_reg
 0221  46	 	 	 	INC     SI                  ;H-половинки - адрес на 1 больше
 0222  C3	 	 	l_reg:	RET
 	 	 	 	
 	 	 	 	;операнды находятся в памяти
 0223  80 0E 0005 R 02	 	inmem:  OR      reg_or_mem,02
 0228  90	 	 	 	NOP
 0229  33 F6	 	 	 	XOR     SI,SI
 022B  8A D0	 	 	 	MOV     DL,AL               ;mod-reg-rm -> DL
 022D  80 E2 C7	 	 	 	AND     DL,0C7h             ;обнулить поле reg
 0230  80 FA 06	 	 	 	CMP     DL,06               ;06=00-xxx-110 - это прямая адресация со смещ=0?
 0233  74 55	 	 	 	JZ      word_offset         ;да - уйти на 291
 0235  8B F8	 	 	 	MOV     DI,AX
 0237  81 E7 0007	 	 	AND     DI,07h              ;иначе использовать rm как индекс в таблице
 023B  D1 E7	 	 	 	SHL     DI,1                ;таблице слов, а не байт, т.ч. сдвинем на 1 разряд
 023D  2E: FF A5 04E7 R	 	 	JMP     CS:[DI+RM_TABLE]    ;переход по таблице обработчиков rm
 	 	 	 	
 	 	 	 	;обработка режимов косвенной адресации к памяти
 	 	 	 	;сюда (на разные строки) попадаем из таблицы на 04ffh
 	 	 	 	;если затрагивается BP, бит 1 E800:5 уст в 1
 0242  03 76 0A	 	 	RM0:	ADD     SI,[BP+000Ah]       ;точка входа rm=0: BX+SI+смещ (0A - адрес BX в стеке)
 0245  03 76 04	 	 	RM4:	ADD     SI,[BP+0004]        ;точка входа rm=4: SI+смещ (04 - адрес SI в стеке)
 0248  EB 25 90	 	 	 	JMP     check_offset
 024B  80 0E 0005 R 01	 	RM3:	OR      reg_or_mem,01       ;точка входа rm=3: BP+DI+смещ
 0250  90	 	 	 	NOP
 0251  03 76 06	 	 	 	ADD     SI,[BP+0006]        ;06 - адрес BP в стеке
 0254  03 76 02	 	 	RM5:	ADD     SI,[BP+0002]        ;точка входа rm=5: DI+смещ (02 - адрес DI в стеке)
 0257  EB 16 90	 	 	 	JMP     check_offset
 025A  03 76 04	 	 	RM2:	ADD     SI,[BP+0004]        ;точка входа rm=2: BP+SI+смещ (04 - адрес SI в стеке)
 025D  03 76 06	 	 	RM6:	ADD     SI,[BP+0006]        ;точка входа rm=6: BP+смещ (06 - адрес BP в стеке)
 0260  80 0E 0005 R 01	 	 	OR      reg_or_mem,01
 0265  90	 	 	 	NOP
 0266  EB 07 90	 	 	 	JMP     check_offset
 0269  03 76 02	 	 	RM1:	ADD     SI,[BP+0002]        ;точка входа rm=1: BX+DI+смещ (02 - адрес DI в стеке)
 026C  03 76 0A	 	 	RM7:	ADD     SI,[BP+000Ah]       ;точка входа rm=7: BX+смещ (0A - адрес BX в стеке)
 	 	 	 	
 	 	 	 	;общая часть обработки косвенной адресации после прибавления значений регистров
 026F	 	 	 	check_offset:
 026F  A8 C0	 	 	 	TEST    AL,0C0h             ;mod 01,10? (есть смещение?)
 0271  74 25	 	 	 	JZ      no_offset           ;нет - уйти на 29F
 0273  A8 28	 	 	 	TEST    AL,40               ;mod 01? (один байт смещения?)
 0275  74 13	 	 	 	JZ      word_offset         ;нет - уйти на 291
 	 	 	 	;считаем, что байт смещения один
 0277  8B D0	 	 	 	MOV     DX,AX               ;сохраняем КОП и mod-reg-rm
 0279  26: 8A 47 01	 	 	MOV     AL,ES:[BX+01]       ;читаем байт смещения
 027D  98	 	 	 	CBW                         ;превращаем в слово с учетом знака (т.к. прибавляем к 16бит регистру)
 027E  03 F0	 	 	 	ADD     SI,AX               ;прибавили смещение
 0280  8B C2	 	 	 	MOV     AX,DX               ;восстановили КОП и mod-reg-rm
 0282  C6 06 0006 R 02	 	 	MOV     BYTE PTR cmd_len,02
 0287  EB 14 90	 	 	 	JMP     check_pref          ;перейти к выбору сегмента
 	 	 	 	
 	 	 	 	;прямая адресация со смещением =0
 	 	 	 	;два байта смещения или непосредственная словная адресация
 028A	 	 	 	word_offset:
 028A  C6 06 0006 R 03	 	 	MOV     BYTE PTR cmd_len,03
 028F  26: 8B 57 01	 	 	MOV     DX,ES:[BX+01]       ;прочитать слово, следующее сразу за mod-reg-rm
 0293  03 F2	 	 	 	ADD     SI,DX               ;прибавили его к SI (как смещение или как значение)
 0295  EB 06 90	 	 	 	JMP     check_pref          ;перейти к выбору сегмента
 	 	 	 	
 	 	 	 	;сюда попадем, если нет смещения
 0298	 	 	 	no_offset:
 0298  C6 06 0006 R 01	 	 	MOV     BYTE PTR cmd_len,01
 	 	 	 	
 	 	 	 	;установка регистра ES правильным сегментом для доступа к операнду
 029D	 	 	 	check_pref:
 029D  8A 16 0000 R	 	 	MOV     DL,BYTE PTR cmd_inf ;прочесть байт информации о команде, считанный из 1843вг1
 02A1  F6 C2 0F	 	 	 	TEST    DL,0Fh              ;были ли сегментные префиксы?
 02A4  75 15	 	 	 	JNZ     seg_pref            ;да - обработать
 02A6  F6 06 0005 R 01	 	 	TEST    reg_or_mem,01       ;использовали ли регистр BP?
 02AB  90	 	 	 	NOP
 02AC  75 04	 	 	 	JNZ     ss_pref             ;да - установить сегмент SS
 02AE	 	 	 	ds_pref:
 02AE  8E 46 12	 	 	 	MOV     ES,[BP+0012h]       ;установить ES значением DS, которое было до команды
 02B1  C3	 	 	 	RET
 	 	 	 	
 	 	 	 	;если использовался регистр BP либо был префикс SS,
 	 	 	 	;адресоваться нужно по сегменту стека, каким он был до вызова команды (в основной паре SS:SP)
 02B2	 	 	 	ss_pref:
 	 	 	 	 	RESS                        ;F1 FA - переключаемся на основную пару SS:SP
 02B2  F1                     +	 	db 0f1h
 02B3  FA                     +	 	CLI
 02B4  8C D2	 	 	 	MOV     DX,SS               ;сохранили стековый сегмент
 	 	 	 	 	SHSS                        ;F1 FB - переключаемся обратно на теневую пару SS':SP'
 02B6  F1                     +	 	db 0F1h
 02B7  FB                     +	 	STI
 02B8  8E C2	 	 	 	MOV     ES,DX               ;установить ES значением SS, которое было до вызова команды
 02BA  C3	 	 	 	RET
 	 	 	 	
 	 	 	 	;обработка сегментных префиксов
 02BB	 	 	 	seg_pref:
 02BB  F6 C2 08	 	 	 	TEST    DL,08               ;есть префикс CS?
 02BE  90	 	 	 	NOP
 02BF  75 10	 	 	 	JNZ     cs_pref
 02C1  F6 C2 04	 	 	 	TEST    DL,04               ;есть префикс DS?
 02C4  90	 	 	 	NOP
 02C5  75 E7	 	 	 	JNZ     ds_pref
 02C7  F6 C2 02	 	 	 	TEST    DL,02               ;есть префикс ES?
 02CA  90	 	 	 	NOP
 02CB  74 E5	 	 	 	JZ      ss_pref             ;нет - значит префикс SS
 02CD  8E 46 00	 	 	 	MOV     ES,[BP+0000]        ;есть - установить ES значением ES, которое было до вызова команды
 02D0  C3	 	 	 	RET
 02D1	 	 	 	cs_pref:
 02D1  8E 46 16	 	 	 	MOV     ES,[BP+0016h]        ;установить ES значением CS, которое было до вызова команды
 02D4  C3	 	 	 	RET
 02D5	 	 	 	h_ADRMODE endp
 	 	 	 	
 	 	 	 	;обработчик ENTER
 	 	 	 	;команда создания стекового кадра процедуры
 	 	 	 	;формат: enter nvar, nest
 	 	 	 	;C8 iw 00 если ENTER nvar,0
 	 	 	 	;C8 iw ib если ENTER nvar,nest и nest<>0
 	 	 	 	;nvar - кол-во слов памяти под переменные
 	 	 	 	;nest - уровень вложенности процедуры
 	 	 	 	
 	 	 	 	;команда ENTER предполагает следующий формат стекового кадра
 	 	 	 	;(см. Морс С.П., Алберт Д.Д. Архитектура микропроцессора 80286. М.:Радио и связь, 1990 - стр.99):
 	 	 	 	;SS:BP указывает на начало (высший адрес) для стекового кадра
 	 	 	 	;[SS:BP], первый байт стекового кадра, содержит
 	 	 	 	;"динамическую связь" - указатель на начало стекового кадра процедуры, вызвавшей данную
 	 	 	 	;[SS:BP-2] и далее содержат "индикаторы" - указатели на начало стекового кадра всех активных процедур:
 	 	 	 	;-процедура первого уровня вложенности содержит индикатор из одного слова,
 	 	 	 	;  указывающий на свое же слово динамической связи (т.е. на следующее слово [SS:BP], высшее в кадре)
 	 	 	 	;-процедура второго уровня вложенности содержит индикатор из двух слов -
 	 	 	 	;  [SS:BP-2] указывает на начало стекового кадра родительской процедуры,
 	 	 	 	;  [SS:BP-4] указывает на свое же слово динамической связи
 	 	 	 	;-процедура 3-го уровня вложенности содержит индикатор из трех слов -
 	 	 	 	;  [SS:BP-2] - начало стекового кадра процедуры-дедушки, родительской для родительской
 	 	 	 	;  [SS:BP-4] - на начало стекового кадра родительской процедуры
 	 	 	 	;  [SS:BP-6] - на свое же слово динамической связи
 	 	 	 	;и так далее. Т.е n элементов индикатора стекового кадра процедуры уровня n+1
 	 	 	 	;аналогичны индикатору родительской процедуры.
 	 	 	 	;После индикаторов в стековом кадре располагается память под переменные.
 	 	 	 	;В книге Морса все пояснено на картинках и с примерами на Паскале.
 	 	 	 	
 	 	 	 	;команда ENTER обновляет BP (чтобы он указывал на начало созданного стекового кадра),
 	 	 	 	;SP (резервируя место в стеке под созданный кадр),
 	 	 	 	;и записывает в начало созданного стекового кадра "динамическую связь" и "индикатор"
 	 	 	 	
 02D5	 	 	 	h_ENTER proc near
 02D5  C4 5E 14	 	 	 	LES BX,[BP+0014h]     ;BX указ. на след. за опкодом байт обрабатываемой команды,ES:=CS команды
 02D8  26: 8B 17	 	 	MOV DX,ES:[BX]       ;DX:=nvar (кол-во байт памяти под переменные)
 02DB  26: 8A 4F 02	 	 	MOV CL,ES:[BX+02]    ;CL:=nest (уровень вложенности)
 02DF  32 ED	 	 	 	XOR CH,CH
 	 	 	 	 	RESS                  ;основной стек
 02E1  F1                     +	 	db 0f1h
 02E2  FA                     +	 	CLI
 02E3  8B FC	 	 	 	MOV DI,SP            ;DI:=SP указатель основного стека
 	 	 	 	 	SHSS                  ;обратно в теневой стек
 02E5  F1                     +	 	db 0F1h
 02E6  FB                     +	 	STI
 02E7  8B 76 06	 	 	 	MOV SI,[BP+0006]     ;SI:=BP до команды ENTER (указатель на стековый кадр процедуры, вызвавшей данную)
 	 	 	 	     ;DS ранее был установлен на SS до команды ENTER (до входа в прерывание)
 02EA  8D 7D FE	 	 	 	LEA DI,[DI-02]       ;DI:=указатель на начало создаваемого стекового кадра
 02ED  89 7E 06	 	 	 	MOV [BP+0006],DI     ;установили BP-после-команды-ENTER на начало нового стекового кадра
 	 	 	 	 	RESS                 ;основной стек
 02F0  F1                     +	 	db 0f1h
 02F1  FA                     +	 	CLI
 02F2  8C D3	 	 	 	MOV BX,SS            ;BX:=SS сегмент основного стека
 	 	 	 	 	SHSS                 ;обратно в теневой стек
 02F4  F1                     +	 	db 0F1h
 02F5  FB                     +	 	STI
 02F6  8E C3	 	 	 	MOV ES,BX            ;ES:=SS основного стека
 02F8  26: 89 35	 	 	MOV ES:[DI],SI          ;записали указатель на стековый кадр родительской (вызвавшей) процедуры в создаваемый стековый кадр
 02FB  8B DF	 	 	 	MOV BX,DI            ;BX:=указатель на начало создаваемого стекового кадра
 02FD  80 F9 00	 	 	 	CMP CL,00            ;уровень вложенности в команде ENTER =0?
 0300  74 15	 	 	 	JZ var_allocate      ;да - уйти на распределение стека под переменные
 	 	 	 	     ;случай ненулевой вложенности
 0302  FD	 	 	 	STD                  ;строковые команды:= на уменьшение
 0303  1E	 	 	 	PUSH DS
 0304  06	 	 	 	PUSH ES
 0305  1F	 	 	 	POP DS               ;DS=ES:= SS основного стека
 0306  49	 	 	 	DEC CX               ;число элементов индикатора=уровню вложенности,
 	 	 	 	 	                     ;а нам нужно скопировать все элементы индикатора родительской процедуры, у нее уровень на 1 меньше
 0307  8D 74 FE	 	 	 	LEA SI,[SI-02]       ;SI:=смещение на начало индикатора родительской процедуры 
 	 	 	 	                             ;(на 1 слово меньше начала родительского стекового кадра, на которое указывал BP до команды ENTER)
 030A  8D 7D FE	 	 	 	LEA DI,[DI-02]       ;DI:=смещение в основном стеке под индикатор (еще один новый операнд уже после заталкивания туда BP)
 030D  80 F9 00	 	 	 	CMP CL,00            ;уровень вложенности 1? (в этом случае копировать нечего)
 0310  74 02	 	 	 	JZ last_indic        ;да - уйти на запись последнего элемента индикатора
 0312  F3/ A5	 	 	 	REPZ MOVSW           ;скопировать индикатор родительской процедуры в создаваемый кадр
 0314	 	 	 	last_indic:
 0314  89 1D	 	 	 	MOV [DI],BX          ;записать в создаваемый кадр последний элемент индикатора для вложенности >0 -
 	 	 	 	 	                     ;указатель на начало создаваемого стекового кадра
 0316  1F	 	 	 	POP DS               ;DS:=SS основного стека
 0317	 	 	 	var_allocate:
 0317  2B FA	 	 	 	SUB DI,DX            ;продвинуть указатель основного стека (в DI) с учетом места в стековом кадре под кол-во переменных,
 	 	 	 	 	                     ;указанных в команде ENTER, под дин.связь и индикаторы указатель (DI) уже модифицирован
 	 	 	 	 	RESS                 ;основной стек
 0319  F1                     +	 	db 0f1h
 031A  FA                     +	 	CLI
 031B  8B E7	 	 	 	MOV SP,DI            ;обновить непосредственно указатель основного стека
 	 	 	 	 	SHSS                 ;обратно в теневой стек
 031D  F1                     +	 	db 0F1h
 031E  FB                     +	 	STI
 031F  83 46 14 03	 	 	ADD WORD PTR [BP+0014h],+03 ;увеличить IP на длину команды
 	 	 	 	 	END_CMD
 0323  C6 06 0005 R 00        +	 	MOV     reg_or_mem,00       ;очистить E800:5, т.к. не инициализируется при входе - для последующих команд
 0328  8B E5                  +	 	MOV     SP,BP               ;восстановить указатель стека на сохраненные при входе регистры
 032A  07                     +	 	POP     ES
 032B  61                     +	 	POPA
 032C  1F                     +	 	POP     DS                  ;восстановить регистры
 032D  CF                     +	 	IRET                        ;закончить обработку команды, восстановить CS и SS
 032E	 	 	 	h_ENTER endp
 	 	 	 	
 	 	 	 	;обработчик IMUL immediate
 032E	 	 	 	h_IMUL proc near
 032E  C4 5E 14	 	 	 	LES     BX,[BP+0014h]       ;BX указ. на след. за опкодом байт обрабатываемой команды
 0331  8C C1	 	 	 	MOV     CX,ES               ;ES=CX= CS обрабатываемой команды
 0333  E8 01F9 R	 	 	CALL    h_ADRMODE           ;возвращает адрес первого операнда в SI и сегмент операнда в ES
 0336  E8 01C9 R	 	 	CALL    fetch_arg2          ;возвращает второй операнд в CL или CX
 0339  E8 01A7 R	 	 	CALL    fetch_arg1          ;возвращает первый операнд в DL или DX
 033C  91	 	 	 	XCHG    CX,AX               ;AX=второй (непосредственный) операнд, CX = первые 2 байта команды
 033D  F7 EA	 	 	 	IMUL    DX                  ;(DX,AX)=(AX)*(DX)
 033F  70 25	 	 	 	JO      set_OF_CF           ;есть переполнение?
 0341  81 66 18 F7FE	 	 	AND     WORD PTR [BP+0018h],0F7FEh    ;нет - сбросить OF и CF
 0346  8B F1	 	 	write:	MOV     SI,CX               ;SI=первые 2 байта команды (второй на младших адресах)
 0348  81 E6 0038	 	 	AND     SI,38h              ;высечь поле reg из mod-reg-rm
 034C  D1 EE	 	 	 	SHR     SI,1
 034E  D1 EE	 	 	 	SHR     SI,1                ;сдвинуть к началу регистра, с учетом того, что адресоваться по словам
 0350  F7 DE	 	 	 	NEG     SI                  ;т.к. регистры в поле reg идут в обратном порядке по отношению к стеку
 0352  89 42 10	 	 	 	MOV     [BP+SI+10h],AX      ;запись результата в 16-бит регистр
 	 	 	 	        	                    ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
 0355  A1 0006 R	 	 	MOV     AX,cmd_len        ;прочесть полную длину операндов команды из E800:6
 0358  01 46 14	 	 	 	ADD     [BP+0014h],AX        ;увеличить IP на эту длину, чтобы он указывал на след команду
 	 	 	 	 	END_CMD
 035B  C6 06 0005 R 00        +	 	MOV     reg_or_mem,00       ;очистить E800:5, т.к. не инициализируется при входе - для последующих команд
 0360  8B E5                  +	 	MOV     SP,BP               ;восстановить указатель стека на сохраненные при входе регистры
 0362  07                     +	 	POP     ES
 0363  61                     +	 	POPA
 0364  1F                     +	 	POP     DS                  ;восстановить регистры
 0365  CF                     +	 	IRET                        ;закончить обработку команды, восстановить CS и SS
 	 	 	 	
 	 	 	 	;если получили флаг OF
 0366	 	 	 	set_OF_CF:
 0366  81 4E 18 0801	 	 	OR      WORD PTR [BP+0018h],0801h    ;установить OF и CF
 036B  EB D9	 	 	 	JMP     write
 036D	 	 	 	h_IMUL endp
 	 	 	 	
 	 	 	 	;обработчик BOUND
 	 	 	 	;формат команды:
 	 	 	 	;BOUND reg16 mem
 	 	 	 	;62 mod-reg-rm mem1 mem2
 	 	 	 	;поскольку команда двухадресная, mod-reg-rm указывает на второй аргумент
 036D	 	 	 	h_BOUND proc near
 036D  80 CC 01	 	 	 	OR      AH,01                      ;установить 16-бит тип операнда
 0370  C4 5E 14	 	 	 	LES     BX,[BP+0014h]              ;BX указ. на след. за опкодом байт обрабатываемой команды,ES:=CS команды
 0373  26: 80 3F BF	 	 	CMP     ES:BYTE PTR [BX],0BFh      ;операнд в регистре? (mod в mod-reg-rm = 11?)
 0377  77 27	 	 	 	JA      h_EXIT                     ;да - уйти на 3B2 (выход из команды)
 0379  E8 01F9 R	 	 	CALL    h_ADRMODE                  ;возвращает адрес (???второго) операнда в SI и сегмент операнда в ES
 037C  26: 8B 0C	 	 	MOV     CX,ES:[SI]                 ;CX:= операнд из памяти - нижняя граница массива
 037F  26: 8B 54 02	 	 	MOV     DX,ES:[SI+02]              ;DX:= следующее за ним слово - верхняя граница массива
 0383  8B F0	 	 	 	MOV     SI,AX                      ;SI=первые 2 байта команды (второй на младших адресах)
 0385  81 E6 0026	 	 	AND     SI,+38                     ;высечь поле reg из mod-reg-rm
 0389  D1 EE	 	 	 	SHR     SI,1
 038B  D1 EE	 	 	 	SHR     SI,1                       ;сдвинуть к началу регистра, с учетом того, что адресоваться по словам
 038D  F7 DE	 	 	 	NEG     SI                         ;т.к. регистры в поле reg идут в обратном порядке по отношению к стеку
 038F  8B 42 0A	 	 	 	MOV     AX,[BP+SI+10]              ;чтение операнда-регистра
 	 	 	 	 	                                   ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
 0392  3B C8	 	 	 	CMP     CX,AX                      ;сравнение с нижней границей
 0394  77 15	 	 	 	JA      em_INT5                    ;если вышли за нее (н.граница>числа) - уйти на 3BD
 0396  3B C2	 	 	 	CMP     AX,DX                      ;сравнение с верхней границей
 0398  77 11	 	 	 	JA      em_INT5                    ;если вышли за нее (число>в.границв) - уйти на 3BD
 039A  A1 0006 R	 	 	MOV     AX,cmd_len                 ;иначе считать длину операндов команды
 039D  01 46 14	 	 	 	ADD     [BP+0014h],AX              ;увеличить IP в стеке на эту длину, чтобы он указывал на начало след.команды
 	 	 	 	
 	 	 	 	;обработчик ненайденной команды
 	 	 	 	;также завершающая фаза обработчика BOUND
 03A0	 	 	 	h_EXIT: END_CMD
 03A0  C6 06 0005 R 00        +	 	MOV     reg_or_mem,00       ;очистить E800:5, т.к. не инициализируется при входе - для последующих команд
 03A5  8B E5                  +	 	MOV     SP,BP               ;восстановить указатель стека на сохраненные при входе регистры
 03A7  07                     +	 	POP     ES
 03A8  61                     +	 	POPA
 03A9  1F                     +	 	POP     DS                  ;восстановить регистры
 03AA  CF                     +	 	IRET                        ;закончить обработку команды, восстановить CS и SS
 	 	 	 	
 	 	 	 	;BOUND: случай выхода за границу массива
 	 	 	 	;эмуляция действий процессора при вызове INT 5
 03AB	 	 	 	em_INT5:
 03AB  8B 46 14	 	 	 	MOV     AX,[BP+0014h]              ;считать IP в стеке (указывающий на второй байт эмулируемой команды)
 03AE  48	 	 	 	DEC     AX                         ;теперь IP указывает на опкод
 03AF  F6 06 0001 R 0F	 	 	TEST    BYTE PTR cmd_inf+1,0Fh     ;были ли префиксы у команды?
 03B4  74 01	 	 	 	JZ      get_CS
 03B6  48	 	 	 	DEC     AX                         ;если были префиксы, сделать IP указывающим на байт префикса
 	 	 	 	        	                           ;теперь IP точно указывает на начало команды
 03B7  8B 5E 16	 	 	get_CS: MOV     BX,[BP+0016h]              ;BX:=CS команды
 03BA  8B 4E 18	 	 	 	MOV     CX,[BP+0018h]              ;CX:=флаги команды
 	 	 	 	 	RESS                               ;переключаемся на основную пару SS:SP
 03BD  F1                     +	 	db 0f1h
 03BE  FA                     +	 	CLI
 03BF  51	 	 	 	PUSH    CX                         ;как бы pushf
 03C0  53	 	 	 	PUSH    BX                         ;как бы push cs
 03C1  50	 	 	 	PUSH    AX                         ;как бы push ip - все в основном стеке, как при уходе на прерывание
 	 	 	 	 	SHSS                               ;обратно на теневую пару SS':SP'
 03C2  F1                     +	 	db 0F1h
 03C3  FB                     +	 	STI
 03C4  33 C0	 	 	 	XOR     AX,AX
 03C6  8E C0	 	 	 	MOV     ES,AX                      ;ES указывает на таблицу векторов прерываний
 03C8  26: A1 0014 R	 	 	MOV     AX,ES:int5_ip              ;14h=20=5*4, начало записи для INT 5 в таблице векторов
 03CC  89 46 14	 	 	 	MOV     [BP+0014h],AX              ;IP стека эмулятора:= IP обработчика INT 5
 03CF  26: A1 0016 R	 	 	MOV     AX,ES:int5_cs
 03D3  89 46 16	 	 	 	MOV     [BP+0016h],AX              ;CS стека эмулятора:= CS обработчика INT 5
 03D6  80 66 19 FC	 	 	AND     BYTE PTR [BP+0019h],0FCh   ;сбросить IF и TF во флагах в стеке, как при уходе на прерывание
 03DA  90	 	 	 	NOP
 03DB  EB C3	 	 	 	JMP     h_EXIT                     ;возврат из эмулятора
 03DD	 	 	 	h_BOUND endp
 	 	 	 	
 	 	 	 	;таблица адресов программ эмуляции команд
 	 	 	 	;адрес в таблице соответствует опкоду
 03DD	 	 	 	OP_table label byte
 03DD  0100 [	 	 	 	db	256 DUP (0)
                00	 	
                    ]	 	
 	 	 	 	
 043F	 	 	 	org offset OP_table+62h
 043F  02	 	 	 	db	02                         ;62h - BOUND
 0446	 	 	 	org offset OP_table+69h
 0446  04	 	 	 	db	04                         ;69h - IMUL immediate
 0448	 	 	 	org offset OP_table+6bh
 0448  04	 	 	 	db	04                         ;6bh - IMUL S immediate
 049D	 	 	 	org offset OP_table+0c0h
 049D  06	 	 	 	db	06                         ;c0h - SHIFT immediate
 049E  06	 	 	 	db	06                         ;c1h - SHIFT immediate
 04A5	 	 	 	org offset OP_table+0c8h
 04A5  08	 	 	 	db	08                         ;c8h - ENTER
 04DD	 	 	 	org offset OP_table+256
 	 	 	 	
 	 	 	 	;таблица адресов обработчиков команд
 04DD	 	 	 	CMD_TABLE label word
 04DD  03A0 R	 	 	 	DW      offset h_EXIT              ;обработчик ненайденной команды
 04DF  036D R	 	 	 	DW      offset h_BOUND             ;обрабочик BOUND (смещ.2)
 04E1  032E R	 	 	 	DW      offset h_IMUL              ;обработчик IMUL (смещ.4)
 04E3  00E7 R	 	 	 	DW      offset h_SHIFT             ;обработчик сдвигов (смещ.6)
 04E5  02D5 R	 	 	 	DW      offset h_ENTER             ;обработчик ENTER (смещ.8)
 	 	 	 	
 	 	 	 	;таблица адресов обработчиков режимов косвенной адресации rm  (mod=00,01,10)
 04E7	 	 	 	RM_TABLE label word
 04E7  0242 R	 	 	 	DW      offset RM0                 ;rm=0
 04E9  0269 R	 	 	 	DW      offset RM1                 ;rm=1
 04EB  025A R	 	 	 	DW      offset RM2                 ;rm=2
 04ED  024B R	 	 	 	DW      offset RM3                 ;rm=3
 04EF  0245 R	 	 	 	DW      offset RM4                 ;rm=4
 04F1  0254 R	 	 	 	DW      offset RM5                 ;rm=5
 04F3  025D R	 	 	 	DW      offset RM6                 ;rm=6
 04F5  026C R	 	 	 	DW      offset RM7                 ;rm=7
 	 	 	 	
 	 	 	 	;таблица адресов обработчиков команд сдвига в 16-разрядном случае
 	 	 	 	;NB! по справочнику Морса reg=6 (010) не используется,
 	 	 	 	;а здесь reg=6 аналогично reg=4 (100)
 04F7	 	 	 	SHIFTABLE16 label word
 04F7  013F R	 	 	 	DW      offset ROL16               ;000 - ROL
 04F9  0144 R	 	 	 	DW      offset ROR16               ;001 - ROR
 04FB  0149 R	 	 	 	DW      offset RCL16               ;010 - RCL
 04FD  014E R	 	 	 	DW      offset RCR16               ;011 - RCR
 04FF  0153 R	 	 	 	DW      offset SHL16               ;100 - SHL
 0501  0158 R	 	 	 	DW      offset SHR16               ;101 - SHR
 0503  0153 R	 	 	 	DW      offset SHL16               ;110 - ничего
 0505  015D R	 	 	 	DW      offset SAR16               ;111 - SAR
 	 	 	 	
 	 	 	 	;таблица адресов обработчиков команд сдвига в 8-разрядном случае
 	 	 	 	;NB! по справочнику Морса reg=6 (010) не используется,
 	 	 	 	;а здесь reg=6 аналогично reg=4 (100)
 0507	 	 	 	SHIFTABLE8 label word
 0507  011C R	 	 	 	DW      offset ROL8               ;000 - ROL
 0509  0121 R	 	 	 	DW      offset ROR8               ;001 - ROR
 050B  0126 R	 	 	 	DW      offset RCL8               ;010 - RCL
 050D  012B R	 	 	 	DW      offset RCR8               ;011 - RCR
 050F  0130 R	 	 	 	DW      offset SHL8               ;100 - SHL
 0511  0135 R	 	 	 	DW      offset SHR8               ;101 - SHR
 0513  0130 R	 	 	 	DW      offset SHL8               ;110 - ничего
 0515  013A R	 	 	 	DW      offset SAR8               ;111 - SAR
 	 	 	 	
 	 	 	 	;располагается по адресу 052Fh и вероятно возник из-за выравнивания следующего сегмента по слову или параграфу
 0517  00	 	 	 	DB      00h
 	 	 	 	
 0518	 	 	 	_TEXT ends
 	 	 	 	
 0000	 	 	 	STACK segment para stack 'STACK'
 	 	 	 	;этого в памяти эмулятора уже не будет, это пойдет в E800:0
 0000     08 [	 	 	 	DB	8 dup (0)
                00	 	
                    ]	 	
 	 	 	 	
 0008	 	 	 	STACK ends
 	 	 	 	end h_int6


Macros:

	 	N a m e  	 	Length

CLM. . . . . . . . . . . . . . .	0001
END_CMD. . . . . . . . . . . . .	0011
RESS . . . . . . . . . . . . . .	0001
SHSS . . . . . . . . . . . . . .	0001
STM. . . . . . . . . . . . . . .	0001

Segments and Groups:

	 	N a m e	 	 	Size	Align	Combine	Class

DATA . . . . . . . . . . . . . .	0008	AT    	E800	
INT_TBL. . . . . . . . . . . . .	0018	AT    	0000	
SHADOW_STACK . . . . . . . . . .	001A	AT    	EC00	
STACK. . . . . . . . . . . . . .	0008	PARA  	STACK 	'STACK'
_TEXT. . . . . . . . . . . . . .	0518	WORD  	PUBLIC	'CODE'

Symbols:            

	 	N a m e	 	 	Type	Value	Attr         

ARG16BIT . . . . . . . . . . . .	L NEAR 	01DE	_TEXT
BCKP_INT1_CS . . . . . . . . . .	Alias	CMD_WORD	 	
BCKP_INT1_IP . . . . . . . . . .	Alias	CMD_INF	 	
CHECK_OFFSET . . . . . . . . . .	L NEAR 	026F	_TEXT
CHECK_PREF . . . . . . . . . . .	L NEAR 	029D	_TEXT
CMD_INF. . . . . . . . . . . . .	L WORD 	0000	DATA
CMD_LEN. . . . . . . . . . . . .	L WORD 	0006	DATA
CMD_TABLE. . . . . . . . . . . .	L WORD 	04DD	_TEXT
CMD_WORD . . . . . . . . . . . .	L WORD 	0002	DATA
CS_PREF. . . . . . . . . . . . .	L NEAR 	02D1	_TEXT
DS_PREF. . . . . . . . . . . . .	L NEAR 	02AE	_TEXT
EM_INT5. . . . . . . . . . . . .	L NEAR 	03AB	_TEXT
ENDNMI . . . . . . . . . . . . .	L NEAR 	0072	_TEXT
EXIT7. . . . . . . . . . . . . .	L NEAR 	00E3	_TEXT
FETCH_ARG1 . . . . . . . . . . .	N PROC	01A7	_TEXT	Length =0022
FETCH_ARG2 . . . . . . . . . . .	N PROC	01C9	_TEXT	Length =0030
GET_CS . . . . . . . . . . . . .	L NEAR 	03B7	_TEXT
H_ADRMODE. . . . . . . . . . . .	N PROC	01F9	_TEXT	Length =00DC
H_BOUND. . . . . . . . . . . . .	N PROC	036D	_TEXT	Length =0070
H_ENTER. . . . . . . . . . . . .	N PROC	02D5	_TEXT	Length =0059
H_EXIT . . . . . . . . . . . . .	L NEAR 	03A0	_TEXT
H_IMUL . . . . . . . . . . . . .	N PROC	032E	_TEXT	Length =003F
H_INT1 . . . . . . . . . . . . .	F PROC	002E	_TEXT	Length =0062
H_INT6 . . . . . . . . . . . . .	F PROC	0000	_TEXT	Length =002B
H_INT7 . . . . . . . . . . . . .	F PROC	0090	_TEXT	Length =0057
H_SHIFT. . . . . . . . . . . . .	N PROC	00E7	_TEXT	Length =00C0
INMEM. . . . . . . . . . . . . .	L NEAR 	0223	_TEXT
INREG8 . . . . . . . . . . . . .	L NEAR 	0215	_TEXT
INT1_CS. . . . . . . . . . . . .	L WORD 	0006	INT_TBL

INT1_IP. . . . . . . . . . . . .	L WORD 	0004	INT_TBL
INT5_CS. . . . . . . . . . . . .	L WORD 	0016	INT_TBL
INT5_IP. . . . . . . . . . . . .	L WORD 	0014	INT_TBL
IRQ13. . . . . . . . . . . . . .	L NEAR 	0074	_TEXT
LAST_INDIC . . . . . . . . . . .	L NEAR 	0314	_TEXT
L_REG. . . . . . . . . . . . . .	L NEAR 	0222	_TEXT
NMIGEN . . . . . . . . . . . . .	L NEAR 	008C	_TEXT
NOPREF . . . . . . . . . . . . .	L NEAR 	00CD	_TEXT
NO_OFFSET. . . . . . . . . . . .	L NEAR 	0298	_TEXT
NO_SFT . . . . . . . . . . . . .	L NEAR 	01EF	_TEXT
OP_TABLE . . . . . . . . . . . .	L BYTE 	03DD	_TEXT
RCL16. . . . . . . . . . . . . .	L NEAR 	0149	_TEXT
RCL8 . . . . . . . . . . . . . .	L NEAR 	0126	_TEXT
RCR16. . . . . . . . . . . . . .	L NEAR 	014E	_TEXT
RCR8 . . . . . . . . . . . . . .	L NEAR 	012B	_TEXT
RD16MEM. . . . . . . . . . . . .	L NEAR 	01C5	_TEXT
RD16REG. . . . . . . . . . . . .	L NEAR 	01B8	_TEXT
RD_MEM . . . . . . . . . . . . .	L NEAR 	01BC	_TEXT
REG_OR_MEM . . . . . . . . . . .	L BYTE 	0005	DATA
RM0. . . . . . . . . . . . . . .	L NEAR 	0242	_TEXT
RM1. . . . . . . . . . . . . . .	L NEAR 	0269	_TEXT
RM2. . . . . . . . . . . . . . .	L NEAR 	025A	_TEXT
RM3. . . . . . . . . . . . . . .	L NEAR 	024B	_TEXT
RM4. . . . . . . . . . . . . . .	L NEAR 	0245	_TEXT
RM5. . . . . . . . . . . . . . .	L NEAR 	0254	_TEXT
RM6. . . . . . . . . . . . . . .	L NEAR 	025D	_TEXT
RM7. . . . . . . . . . . . . . .	L NEAR 	026C	_TEXT
RM_TABLE . . . . . . . . . . . .	L WORD 	04E7	_TEXT
ROL16. . . . . . . . . . . . . .	L NEAR 	013F	_TEXT
ROL8 . . . . . . . . . . . . . .	L NEAR 	011C	_TEXT
ROR16. . . . . . . . . . . . . .	L NEAR 	0144	_TEXT
ROR8 . . . . . . . . . . . . . .	L NEAR 	0121	_TEXT
SAR16. . . . . . . . . . . . . .	L NEAR 	015D	_TEXT
SAR8 . . . . . . . . . . . . . .	L NEAR 	013A	_TEXT
SAVED_AX . . . . . . . . . . . .	L WORD 	0010	SHADOW_STACK
SAVED_BP . . . . . . . . . . . .	L WORD 	0006	SHADOW_STACK
SAVED_BX . . . . . . . . . . . .	L WORD 	000A	SHADOW_STACK
SAVED_CS . . . . . . . . . . . .	L WORD 	0016	SHADOW_STACK
SAVED_CX . . . . . . . . . . . .	L WORD 	000E	SHADOW_STACK
SAVED_DI . . . . . . . . . . . .	L WORD 	0002	SHADOW_STACK
SAVED_DS . . . . . . . . . . . .	L WORD 	0012	SHADOW_STACK
SAVED_DX . . . . . . . . . . . .	L WORD 	000C	SHADOW_STACK
SAVED_ES . . . . . . . . . . . .	L WORD 	0000	SHADOW_STACK
SAVED_FLAGS. . . . . . . . . . .	L WORD 	0018	SHADOW_STACK
SAVED_IP . . . . . . . . . . . .	L WORD 	0014	SHADOW_STACK
SAVED_SI . . . . . . . . . . . .	L WORD 	0004	SHADOW_STACK
SAVED_SP . . . . . . . . . . . .	L WORD 	0008	SHADOW_STACK
SEG_PREF . . . . . . . . . . . .	L NEAR 	02BB	_TEXT
SET_FLAG . . . . . . . . . . . .	L NEAR 	015F	_TEXT
SET_OF . . . . . . . . . . . . .	L NEAR 	0181	_TEXT
SET_OF_CF. . . . . . . . . . . .	L NEAR 	0366	_TEXT
SHFT8. . . . . . . . . . . . . .	L NEAR 	0116	_TEXT
SHIFTABLE16. . . . . . . . . . .	L WORD 	04F7	_TEXT

SHIFTABLE8 . . . . . . . . . . .	L WORD 	0507	_TEXT
SHL16. . . . . . . . . . . . . .	L NEAR 	0153	_TEXT
SHL8 . . . . . . . . . . . . . .	L NEAR 	0130	_TEXT
SHR16. . . . . . . . . . . . . .	L NEAR 	0158	_TEXT
SHR8 . . . . . . . . . . . . . .	L NEAR 	0135	_TEXT
SS_PREF. . . . . . . . . . . . .	L NEAR 	02B2	_TEXT
VAR_ALLOCATE . . . . . . . . . .	L NEAR 	0317	_TEXT
WORD_OFFSET. . . . . . . . . . .	L NEAR 	028A	_TEXT
WR8MEM . . . . . . . . . . . . .	L NEAR 	01A3	_TEXT
WR8REG . . . . . . . . . . . . .	L NEAR 	0196	_TEXT
WRITE. . . . . . . . . . . . . .	L NEAR 	0346	_TEXT
WRITE_RESULT . . . . . . . . . .	L NEAR 	0185	_TEXT
WR_FL. . . . . . . . . . . . . .	L NEAR 	0167	_TEXT
WR_MEM . . . . . . . . . . . . .	L NEAR 	019A	_TEXT

45048 Bytes free   

Warning Severe
Errors	Errors 
0	0

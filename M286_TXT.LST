 	 	 	 	.286c                               ;включить инструкции реального режима 286
 	 	 	 	
 0000	 	 	 	DATA segment at 0E800h
 0000  ????	 	 	cmd_inf	 	dw	?           ;слово информации о прерванной команде из 1843ВГ1. Содержит сегментные префиксы
 0002  ????	 	 	cmd_word	dw	?           ;два первых байта команды, считываются из 1843ВГ1
 0004  ??	 	 	 	 	db	?           ;на этот байт ссылок нет
 0005  ??	 	 	reg_or_mem	db	?           ;байт флажков информации об эмулируемой команде
 0006  ????	 	 	cmd_len	 	dw	?           ;длина операндов команды
 	 	 	 	
 =	 	 	 	bckp_int1_ip	equ	cmd_inf
 =	 	 	 	bckp_int1_cs	equ	cmd_word
 0008	 	 	 	DATA ends
 	 	 	 	
 0000	 	 	 	INT_TBL segment at 0h               ;таблица векторов прерываний
 0004	 	 	 	org 01h*4                           ;INT 01h - прерывание пошагового режима, вызывается после каждой команды, если TF=1
 0004  ????	 	 	int1_ip	dw	?
 0006  ????	 	 	int1_cs	dw	?
 0014	 	 	 	org 05h*4                           ;INT 05h - прерывание, генерируемое по команде BOUND
 0014  ????	 	 	int5_ip	dw	?
 0016  ????	 	 	int5_cs	dw	?
 0018	 	 	 	INT_TBL ends
 	 	 	 	
 0000	 	 	 	SHADOW_STAC segment at 0EC00h
 0000  ????	 	 	saved_ES	dw	?
 0002  ????	 	 	saved_DI	dw	?
 0004  ????	 	 	saved_SI	dw	?
 0006  ????	 	 	saved_BP	dw	?
 0008  ????	 	 	saved_SP	dw	?
 000A  ????	 	 	saved_BX	dw	?
 000C  ????	 	 	saved_DX	dw	?
 000E  ????	 	 	saved_CX	dw	?
 0010  ????	 	 	saved_AX	dw	?
 0012  ????	 	 	saved_DS	dw	?
 0014  ????	 	 	saved_IP	dw	?
 0016  ????	 	 	saved_CS	dw	?
 0018  ????	 	 	saved_FLAGS	dw	?
 001A	 	 	 	SHADOW_STAC ends
 	 	 	 	
 0000	 	 	 	_TEXT segment word public 'CODE'
 	 	 	 	
 	 	 	 	;обработчик прерывания int 06h (неизвестная команда)
 	 	 	 	;оказались в стеке, адресуемом теневой парой
 	 	 	 	;SS':SP'=E800:4000 (EC000h)
 	 	 	 	;CS:IP, сохраненные в стеке, указывают на следующий за опкодом байт команды
 	 	 	 	assume cs:_TEXT
 0000	 	 	 	h_int6 proc far
 0000  1E	 	 	 	PUSH    DS
 0001  60	 	 	 	PUSHA                       ;AX,CX,DX,BX,SP,BP,SI,DI
 0002  06	 	 	 	PUSH    ES
 0003  8B EC	 	 	 	MOV     BP,SP               ;BP - ук-ль стека после сохранения всех регистров
 	 	 	 	;теперь имеем
 	 	 	 	;[BP]=ES
 	 	 	 	;[BP+2]=DI
 	 	 	 	;[BP+4]=SI
 	 	 	 	;[BP+6]=BP
 	 	 	 	;[BP+8]=SP
 	 	 	 	;[BP+0Ah]=BX
 	 	 	 	;[BP+0Ch]=DX
 	 	 	 	;[BP+0Eh]=CX
 	 	 	 	;[BP+10h]=AX
 	 	 	 	;[BP+12h]=DS
 	 	 	 	;[BP+14h]=IP
 	 	 	 	;[BP+16h]=CS
 	 	 	 	;[BP+18h]=FLAGS
 0005  8C D0	 	 	 	MOV     AX,SS
 0007  8E D8	 	 	 	MOV     DS,AX               ;DS:=SS=E800,сегмент стека при входе в прерывание (установлено загрузчиком эмулятора)
 	 	 	 	                                    ;теперь по DS можно адресоваться к области данных эмулятора E800:0 (ну и к стеку)
 	 	 	 	assume DS:DATA
 0009  E4 C8	 	 	 	IN      AL,0C8h             ;c8h - порт информации о команде 1843вг1
 000B  8A E0	 	 	 	MOV     AH,AL
 000D  E4 C8	 	 	 	IN      AL,0C8h
 000F  A3 0000 R	 	 	MOV     cmd_inf,AX        ;сохранили считанное из порта информации о команде в DS:0 (E800:0)
 0012  E4 CE	 	 	 	IN      AL,0CEh             ;ceh - порт первого слова команды 1843вг1
 0014  8A E0	 	 	 	MOV     AH,AL
 0016  E4 CE	 	 	 	IN      AL,0CEh
 0018  A3 0002 R	 	 	MOV     cmd_word,AX       ;сохранили считанное из порта слова команды в DS:2 (E800:2)
 001B  8A C4	 	 	 	MOV     AL,AH               ;оставили только первый байт
 001D  BB 03ED R	 	 	MOV     BX,offset op_table  ;адрес таблицы опкодов
 0020  2E: D7	 	 	 	XLAT    CS:op_table         ;AL:=номер обработчика в таблице обработчиков команд
 0022  32 FF	 	 	 	XOR     BH,BH
 0024  8A D8	 	 	 	MOV     BL,AL
 0026  2E: FF A7 04ED R	 	 	JMP     CS:[BX+CMD_TABLE]   ;адрес таблицы адресов обработчиков команд
 	 	 	 	                                    ;перешли на обработчик соответствующей команды
 002B	 	 	 	h_int6 endp
 	 	 	 	
 002B  B8 ---- R	 	 	MOV     AX,STACK           ;адрес настраивается при загрузке EXE-шника - т.е. это был сегмент. В файле - 0053h
 	 	 	 	                                               ;возможно, использован как указатель конца кода эмулятора для загрузчика
 	 	 	 	
 	 	 	 	;обработчик INT 01h (пошаговый режим)
 	 	 	 	;устанавливается при первом вызове сопроцессорной команды в обработчике INT 7
 002E	 	 	 	h_int1 proc far
 002E  50	 	 	 	PUSH    AX
 002F  1E	 	 	 	PUSH    DS
 0030  06	 	 	 	PUSH    ES
 0031  33 C0	 	 	 	XOR     AX,AX
 0033  8E D8	 	 	 	MOV     DS,AX               ;уст DS на таблицу векторов прерываний
 	 	 	 	assume DS:INT_TBL
 0035  B8 E800	 	 	 	MOV     AX,0E800h
 0038  8E C0	 	 	 	MOV     ES,AX               ;уст ES на область данных эмулятора E800
 003A  26: A1 0000 R	 	 	MOV     AX,ES:bckp_int1_ip  ;прочесть сохраненный IP INT 1
 003E  A3 0004 R	 	 	MOV     int1_ip,AX         ;записать в таблицу векторов
 0041  26: A1 0002 R	 	 	MOV     AX,ES:bckp_int1_cs  ;прочесть сохраненный CS INT 1
 0045  A3 0006 R	 	 	MOV     int1_cs,AX         ;записать в таблицу векторов
 0048  26: A1 0004	 	 	MOV     AX,ES:[0004]        ;прочесть сохраненные флаги, бывшие до вызова INT 7
 004C  07	 	 	 	POP     ES
 004D  1F	 	 	 	POP     DS
 	 	 	 	assume DS:DATA
 004E  87 EC	 	 	 	XCHG    BP,SP
 	 	 	 	;теперь распределение в стеке такое
 	 	 	 	;[BP]=AX
 	 	 	 	;[BP+2]=IP
 	 	 	 	;[BP+4]=CS
 	 	 	 	;[BP+6]=FLAGS
 	 	 	 	;SP'=BP до прерывания
 0050  89 46 06	 	 	 	MOV     [BP+06],AX          ;записать старые флаги
 0053  87 EC	 	 	 	XCHG    BP,SP               ;восстановить BP и SP
 0055  B0 0A	 	 	 	MOV     AL,0Ah              ;команда контроллеру прерываний: чтение регистра IRR (запросов на прерывание)
 0057  E6 A0	 	 	 	OUT     0A0h,AL             ;A0h - второй контроллер прерываний
 0059  EB 00	 	 	 	JMP     $+2                 ;очистить очередь команд
 005B  E4 A0	 	 	 	IN      AL,0A0h             ;прочитать регистр запросов на прерывание 2-го контроллера
 005D  A8 20	 	 	 	TEST    AL,20h              ;было прерывание от сопроцессора? (IRQ 13)
 005F  75 13	 	 	 	JNZ     IRQ13               ;да - уйти на 0074
 0061  9B	 	 	 	WAIT                        ;иначе ждать готовности сопроцессора
 0062  F1	 	 	 	DB      0F1h
 0063  FD	 	 	 	STD                         ;включить INT 07 на каждую ESC команду
 0064  E4 62	 	 	 	IN      AL,62h
 0066  0C 40	 	 	 	OR      AL,40h              ;установить триггер блокировки очереди команд процессора
 0068  E6 62	 	 	 	OUT     62h,AL
 006A  A8 10	 	 	 	TEST    AL,10h              ;частота сопроцессора 8мгц?
 006C  75 04	 	 	 	JNZ     endnmi              ;да - уйти на 72
 006E  E6 E0	 	 	 	OUT     0E0h,AL             ;иначе переключить синхронизатор
 0070  EB 00	 	 	 	JMP     $+2                 ;очистить очередь команд
 0072  58	 	 	endnmi:	POP     AX
 0073  CF	 	 	 	IRET
 	 	 	 	
 	 	 	 	;если было прерывание от сопроцессора IRQ13
 0074  B0 14	 	 	IRQ13:	MOV     AL,20
 0076  E6 A0	 	 	 	OUT     0A0h,AL             ;команда 2-му контроллеру прерывания "обычный конец прерывания"
 0078  B0 62	 	 	 	MOV     AL,62h
 007A  E6 20	 	 	 	OUT     20h,AL               ;команда 1-му контроллеру прерывания "специальный конец прерывания" - сброс каскадируемого IRQ2
 007C  F1	 	 	 	DB      0F1h
 007D  FD	 	 	 	STD                         ;включить INT 07 на каждую ESC команду
 007E  E4 62	 	 	 	IN      AL,62h
 0080  0C 40	 	 	 	OR      AL,40h               
 0082  E6 62	 	 	 	OUT     62h,AL              ;установить триггер блокировки очереди команд процессора
 0084  A8 10	 	 	 	TEST    AL,10h              ;частота сопроцессора 8мгц?
 0086  75 04	 	 	 	JNZ     nmigen              ;да - уйти на 8C
 0088  E6 E0	 	 	 	OUT     0E0h,AL             ;иначе переключить синхронизатор
 008A  EB 00	 	 	 	JMP     $+2                 ;очистить очередь команд
 008C  58	 	 	nmigen:	POP     AX
 008D  CD 02	 	 	 	INT     02                  ;вновь сгенерировать NMI уже с настоящим обработчиком (сохраненным по первому вызову int07h)
 008F  CF	 	 	 	IRET
 0090	 	 	 	h_int1 endp
 	 	 	 	
 	 	 	 	;обработчик прерывания int 07h (встречена команда сопроцессора ESC)
 0090	 	 	 	h_int7 proc far
 0090  50	 	 	 	PUSH    AX
 0091  1E	 	 	 	PUSH    DS
 0092  33 C0	 	 	 	XOR     AX,AX
 0094  8E D8	 	 	 	MOV     DS,AX               ;установить DS на таблицу векторов прерываний
 	 	 	 	assume DS:INT_TBL
 0096  A1 0004 R	 	 	MOV     AX,int1_ip         ;прочесть IP обработчика INT 1 (пошаговый режим)
 0099  36: A3 0000 R	 	 	MOV     SS:bckp_int1_ip,AX  ;сохранить IP INT 1 в области данных эмулятора (E800:0000)
 009D  A1 0006 R	 	 	MOV     AX,int1_cs         ;прочесть CS обработчика INT 1 (пошаговый режим)
 00A0  36: A3 0002 R	 	 	MOV     SS:bckp_int1_cs,AX  ;сохранить CS INT 1 в области данных эмулятора (E800:0002)
 00A4  B8 002E R	 	 	MOV     AX,offset h_int1             
 00A7  A3 0004 R	 	 	MOV     int1_ip,AX
 00AA  8C 0E 0006 R	 	 	MOV     int1_cs,CS           ;установить обработчик прерывания пошагового режима INT1  на E000:02Eh
 00AE  1F	 	 	 	POP     DS
 	 	 	 	assume DS:DATA
 00AF  87 E5	 	 	 	XCHG    SP,BP
 	 	 	 	;теперь распределение в стеке такое
 	 	 	 	;[BP]=AX
 	 	 	 	;[BP+2]=IP
 	 	 	 	;[BP+4]=CS
 	 	 	 	;[BP+6]=FLAGS
 	 	 	 	;SP'=BP до прерывания
 00B1  8B 46 06	 	 	 	MOV     AX,[BP+06]          ;прочесть флаги, бывшие до прерывания
 00B4  36: A3 0004	 	 	MOV     SS:[0004],AX        ;сохранить старые флаги в E800:0004
 00B8  C6 46 07 F1	 	 	MOV     BYTE PTR [BP+07],0F1h ;уст старшие флаги: режим без int 07h на ESC, реальный, OF,DF,IF=0, TF=1 (пошаговый режим ВКЛ)
 00BC  FF 4E 02	 	 	 	DEC     WORD PTR [BP+02]    ;уст IP на байт опкода, вызвавшего прерывание
 00BF  E4 C8	 	 	 	IN      AL,0C8h             ;c8h - порт информации о команде 1843вг1
 00C1  8A E0	 	 	 	MOV     AH,AL
 00C3  E4 C8	 	 	 	IN      AL,0C8h
 00C5  F6 C4 0F	 	 	 	TEST    AH,0Fh              ;были ли сегментные префиксы?
 00C8  74 03	 	 	 	JZ      nopref              ;нет - уйти на CD
 00CA  FF 4E 02	 	 	 	DEC     WORD PTR [BP+02]    ;были - сделать IP указывающим на префикс (начало команды)
 00CD  87 E5	 	 	nopref: XCHG    SP,BP
 00CF  E4 62	 	 	 	IN      AL,62h              ;2-й порт конфигурации компьютера
 00D1  24 D7	 	 	 	AND     AL,0D7h             ;сбросить бит 5 (????пусть кнопка TURBO переключает синхронизацию) и 3 (сопроцессор не установлен?) 
 	 	 	 	                                    ;- но в бит 3 запись невозможна
 00D3  E6 62	 	 	 	OUT     62h,AL
 00D5  A8 10	 	 	 	TEST    AL,10h              ;частота сопроцессора 8МГц?
 00D7  75 0A	 	 	 	JNZ     exit7               ;да - уйти на 0E3
 00D9  E4 61	 	 	 	IN      AL,61h              ;иначе прочесть 1-й порт конфигурации компьютера 
 00DB  A8 10	 	 	 	TEST    AL,10h              ;режим синхронизатора 8МГц?
 00DD  74 04	 	 	 	JZ      exit7               ;нет - уйти на 0E3
 00DF  E6 E0	 	 	 	OUT     0E0h,AL             ;иначе переключить синхронизатор
 00E1  EB 00	 	 	 	JMP     $+2                 ;очистить очередь команд
 00E3  F1	 	 	exit7:	DB      0F1h
 00E4  FC	 	 	 	CLD                         ;ОТКЛЮЧИТЬ int 07 на каждую ESC команду
 00E5  58	 	 	 	POP     AX
 00E6  CF	 	 	 	IRET                        ;рестарт команды (теперь ее исполнит сопроцессор)
 00E7	 	 	 	h_int7 endp
 	 	 	 	
 	 	 	 	;обработчик сдвигов SHIFT immediate
 	 	 	 	;формат команд:
 	 	 	 	;(SHIFT) reg/mem,immed8 
 	 	 	 	;первый байт:
 	 	 	 	;C0 - сдвигаемый операнд 8 бит
 	 	 	 	;С1 - сдвигаемый операнд 16 бит
 	 	 	 	;второй байт: mod-reg-rm
 	 	 	 	;тип сдвига определяется reg:
 	 	 	 	;000 - ROL
 	 	 	 	;001 - ROR
 	 	 	 	;010 - RCL
 	 	 	 	;011 - RCR
 	 	 	 	;100 - SHL
 	 	 	 	;101 - SHR
 	 	 	 	;110 - SHL, как и для 100 (а по справочникам - ничего)
 	 	 	 	;111 - SAR
 	 	 	 	;mod и rm аналогичны обычной кодировке для одноадресных команд
 	 	 	 	;последний байт - число, на которое нужно сдвинуть
 00E7	 	 	 	h_SHIFT proc near
 00E7  80 CC 02	 	 	 	OR      AH,02               ;установить, что это команда SHIFT, для дальнейшей обработки
 00EA  C4 5E 14	 	 	 	LES     BX,[BP+0014h]       ;BX указ. на след. за опкодом байт обрабатываемой команды          
 00ED  8C C1	 	 	 	MOV     CX,ES               ;ES=CX= CS обрабатываемой команды
 00EF  E8 0204 R	 	 	CALL    h_ADRMODE           ;возвращает адрес первого операнда в SI и сегмент операнда в ES
 00F2  E8 01D4 R	 	 	CALL    fetch_arg2          ;возвращает второй операнд в CL или CX
 00F5  E8 01B2 R	 	 	CALL    fetch_arg1          ;возвращает первый операнд в DL или DX
 00F8  80 E1 1F	 	 	 	AND     CL,01Fh             ;ограничить величину сдвига
 00FB  8B F8	 	 	 	MOV     DI,AX
 00FD  81 E7 0038	 	 	AND     DI,38h              ;вычленяем из mod-reg-rm команды только reg
 0101  D1 EF	 	 	 	SHR     DI,1
 0103  D1 EF	 	 	 	SHR     DI,1                ;превратили reg в указатель при переходе 
 0105  F6 C4 01	 	 	 	TEST    AH,01               ;8 или 16 бит команда?
 0108  50	 	 	 	PUSH    AX
 0109  8A 66 18	 	 	 	MOV     AH,[BP+0018h]       ;старые флаги
 010C  74 06	 	 	 	JZ      shft8               ;8 бит - уйти на 115
 010E  9E	 	 	 	SAHF                        ;записать старые флаги (мл.часть)
 010F  2E: FF A5 0507 R	 	 	JMP     CS:[DI+SHIFTABLE16] ;переход по таблице сдвига в 16-разрядном случае
 	 	 	 	
 	 	 	 	                            ;8-разр. случай
 0114  9E	 	 	shft8:	SAHF                        ;записать старые флаги (мл.часть)
 0115  2E: FF A5 0517 R	 	 	JMP     CS:[DI+SHIFTABLE8]  ;переход по таблице сдвига в 8-разрядном случае
 	 	 	 	
 	 	 	 	;8-битный операнд
 011A  D2 C2	 	 	ROL8:	ROL     DL,CL               ;000
 011C  EB 4C 90	 	 	 	JMP     set_flag
 011F  90	 	 	 	NOP
 0120  D2 CA	 	 	ROR8:	ROR     DL,CL               ;001
 0122  EB 46 90	 	 	 	JMP     set_flag
 0125  90	 	 	 	NOP
 0126  D2 D2	 	 	RCL8:	RCL     DL,CL               ;010
 0128  EB 40 90	 	 	 	JMP     set_flag
 012B  90	 	 	 	NOP
 012C  D2 DA	 	 	RCR8:	RCR     DL,CL               ;011
 012E  EB 3A 90	 	 	 	JMP     set_flag
 0131  90	 	 	 	NOP
 0132  D2 E2	 	 	SHL8:	SHL     DL,CL               ;100 и 110
 0134  EB 34 90	 	 	 	JMP     set_flag
 0137  90	 	 	 	NOP
 0138  D2 EA	 	 	SHR8:	SHR     DL,CL               ;101
 013A  EB 2E 90	 	 	 	JMP     set_flag
 013D  90	 	 	 	NOP
 013E  D2 FA	 	 	SAR8:	SAR     DL,CL               ;111
 0140  EB 28 90	 	 	 	JMP     set_flag
 0143  90	 	 	 	NOP
 	 	 	 	
 	 	 	 	;16-битный операнд
 0144  D3 C2	 	 	ROL16:	ROL     DX,CL               ;000
 0146  EB 22 90	 	 	 	JMP     set_flag                    
 0149  90	 	 	 	NOP                             
 014A  D3 CA	 	 	ROR16:	ROR     DX,CL               ;001
 014C  EB 1C 90	 	 	 	JMP     set_flag                    
 014F  90	 	 	 	NOP                             
 0150  D3 D2	 	 	RCL16:	RCL     DX,CL               ;010
 0152  EB 16 90	 	 	 	JMP     set_flag                    
 0155  90	 	 	 	NOP                             
 0156  D3 DA	 	 	RCR16:	RCR     DX,CL               ;011
 0158  EB 10 90	 	 	 	JMP     set_flag                    
 015B  90	 	 	 	NOP                             
 015C  D3 E2	 	 	SHL16:	SHL     DX,CL               ;100 и 110
 015E  EB 0A 90	 	 	 	JMP     set_flag                    
 0161  90	 	 	 	NOP                             
 0162  D3 EA	 	 	SHR16:	SHR     DX,CL               ;101
 0164  EB 04 90	 	 	 	JMP     set_flag                    
 0167  90	 	 	 	NOP                             
 0168  D3 FA	 	 	SAR16:	SAR     DX,CL               ;111
 	 	 	 	 	
 	 	 	 	;запись в сохраненный в теневом стеке регистр флагов, запись результата и выход
 016A	 	 	 	set_flag:
 016A  9F	 	 	 	LAHF                        ;выгрузить младшие флаги после сдвига в AH
 016B  8A 46 19	 	 	 	MOV     AL,[BP+0019h]       ;прочесть старшие флаги из стека (какие были до команды)
 016E  70 1C	 	 	 	JO      set_OF              ;OF хранится в старших флагах, он уст? да - 183
 0170  24 F7	 	 	 	AND     AL,0F7h             ;нет - сбросить OF=0
 0172  86 E0	 	 	wr_fl:	XCHG    AH,AL
 0174  89 46 18	 	 	 	MOV     [BP+0018h],AX       ;записать в стек правильное значение флагов после сдвига
 0177  58	 	 	 	POP     AX                  ;восстановить первый байт команды в AL и AH (с уст. битом 1)
 0178  E8 0190 R	 	 	CALL    write_result        ;записать результат сдвига в память или регистр
 017B  A1 0006 R	 	 	MOV     AX,cmd_len        ;прочесть полную длину операндов команды из E800:6
 017E  01 46 14	 	 	 	ADD     [BP+0014h],AX       ;увеличить IP на эту длину, чтобы он указывал на след команду 
 0181  C6 06 0005 R 00	 	 	MOV     BYTE PTR [reg_or_mem],00  ;очистить E800:5, т.к. не инициализируется при входе - для последующих команд
 0186  8B E5	 	 	 	MOV     SP,BP               ;восстановить указатель стека на сохраненные при входе регистры
 0188  07	 	 	 	POP     ES
 0189  61	 	 	 	POPA
 018A  1F	 	 	 	POP     DS                  ;восстановить регистры
 018B  CF	 	 	 	IRET                        ;закончить обработку команды, восстановить CS и SS
 	 	 	 	
 018C  0C 08	 	 	set_of: OR      AL,08               ;установить OF=1
 018E  EB E2	 	 	 	JMP     wr_fl
 	 	 	 	
 0190	 	 	 	write_result:
 	 	 	 	;запись результата сдвига в требуемое место (туда же, где был и источник)
 0190  F6 06 0005 R 02	 	 	TEST    BYTE PTR [reg_or_mem],02  ;операнд находится в памяти или в регистре?
 0195  90	 	 	 	NOP
 0196  75 0D	 	 	 	JNZ     wr_mem              ;в памяти - уйти на 019С
 0198  F6 C4 01	 	 	 	TEST    AH,01               ;8 или 16 бит операнд?
 019B  74 04	 	 	 	JZ      wr8reg              ;8 бит - уйти на 0198                                                                       
 019D  89 52 10	 	 	 	MOV     [BP+SI+10h],DX      ;запись результата в 16-бит регистр
 	 	 	 	 	                            ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
 01A0  C3	 	 	 	RET
 	 	 	 	                         
 01A1  88 52 10	 	 	wr8reg: MOV     [BP+SI+10h],DL       ;запись результата в 8-бит регистр
 	 	 	 	 	                            ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
 01A4  C3	 	 	 	RET
 01A5	 	 	 	wr_mem:	                            ;запись в память
 01A5  F6 C4 01	 	 	 	TEST    AH,01               ;8 или 16 бит операнд?
 01A8  74 04	 	 	 	JZ      wr8mem              ;8 бит - уйти на 01A5 
 01AA  26: 89 14	 	 	MOV     ES:[SI],DX          ;запись слова результата в память
 01AD  C3	 	 	 	RET
 	 	 	 	
 01AE  26: 88 14	 	wr8mem:	MOV     ES:[SI],DL          ;запись байта результата в память
 01B1  C3	 	 	 	RET
 01B2	 	 	 	h_SHIFT endp
 	 	 	 	
 	 	 	 	
 	 	 	 	;осуществляет выборку операнда в регистр DL либо DX
 	 	 	 	;вызывается третьим после 01FB, 01CB в обработчиках SHIFT и IMUL
 	 	 	 	;при вызове:
 	 	 	 	;ES указывает на правильный сегмент в памяти с учетом префиксов команды
 	 	 	 	;SI - адрес операнда
 01B2	 	 	 	fetch_arg1 proc near
 01B2  F6 06 0005 R 02	 	 	TEST    BYTE PTR [reg_or_mem],02  ;операнд находится в памяти или в регистре?
 01B7  90	 	 	 	NOP
 01B8  75 0D	 	 	 	JNZ     rd_mem              ;в памяти - уйти на 01BE
 	 	 	 	 	                            ;операнд в регистре
 01BA  F6 C4 01	 	 	 	TEST    AH,01               ;8 или 16 бит операнд?
 01BD  75 04	 	 	 	JNZ     rd16reg             ;16 бит - уйти на 01BA
 01BF  8A 52 10	 	 	 	MOV     DL,[BP+SI+10h]      ;выборка операнда из 8-бит регистра
 	 	 	 	 	                            ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
 01C2  C3	 	 	 	RET
 	 	 	 	
 01C3	 	 	 	rd16reg:
 01C3  8B 52 10	 	 	 	MOV     DX,[BP+SI+10h]      ;выборка операнда из 16-бит регистра
 01C6  C3	 	 	 	RET
 	 	 	 	        	                    ;выборка из памяти
 01C7  F6 C4 01	 	 	rd_mem:	TEST    AH,01               ;8 или 16 бит операнд?
 01CA  75 04	 	 	 	JNZ     rd16mem             ;16 бит - уйти на 01BA
 01CC  26: 8A 14	 	 	MOV     DL,ES:[SI]          ;выборка 8-бит операнда из памяти
 01CF  C3	 	 	 	RET
 	 	 	 	
 01D0	 	 	 	rd16mem:
 01D0  26: 8B 14	 	 	MOV     DX,ES:[SI]          ;выборка 16-бит операнда из памяти 
 01D3  C3	 	 	 	RET
 01D4	 	 	 	fetch_arg1 endp
 	 	 	 	
 	 	 	 	;выборка второго операнда команды в регистр CX или CL
 	 	 	 	;вызывается после h_ADRMODE в обработчиках SHIFT и IMUL
 	 	 	 	;при вызове:
 	 	 	 	;AL - первый байт команды, AH - первый байт команды с правками
 	 	 	 	;CX - CS команды, BX - указывает на следующий за опкодом байт команды
 	 	 	 	;плюс см. возвращаемое h_ADRMODE
 	 	 	 	;при возврате:
 	 	 	 	;E800:6 - реальная длина команды (увеличенная на байт или слово)
 	 	 	 	;CL/CX - второй операнд
 01D4	 	 	 	fetch_arg2 proc near 
 01D4  06	 	 	        PUSH    ES
 01D5  8E C1	 	 	 	MOV     ES,CX
 01D7  03 1E 0006 R	 	 	ADD     BX,cmd_len        ;передвинуть BX на байт, следующий за первым операндом команды
 01DB  F6 C4 01	 	 	 	TEST    AH,01               ;8 или 16 бит операнд? (для SHIFT)
 01DE  75 09	 	 	 	JNZ     arg16bit            ;16 бит - уйти на 1E0
 01E0  FE 06 0006 R	 	 	INC     BYTE PTR cmd_len  ;увеличить длину команды на байт
 01E4  26: 8A 0F	 	 	MOV     CL,ES:[BX]          ;прочесть байтовый второй операнд в CL
 01E7  07	 	 	 	POP     ES
 01E8  C3	 	 	 	RET
 01E9	 	 	 	arg16bit:
 01E9  F6 C4 02	 	 	 	TEST    AH,02               ;это команда SHIFT?
 01EC  74 0C	 	 	 	JZ      no_sft              ;нет - уйти на 1F1
 01EE  FE 06 0006 R	 	 	INC     BYTE PTR cmd_len  ;увеличить длину команды на байт
 01F2  26: 8A 0F	 	 	MOV     CL,ES:[BX]          ;прочесть байтовый второй операнд в CL
 01F5  91	 	 	 	XCHG    CX,AX
 01F6  98	 	 	 	CBW                         
 01F7  91	 	 	 	XCHG    CX,AX               ;превратить операнд в слово, сохраняя знак
 01F8  07	 	 	 	POP     ES
 01F9  C3	 	 	 	RET
 	 	 	 	
 	 	 	 	;не SHIFT и 16-бит
 01FA  80 06 0006 R 02	 	no_sft:	ADD     BYTE PTR cmd_len,02  ;увеличить длину команды на 2 байта
 01FF  26: 8B 0F	 	 	MOV     CX,ES:[BX]          ;прочесть слово второго операнда в CL
 0202  07	 	 	 	POP     ES
 0203  C3	 	 	 	RET
 0204	 	 	 	fetch_arg2 endp
 	 	 	 	
 	 	 	 	;выборка адреса операнда 
 	 	 	 	;вызывается во всех обработчиках, кроме ENTER
 	 	 	 	;при вызове:
 	 	 	 	;BX указывает на следующий за опкодом байт команды, 
 	 	 	 	;в ES и CX - CS команды
 	 	 	 	;DS указывает на E800, стек с E800:4000
 	 	 	 	;при возврате:
 	 	 	 	;SI - смещение операнда, если он в памяти, 
 	 	 	 	;и полуфабрикат для выборки регистра, если он в регистре
 	 	 	 	;ES - сегмент операнда
 	 	 	 	;AL - второй (mod-reg-rm) байт команды
 	 	 	 	;AH - первый (опкод) байт команды
 	 	 	 	;по адресу E800:5 значение:
 	 	 	 	;бит 0 установлен - адресация по регистру BP
 	 	 	 	;бит 1 установлен - операнд в памяти (не в регистре)
 	 	 	 	;по адресу E800:6 значение:
 	 	 	 	;1=регистровый операнд, непосредственный операнд
 	 	 	 	;2=слово смещения
 	 	 	 	;3=байт смещения
 	 	 	 	;позже это будет использоваться как информация о длине команды
 	 	 	 	
 0204	 	 	 	h_ADRMODE proc near
 0204  26: 8A 07	 	 	MOV     AL,ES:[BX]          ;прочитали второй (mod-reg-rm) байт команды, т.к. IP указывает на следующий за опкодом
 0207  3C C0	 	 	 	CMP     AL,0C0h             ;операнды находятся в памяти? (если да, то два старших бита не могут быть 11, т.е. меньше C0h)
 0209  72 23	 	 	 	JB      inmem               ;да - уйти на 223
 	 	 	 	        	                    ;нет - случай регистровых операндов
 	 	 	 	                	            ;формируем адрес нужного регистра, сохраненного в стеке, по полю reg
 	 	 	 	 	                            ;порядок регистров обратен по отношению к тому, как они сохранены по PUSHA
 	 	 	 	        	                    ;важно, что здесь мы НЕ получим истинного адреса регистра, а только полуфабрикат
 020B  C6 06 0006 R 01	 	 	MOV     BYTE PTR cmd_len,01
 0210  8B F0	 	 	 	MOV     SI,AX
 0212  F6 C4 01	 	 	 	TEST    AH,01               ;8 или 16 разрядный операнд?
 0215  74 09	 	 	 	JZ      inreg8              ;8 - уйти на 216
 0217  81 E6 0007	 	 	AND     SI,07h              ;оставить только три младших бита rm
 021B  D1 E6	 	 	 	SHL     SI,1                ;т.к. регистры в стеке расположены по словам
 021D  F7 DE	 	 	 	NEG     SI                  ;т.к. регистры идут в обратном порядке
 021F  C3	 	 	 	RET
 	 	 	 	
 	 	 	 	;8-разрядный операнд в регистре
 0220	 	 	 	inreg8:
 0220  81 E6 0003	 	 	AND     SI,03h              ;оставить только 2 младших бита rm
 0224  D1 E6	 	 	 	SHL     SI,1                ;т.к. регистры расположены по словам
 0226  F7 DE	 	 	 	NEG     SI                  ;т.к. регистры идут в обратном порядке
 0228  A8 04	 	 	 	TEST    AL,04               ;L-половинки или H-половинки регистров?
 022A  74 01	 	 	 	JZ      l_reg                
 022C  46	 	 	 	INC     SI                  ;H-половинки - адрес на 1 больше
 022D  C3	 	 	l_reg:	RET
 	 	 	 	
 	 	 	 	;операнды находятся в памяти
 022E  80 0E 0005 R 02	 	inmem:  OR      BYTE PTR [reg_or_mem],02
 0233  90	 	 	 	NOP
 0234  33 F6	 	 	 	XOR     SI,SI               
 0236  8A D0	 	 	 	MOV     DL,AL               ;mod-reg-rm -> DL
 0238  80 E2 C7	 	 	 	AND     DL,0C7h             ;обнулить поле reg
 023B  80 FA 06	 	 	 	CMP     DL,06               ;06=00-xxx-110 - это прямая адресация со смещ=0?
 023E  74 59	 	 	 	JZ      word_offset         ;да - уйти на 291
 0240  8B F8	 	 	 	MOV     DI,AX
 0242  81 E7 0007	 	 	AND     DI,07h              ;иначе использовать rm как индекс в таблице
 0246  D1 E7	 	 	 	SHL     DI,1                ;таблице слов, а не байт, т.ч. сдвинем на 1 разряд
 0248  2E: FF A5 04F7 R	 	 	JMP     CS:[DI+RM_TABLE]    ;переход по таблице обработчиков rm
 	 	 	 	
 	 	 	 	;обработка режимов косвенной адресации к памяти
 	 	 	 	;сюда (на разные строки) попадаем из таблицы на 04ffh
 	 	 	 	;если затрагивается BP, бит 1 E800:5 уст в 1
 024D  03 76 0A	 	 	RM0:	ADD     SI,[BP+000Ah]       ;точка входа rm=0: BX+SI+смещ (0A - адрес BX в стеке)
 0250  03 76 04	 	 	RM4:	ADD     SI,[BP+0004]        ;точка входа rm=4: SI+смещ (04 - адрес SI в стеке)
 0253  EB 28 90	 	 	 	JMP     check_offset
 0256  90	 	 	 	NOP
 0257  80 0E 0005 R 01	 	RM3:	OR      BYTE PTR [reg_or_mem],01  ;точка входа rm=3: BP+DI+смещ 
 025C  90	 	 	 	NOP
 025D  03 76 06	 	 	 	ADD     SI,[BP+0006]        ;06 - адрес BP в стеке
 0260  03 76 02	 	 	RM5:	ADD     SI,[BP+0002]        ;точка входа rm=5: DI+смещ (02 - адрес DI в стеке)
 0263  EB 18 90	 	 	 	JMP     check_offset
 0266  90	 	 	 	NOP
 0267  03 76 04	 	 	RM2:	ADD     SI,[BP+0004]        ;точка входа rm=2: BP+SI+смещ (04 - адрес SI в стеке)
 026A  03 76 06	 	 	RM6:	ADD     SI,[BP+0006]        ;точка входа rm=6: BP+смещ (06 - адрес BP в стеке)
 026D  80 0E 0005 R 01	 	 	OR      BYTE PTR [reg_or_mem],01
 0272  90	 	 	 	NOP
 0273  EB 08 90	 	 	 	JMP     check_offset
 0276  90	 	 	 	NOP     	
 0277  03 76 02	 	 	RM1:	ADD     SI,[BP+0002]        ;точка входа rm=1: BX+DI+смещ (02 - адрес DI в стеке)
 027A  03 76 0A	 	 	RM7:	ADD     SI,[BP+000Ah]       ;точка входа rm=7: BX+смещ (0A - адрес BX в стеке)
 	 	 	 	
 	 	 	 	;общая часть обработки косвенной адресации после прибавления значений регистров
 027D	 	 	 	check_offset:
 027D  A8 C0	 	 	 	TEST    AL,0C0h             ;mod 01,10? (есть смещение?)
 027F  74 27	 	 	 	JZ      no_offset           ;нет - уйти на 29F
 0281  A8 28	 	 	 	TEST    AL,40               ;mod 01? (один байт смещения?)
 0283  74 14	 	 	 	JZ      word_offset         ;нет - уйти на 291
 	 	 	 	;считаем, что байт смещения один
 0285  8B D0	 	 	 	MOV     DX,AX               ;сохраняем КОП и mod-reg-rm
 0287  26: 8A 47 01	 	 	MOV     AL,ES:[BX+01]       ;читаем байт смещения
 028B  98	 	 	 	CBW                         ;превращаем в слово с учетом знака (т.к. прибавляем к 16бит регистру)
 028C  03 F0	 	 	 	ADD     SI,AX               ;прибавили смещение
 028E  8B C2	 	 	 	MOV     AX,DX               ;восстановили КОП и mod-reg-rm
 0290  C6 06 0006 R 02	 	 	MOV     BYTE PTR cmd_len,02
 0295  EB 16 90	 	 	 	JMP     check_pref          ;перейти к выбору сегмента
 0298  90	 	 	 	NOP
 	 	 	 	
 	 	 	 	;прямая адресация со смещением =0
 	 	 	 	;два байта смещения или непосредственная словная адресация
 0299	 	 	 	word_offset:
 0299  C6 06 0006 R 03	 	 	MOV     BYTE PTR cmd_len,03
 029E  26: 8B 57 01	 	 	MOV     DX,ES:[BX+01]       ;прочитать слово, следующее сразу за mod-reg-rm
 02A2  03 F2	 	 	 	ADD     SI,DX               ;прибавили его к SI (как смещение или как значение)
 02A4  EB 07 90	 	 	 	JMP     check_pref          ;перейти к выбору сегмента
 02A7  90	 	 	 	NOP
 	 	 	 	
 	 	 	 	;сюда попадем, если нет смещения
 02A8	 	 	 	no_offset:
 02A8  C6 06 0006 R 01	 	 	MOV     BYTE PTR cmd_len,01
 	 	 	 	
 	 	 	 	;установка регистра ES правильным сегментом для доступа к операнду
 02AD	 	 	 	check_pref:
 02AD  8A 16 0000 R	 	 	MOV     DL,BYTE PTR cmd_inf ;прочесть байт информации о команде, считанный из 1843вг1
 02B1  F6 C2 0F	 	 	 	TEST    DL,0Fh              ;были ли сегментные префиксы?
 02B4  75 15	 	 	 	JNZ     seg_pref            ;да - обработать
 02B6  F6 06 0005 R 01	 	 	TEST    BYTE PTR [reg_or_mem],01  ;использовали ли регистр BP?
 02BB  90	 	 	 	NOP
 02BC  75 04	 	 	 	JNZ     ss_pref             ;да - установить сегмент SS
 02BE	 	 	 	ds_pref:
 02BE  8E 46 12	 	 	 	MOV     ES,[BP+0012h]       ;установить ES значением DS, которое было до команды
 02C1  C3	 	 	 	RET
 	 	 	 	
 	 	 	 	;если использовался регистр BP либо был префикс SS,
 	 	 	 	;адресоваться нужно по сегменту стека, каким он был до вызова команды (в основной паре SS:SP)
 02C2	 	 	 	ss_pref:
 02C2  F1	 	 	 	DB      0F1h
 02C3  FA	 	 	 	CLI                         ;F1 FA - переключаемся на основную пару SS:SP
 02C4  8C D2	 	 	 	MOV     DX,SS               ;сохранили стековый сегмент
 02C6  F1	 	 	 	DB      0F1h
 02C7  FB	 	 	 	STI                         ;F1 FB - переключаемся обратно на теневую пару SS':SP'
 02C8  8E C2	 	 	 	MOV     ES,DX               ;установить ES значением SS, которое было до вызова команды
 02CA  C3	 	 	 	RET
 	 	 	 	
 	 	 	 	;обработка сегментных префиксов
 02CB	 	 	 	seg_pref:
 02CB  F6 C2 08	 	 	 	TEST    DL,08               ;есть префикс CS?
 02CE  90	 	 	 	NOP
 02CF  75 10	 	 	 	JNZ     cs_pref
 02D1  F6 C2 04	 	 	 	TEST    DL,04               ;есть префикс DS?
 02D4  90	 	 	 	NOP
 02D5  75 E7	 	 	 	JNZ     ds_pref
 02D7  F6 C2 02	 	 	 	TEST    DL,02               ;есть префикс ES?
 02DA  90	 	 	 	NOP
 02DB  74 E5	 	 	 	JZ      ss_pref             ;нет - значит префикс SS
 02DD  8E 46 00	 	 	 	MOV     ES,[BP+0000]        ;есть - установить ES значением ES, которое было до вызова команды
 02E0  C3	 	 	 	RET
 02E1	 	 	 	cs_pref:
 02E1  8E 46 16	 	 	 	MOV     ES,[BP+0016h]        ;установить ES значением CS, которое было до вызова команды
 02E4  C3	 	 	 	RET
 02E5	 	 	 	h_ADRMODE endp
 	 	 	 	
 	 	 	 	;обработчик ENTER
 	 	 	 	;команда создания стекового кадра процедуры
 	 	 	 	;формат: enter nvar, nest
 	 	 	 	;C8 iw 00 если ENTER nvar,0
 	 	 	 	;C8 iw ib если ENTER nvar,nest и nest<>0
 	 	 	 	;nvar - кол-во слов памяти под переменные
 	 	 	 	;nest - уровень вложенности процедуры
 	 	 	 	
 	 	 	 	;команда ENTER предполагает следующий формат стекового кадра
 	 	 	 	;(см. Морс С.П., Алберт Д.Д. Архитектура микропроцессора 80286. М.:Радио и связь, 1990 - стр.99):
 	 	 	 	;SS:BP указывает на начало (высший адрес) для стекового кадра
 	 	 	 	;[SS:BP], первый байт стекового кадра, содержит 
 	 	 	 	;"динамическую связь" - указатель на начало стекового кадра процедуры, вызвавшей данную
 	 	 	 	;[SS:BP-2] и далее содержат "индикаторы" - указатели на начало стекового кадра всех активных процедур:
 	 	 	 	;-процедура первого уровня вложенности содержит индикатор из одного слова, 
 	 	 	 	;  указывающий на свое же слово динамической связи (т.е. на следующее слово [SS:BP], высшее в кадре)
 	 	 	 	;-процедура второго уровня вложенности содержит индикатор из двух слов - 
 	 	 	 	;  [SS:BP-2] указывает на начало стекового кадра родительской процедуры,
 	 	 	 	;  [SS:BP-4] указывает на свое же слово динамической связи
 	 	 	 	;-процедура 3-го уровня вложенности содержит индикатор из трех слов - 
 	 	 	 	;  [SS:BP-2] - начало стекового кадра процедуры-дедушки, родительской для родительской
 	 	 	 	;  [SS:BP-4] - на начало стекового кадра родительской процедуры
 	 	 	 	;  [SS:BP-6] - на свое же слово динамической связи
 	 	 	 	;и так далее. Т.е n элементов индикатора стекового кадра процедуры уровня n+1
 	 	 	 	;аналогичны индикатору родительской процедуры.
 	 	 	 	;После индикаторов в стековом кадре располагается память под переменные.
 	 	 	 	;В книге Морса все пояснено на картинках и с примерами на Паскале.
 	 	 	 	
 	 	 	 	;команда ENTER обновляет BP (чтобы он указывал на начало созданного стекового кадра),
 	 	 	 	;SP (резервируя место в стеке под созданный кадр),
 	 	 	 	;и записывает в начало созданного стекового кадра "динамическую связь" и "индикатор"
 	 	 	 	
 02E5	 	 	 	h_ENTER proc near
 02E5  C4 5E 14	 	 	 	LES BX,[BP+0014h]     ;BX указ. на след. за опкодом байт обрабатываемой команды,ES:=CS команды
 02E8  26: 8B 17	 	 	MOV DX,ES:[BX]       ;DX:=nvar (кол-во байт памяти под переменные)                                
 02EB  26: 8A 4F 02	 	 	MOV CL,ES:[BX+02]    ;CL:=nest (уровень вложенности)                                           
 02EF  32 ED	 	 	 	XOR CH,CH                                                                                
 02F1  F1	 	 	 	DB 0F1h                                                                                    
 02F2  FA	 	 	 	CLI                  ;основной стек                                                                    
 02F3  8B FC	 	 	 	MOV DI,SP            ;DI:=SP указатель основного стека                                                                             
 	 	 	 	
 02F5  F1	 	 	 	DB 0F1h                                                                                    
 02F6  FB	 	 	 	STI                  ;обратно в теневой стек                                                                    
 02F7  8B 76 06	 	 	 	MOV SI,[BP+0006]     ;SI:=BP до команды ENTER (указатель на стековый кадр процедуры, вызвавшей данную)
 	 	 	 	     ;DS ранее был установлен на SS до команды ENTER (до входа в прерывание)
 02FA  8D 7D FE	 	 	 	LEA DI,[DI-02]       ;DI:=указатель на начало создаваемого стекового кадра
 02FD  89 7E 06	 	 	 	MOV [BP+0006],DI     ;установили BP-после-команды-ENTER на начало нового стекового кадра
 0300  F1	 	 	 	DB 0F1h                
 0301  FA	 	 	 	CLI                  ;основной стек                                                                    
 0302  8C D3	 	 	 	MOV BX,SS            ;BX:=SS сегмент основного стека
 0304  F1	 	 	 	DB 0F1h                                                                                    
 0305  FB	 	 	 	STI                  ;обратно в теневой стек
 0306  8E C3	 	 	 	MOV ES,BX            ;ES:=SS основного стека                                                                    
 0308  26: 89 35	 	 	MOV ES:[DI],SI          ;записали указатель на стековый кадр родительской (вызвавшей) процедуры в создаваемый стековый кадр
 030B  8B DF	 	 	 	MOV BX,DI            ;BX:=указатель на начало создаваемого стекового кадра
 030D  80 F9 00	 	 	 	CMP CL,00            ;уровень вложенности в команде ENTER =0?
 0310  74 15	 	 	 	JZ var_allocate      ;да - уйти на распределение стека под переменные
 	 	 	 	     ;случай ненулевой вложенности 
 0312  FD	 	 	 	STD                  ;строковые команды:= на уменьшение
 0313  1E	 	 	 	PUSH DS                                                                                  
 0314  06	 	 	 	PUSH ES                                                                                  
 0315  1F	 	 	 	POP DS               ;DS=ES:= SS основного стека
 0316  49	 	 	 	DEC CX               ;число элементов индикатора=уровню вложенности,
 	 	 	 	 	                     ;а нам нужно скопировать все элементы индикатора родительской процедуры, у нее уровень на 1 меньше
 0317  8D 74 FE	 	 	 	LEA SI,[SI-02]       ;SI:=смещение на начало индикатора родительской процедуры 
 	 	 	 	                             ;(на 1 слово меньше начала родительского стекового кадра, на которое указывал BP до команды ENTER)
 031A  8D 7D FE	 	 	 	LEA DI,[DI-02]       ;DI:=смещение в основном стеке под индикатор (еще один новый операнд уже после заталкивания туда BP)
 031D  80 F9 00	 	 	 	CMP CL,00            ;уровень вложенности 1? (в этом случае копировать нечего)                                                     
 	 	 	 	                         
 0320  74 02	 	 	 	JZ last_indic        ;да - уйти на запись последнего элемента индикатора
 0322  F3/ A5	 	 	 	REPZ MOVSW           ;скопировать индикатор родительской процедуры в создаваемый кадр
 0324	 	 	 	last_indic:                                                    
 0324  89 1D	 	 	 	MOV [DI],BX          ;записать в создаваемый кадр последний элемент индикатора для вложенности >0 - 
 	 	 	 	 	                     ;указатель на начало создаваемого стекового кадра
 0326  1F	 	 	 	POP DS               ;DS:=SS основного стека                                                                    
 0327	 	 	 	var_allocate:
 0327  2B FA	 	 	 	SUB DI,DX            ;продвинуть указатель основного стека (в DI) с учетом места в стековом кадре под кол-во переменных,
 	 	 	 	 	                     ;указанных в команде ENTER, под дин.связь и индикаторы указатель (DI) уже модифицирован
 0329  F1	 	 	 	DB 0F1h                                                                                    
 032A  FA	 	 	 	CLI                  ;основной стек
 032B  8B E7	 	 	 	MOV SP,DI            ;обновить непосредственно указатель основного стека                                                      
 032D  F1	 	 	 	DB 0F1h                                                                                    
 032E  FB	 	 	 	STI                  ;обратно в теневой стек
 032F  83 46 14 03	 	 	ADD WORD PTR [BP+0014h],+03 ;увеличить IP на длину команды
 	 	 	 	
 	 	 	 	;завершающий этап обработки команды ENTER
 	 	 	 	;полностью аналогичен концу обработки SHIFT (адрес 0178)
 	 	 	 	;т.е. просто лишний повтор
 0333  C6 06 0005 R 00	 	 	MOV     BYTE PTR [reg_or_mem],00
 0338  8B E5	 	 	 	MOV     SP,BP
 033A  07	 	 	 	POP     ES
 033B  61	 	 	 	POPA
 033C  1F	 	 	 	POP     DS
 033D  CF	 	 	 	IRET
 033E	 	 	 	h_ENTER endp
 	 	 	 	
 	 	 	 	;обработчик IMUL immediate
 033E	 	 	 	h_IMUL proc near
 033E  C4 5E 14	 	 	 	LES     BX,[BP+0014h]       ;BX указ. на след. за опкодом байт обрабатываемой команды
 0341  8C C1	 	 	 	MOV     CX,ES               ;ES=CX= CS обрабатываемой команды       
 0343  E8 0204 R	 	 	CALL    h_ADRMODE           ;возвращает адрес первого операнда в SI и сегмент операнда в ES
 0346  E8 01D4 R	 	 	CALL    fetch_arg2          ;возвращает второй операнд в CL или CX
 0349  E8 01B2 R	 	 	CALL    fetch_arg1          ;возвращает первый операнд в DL или DX         
 034C  91	 	 	 	XCHG    CX,AX               ;AX=второй (непосредственный) операнд, CX = первые 2 байта команды
 034D  F7 EA	 	 	 	IMUL    DX                  ;(DX,AX)=(AX)*(DX)
 034F  70 25	 	 	 	JO      set_OF_CF           ;есть переполнение?
 0351  81 66 18 F7FE	 	 	AND     WORD PTR [BP+0018h],0F7FEh    ;нет - сбросить OF и CF
 0356  8B F1	 	 	write:	MOV     SI,CX               ;SI=первые 2 байта команды (второй на младших адресах)
 0358  81 E6 0038	 	 	AND     SI,38h              ;высечь поле reg из mod-reg-rm
 035C  D1 EE	 	 	 	SHR     SI,1
 035E  D1 EE	 	 	 	SHR     SI,1                ;сдвинуть к началу регистра, с учетом того, что адресоваться по словам
 0360  F7 DE	 	 	 	NEG     SI                  ;т.к. регистры в поле reg идут в обратном порядке по отношению к стеку
 0362  89 42 10	 	 	 	MOV     [BP+SI+10h],AX      ;запись результата в 16-бит регистр
 	 	 	 	        	                    ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
 0365  A1 0006 R	 	 	MOV     AX,cmd_len        ;прочесть полную длину операндов команды из E800:6
 0368  01 46 14	 	 	 	ADD     [BP+0014h],AX        ;увеличить IP на эту длину, чтобы он указывал на след команду
 	 	 	 	
 	 	 	 	;завершающий этап обработки команды IMUL
 	 	 	 	;полностью аналогичен концу обработки SHIFT (адрес 0178)
 	 	 	 	;т.е. просто лишний повтор
 036B  C6 06 0005 R 00	 	 	MOV     BYTE PTR [reg_or_mem],00
 0370  8B E5	 	 	 	MOV     SP,BP
 0372  07	 	 	 	POP     ES
 0373  61	 	 	 	POPA
 0374  1F	 	 	 	POP     DS
 0375  CF	 	 	 	IRET
 	 	 	 	
 	 	 	 	;если получили флаг OF
 0376	 	 	 	set_OF_CF:
 0376  81 4E 18 0801	 	 	OR      WORD PTR [BP+0018h],0801h    ;установить OF и CF
 037B  EB D9	 	 	 	JMP     write
 037D	 	 	 	h_IMUL endp
 	 	 	 	
 	 	 	 	;обработчик BOUND
 	 	 	 	;формат команды:
 	 	 	 	;BOUND reg16 mem
 	 	 	 	;62 mod-reg-rm mem1 mem2
 	 	 	 	;поскольку команда двухадресная, mod-reg-rm указывает на второй аргумент
 037D	 	 	 	h_BOUND proc near
 037D  80 CC 01	 	 	 	OR      AH,01                      ;установить 16-бит тип операнда
 0380  C4 5E 14	 	 	 	LES     BX,[BP+0014h]              ;BX указ. на след. за опкодом байт обрабатываемой команды,ES:=CS команды
 0383  26: 80 3F BF	 	 	CMP     ES:BYTE PTR [BX],0BFh      ;операнд в регистре? (mod в mod-reg-rm = 11?)
 0387  77 27	 	 	 	JA      h_EXIT                     ;да - уйти на 3B2 (выход из команды)
 0389  E8 0204 R	 	 	CALL    h_ADRMODE                  ;возвращает адрес (???второго) операнда в SI и сегмент операнда в ES
 038C  26: 8B 0C	 	 	MOV     CX,ES:[SI]                 ;CX:= операнд из памяти - нижняя граница массива
 038F  26: 8B 54 02	 	 	MOV     DX,ES:[SI+02]              ;DX:= следующее за ним слово - верхняя граница массива
 0393  8B F0	 	 	 	MOV     SI,AX                      ;SI=первые 2 байта команды (второй на младших адресах)                                       
 0395  81 E6 0026	 	 	AND     SI,+38                     ;высечь поле reg из mod-reg-rm                                                              
 0399  D1 EE	 	 	 	SHR     SI,1                                                                                                                    
 039B  D1 EE	 	 	 	SHR     SI,1                       ;сдвинуть к началу регистра, с учетом того, что адресоваться по словам
 039D  F7 DE	 	 	 	NEG     SI                         ;т.к. регистры в поле reg идут в обратном порядке по отношению к стеку
 039F  8B 42 0A	 	 	 	MOV     AX,[BP+SI+10]              ;чтение операнда-регистра
 	 	 	 	 	                                   ;(смещение в SI - отрицательное, с 10h и менее в стеке располагаются РОН, BP - вершина стека)
 03A2  3B C8	 	 	 	CMP     CX,AX                      ;сравнение с нижней границей
 03A4  77 15	 	 	 	JA      em_INT5                    ;если вышли за нее (н.граница>числа) - уйти на 3BD
 03A6  3B C2	 	 	 	CMP     AX,DX                      ;сравнение с верхней границей
 03A8  77 11	 	 	 	JA      em_INT5                    ;если вышли за нее (число>в.границв) - уйти на 3BD
 03AA  A1 0006 R	 	 	MOV     AX,cmd_len                 ;иначе считать длину операндов команды
 03AD  01 46 14	 	 	 	ADD     [BP+0014h],AX              ;увеличить IP в стеке на эту длину, чтобы он указывал на начало след.команды
 	 	 	 	
 	 	 	 	;обработчик ненайденной команды 
 	 	 	 	;также завершающая фаза обработчика BOUND
 	 	 	 	;полностью аналогичен концу обработки SHIFT (адрес 0178)
 	 	 	 	;т.е. просто лишний повтор
 03B0	 	 	 	h_EXIT:
 03B0  C6 06 0005 R 00	 	 	MOV     BYTE PTR [reg_or_mem],00
 03B5  8B E5	 	 	 	MOV     SP,BP
 03B7  07	 	 	 	POP     ES
 03B8  61	 	 	 	POPA
 03B9  1F	 	 	 	POP     DS
 03BA  CF	 	 	 	IRET
 	 	 	 	
 	 	 	 	;BOUND: случай выхода за границу массива
 	 	 	 	;эмуляция действий процессора при вызове INT 5 
 03BB	 	 	 	em_INT5:
 03BB  8B 46 14	 	 	 	MOV     AX,[BP+0014h]              ;считать IP в стеке (указывающий на второй байт эмулируемой команды)
 03BE  48	 	 	 	DEC     AX                         ;теперь IP указывает на опкод
 03BF  F6 06 0001 R 0F	 	 	TEST    BYTE PTR cmd_inf+1,0Fh     ;были ли префиксы у команды?
 03C4  74 01	 	 	 	JZ      get_CS
 03C6  48	 	 	 	DEC     AX                         ;если были префиксы, сделать IP указывающим на байт префикса
 	 	 	 	        	                           ;теперь IP точно указывает на начало команды
 03C7  8B 5E 16	 	 	get_CS: MOV     BX,[BP+0016h]              ;BX:=CS команды
 03CA  8B 4E 18	 	 	 	MOV     CX,[BP+0018h]              ;CX:=флаги команды
 03CD  F1	 	 	 	DB      0F1h
 03CE  FA	 	 	 	CLI                                ;переключаемся на основную пару SS:SP
 03CF  51	 	 	 	PUSH    CX                         ;как бы pushf
 03D0  53	 	 	 	PUSH    BX                         ;как бы push cs
 03D1  50	 	 	 	PUSH    AX                         ;как бы push ip - все в основном стеке, как при уходе на прерывание
 03D2  F1	 	 	 	DB      0F1h
 03D3  FB	 	 	 	STI                                ;обратно на теневую пару SS':SP'
 03D4  33 C0	 	 	 	XOR     AX,AX
 03D6  8E C0	 	 	 	MOV     ES,AX                      ;ES указывает на таблицу векторов прерываний
 03D8  26: A1 0014 R	 	 	MOV     AX,ES:int5_ip              ;14h=20=5*4, начало записи для INT 5 в таблице векторов
 03DC  89 46 14	 	 	 	MOV     [BP+0014h],AX              ;IP стека эмулятора:= IP обработчика INT 5
 03DF  26: A1 0016 R	 	 	MOV     AX,ES:int5_cs
 03E3  89 46 16	 	 	 	MOV     [BP+0016h],AX              ;CS стека эмулятора:= CS обработчика INT 5
 03E6  80 66 19 FC	 	 	AND     BYTE PTR [BP+0019h],0FCh   ;сбросить IF и TF во флагах в стеке, как при уходе на прерывание
 03EA  90	 	 	 	NOP
 03EB  EB C3	 	 	 	JMP     h_EXIT                     ;возврат из эмулятора
 03ED	 	 	 	h_BOUND endp
 	 	 	 	
 	 	 	 	;таблица адресов программ эмуляции команд
 	 	 	 	;адрес в таблице соответствует опкоду
 03ED	 	 	 	OP_table label byte
 03ED  0100 [	 	 	 	db	256 DUP (0)
                00	 	
                    ]	 	
 	 	 	 	
 044F	 	 	 	org offset OP_table+62h
 044F  02	 	 	 	db	02                         ;62h - BOUND
 0456	 	 	 	org offset OP_table+69h
 0456  04	 	 	 	db	04                         ;69h - IMUL immediate
 0458	 	 	 	org offset OP_table+6bh
 0458  04	 	 	 	db	04                         ;6bh - IMUL S immediate
 04AD	 	 	 	org offset OP_table+0c0h
 04AD  06	 	 	 	db	06                         ;c0h - SHIFT immediate  
 04AE  06	 	 	 	db	06                         ;c1h - SHIFT immediate               
 04B5	 	 	 	org offset OP_table+0c8h
 04B5  08	 	 	 	db	08                         ;c8h - ENTER
 04ED	 	 	 	org offset OP_table+256
 	 	 	 	
 	 	 	 	;таблица адресов обработчиков команд
 04ED	 	 	 	CMD_TABLE label word
 04ED  03B0 R	 	 	 	DW      offset h_EXIT              ;обработчик ненайденной команды
 04EF  037D R	 	 	 	DW      offset h_BOUND             ;обрабочик BOUND (смещ.2)
 04F1  033E R	 	 	 	DW      offset h_IMUL              ;обработчик IMUL (смещ.4)
 04F3  00E7 R	 	 	 	DW      offset h_SHIFT             ;обработчик сдвигов (смещ.6)
 04F5  02E5 R	 	 	 	DW      offset h_ENTER             ;обработчик ENTER (смещ.8)
 	 	 	 	
 	 	 	 	;таблица адресов обработчиков режимов косвенной адресации rm  (mod=00,01,10)
 04F7	 	 	 	RM_TABLE label word
 04F7  024D R	 	 	 	DW      offset RM0                 ;rm=0
 04F9  0277 R	 	 	 	DW      offset RM1                 ;rm=1
 04FB  0267 R	 	 	 	DW      offset RM2                 ;rm=2
 04FD  0257 R	 	 	 	DW      offset RM3                 ;rm=3
 04FF  0250 R	 	 	 	DW      offset RM4                 ;rm=4
 0501  0260 R	 	 	 	DW      offset RM5                 ;rm=5
 0503  026A R	 	 	 	DW      offset RM6                 ;rm=6
 0505  027A R	 	 	 	DW      offset RM7                 ;rm=7
 	 	 	 	
 	 	 	 	;таблица адресов обработчиков команд сдвига в 16-разрядном случае
 	 	 	 	;NB! по справочнику Морса reg=6 (010) не используется,
 	 	 	 	;а здесь reg=6 аналогично reg=4 (100) 
 0507	 	 	 	SHIFTABLE16 label word
 0507  0144 R	 	 	 	DW      offset ROL16               ;000 - ROL   
 0509  014A R	 	 	 	DW      offset ROR16               ;001 - ROR   
 050B  0150 R	 	 	 	DW      offset RCL16               ;010 - RCL   
 050D  0156 R	 	 	 	DW      offset RCR16               ;011 - RCR   
 050F  015C R	 	 	 	DW      offset SHL16               ;100 - SHL   
 0511  0162 R	 	 	 	DW      offset SHR16               ;101 - SHR   
 0513  015C R	 	 	 	DW      offset SHL16               ;110 - ничего
 0515  0168 R	 	 	 	DW      offset SAR16               ;111 - SAR   
 	 	 	 	
 	 	 	 	;таблица адресов обработчиков команд сдвига в 8-разрядном случае
 	 	 	 	;NB! по справочнику Морса reg=6 (010) не используется,
 	 	 	 	;а здесь reg=6 аналогично reg=4 (100) 
 0517	 	 	 	SHIFTABLE8 label word
 0517  011A R	 	 	 	DW      offset ROL8               ;000 - ROL   
 0519  0120 R	 	 	 	DW      offset ROR8               ;001 - ROR   
 051B  0126 R	 	 	 	DW      offset RCL8               ;010 - RCL   
 051D  012C R	 	 	 	DW      offset RCR8               ;011 - RCR   
 051F  0132 R	 	 	 	DW      offset SHL8               ;100 - SHL   
 0521  0138 R	 	 	 	DW      offset SHR8               ;101 - SHR   
 0523  0132 R	 	 	 	DW      offset SHL8               ;110 - ничего
 0525  013E R	 	 	 	DW      offset SAR8               ;111 - SAR   
 	 	 	 	
 	 	 	 	;располагается по адресу 052Fh и вероятно возник из-за выравнивания следующего сегмента по слову или параграфу
 0527  00	 	 	 	DB      00h
 	 	 	 	
 0528	 	 	 	_TEXT ends
 	 	 	 	
 	 	 	 	
 0000	 	 	 	STACK segment para 'STACK'
 	 	 	 	;этого в памяти эмулятора уже не будет, это пойдет в E800:0
 0000     08 [	 	 	 	DB	8 dup (0)
                00	 	
                    ]	 	
 	 	 	 	
 0008	 	 	 	STACK ends
 	 	 	 	end h_int6


Segments and Groups:

	 	N a m e	 	 	Size	Align	Combine	Class

DATA . . . . . . . . . . . . . .	0008	AT    	E800	
INT_TBL. . . . . . . . . . . . .	0018	AT    	0000	
SHADOW_STAC. . . . . . . . . . .	001A	AT    	EC00	
STACK. . . . . . . . . . . . . .	0008	PARA  	NONE	'STACK'
_TEXT. . . . . . . . . . . . . .	0528	WORD  	PUBLIC	'CODE'

Symbols:            

	 	N a m e	 	 	Type	Value	Attr         

ARG16BIT . . . . . . . . . . . .	L NEAR 	01E9	_TEXT
BCKP_INT1_CS . . . . . . . . . .	Alias	CMD_WORD	 	
BCKP_INT1_IP . . . . . . . . . .	Alias	CMD_INF	 	
CHECK_OFFSET . . . . . . . . . .	L NEAR 	027D	_TEXT
CHECK_PREF . . . . . . . . . . .	L NEAR 	02AD	_TEXT
CMD_INF. . . . . . . . . . . . .	L WORD 	0000	DATA
CMD_LEN. . . . . . . . . . . . .	L WORD 	0006	DATA
CMD_TABLE. . . . . . . . . . . .	L WORD 	04ED	_TEXT
CMD_WORD . . . . . . . . . . . .	L WORD 	0002	DATA
CS_PREF. . . . . . . . . . . . .	L NEAR 	02E1	_TEXT
DS_PREF. . . . . . . . . . . . .	L NEAR 	02BE	_TEXT
EM_INT5. . . . . . . . . . . . .	L NEAR 	03BB	_TEXT
ENDNMI . . . . . . . . . . . . .	L NEAR 	0072	_TEXT
EXIT7. . . . . . . . . . . . . .	L NEAR 	00E3	_TEXT
FETCH_ARG1 . . . . . . . . . . .	N PROC	01B2	_TEXT	Length =0022
FETCH_ARG2 . . . . . . . . . . .	N PROC	01D4	_TEXT	Length =0030
GET_CS . . . . . . . . . . . . .	L NEAR 	03C7	_TEXT
H_ADRMODE. . . . . . . . . . . .	N PROC	0204	_TEXT	Length =00E1
H_BOUND. . . . . . . . . . . . .	N PROC	037D	_TEXT	Length =0070
H_ENTER. . . . . . . . . . . . .	N PROC	02E5	_TEXT	Length =0059
H_EXIT . . . . . . . . . . . . .	L NEAR 	03B0	_TEXT
H_IMUL . . . . . . . . . . . . .	N PROC	033E	_TEXT	Length =003F
H_INT1 . . . . . . . . . . . . .	F PROC	002E	_TEXT	Length =0062
H_INT6 . . . . . . . . . . . . .	F PROC	0000	_TEXT	Length =002B
H_INT7 . . . . . . . . . . . . .	F PROC	0090	_TEXT	Length =0057
H_SHIFT. . . . . . . . . . . . .	N PROC	00E7	_TEXT	Length =00CB
INMEM. . . . . . . . . . . . . .	L NEAR 	022E	_TEXT
INREG8 . . . . . . . . . . . . .	L NEAR 	0220	_TEXT
INT1_CS. . . . . . . . . . . . .	L WORD 	0006	INT_TBL
INT1_IP. . . . . . . . . . . . .	L WORD 	0004	INT_TBL
INT5_CS. . . . . . . . . . . . .	L WORD 	0016	INT_TBL
INT5_IP. . . . . . . . . . . . .	L WORD 	0014	INT_TBL
IRQ13. . . . . . . . . . . . . .	L NEAR 	0074	_TEXT
LAST_INDIC . . . . . . . . . . .	L NEAR 	0324	_TEXT
L_REG. . . . . . . . . . . . . .	L NEAR 	022D	_TEXT
NMIGEN . . . . . . . . . . . . .	L NEAR 	008C	_TEXT
NOPREF . . . . . . . . . . . . .	L NEAR 	00CD	_TEXT
NO_OFFSET. . . . . . . . . . . .	L NEAR 	02A8	_TEXT
NO_SFT . . . . . . . . . . . . .	L NEAR 	01FA	_TEXT

OP_TABLE . . . . . . . . . . . .	L BYTE 	03ED	_TEXT
RCL16. . . . . . . . . . . . . .	L NEAR 	0150	_TEXT
RCL8 . . . . . . . . . . . . . .	L NEAR 	0126	_TEXT
RCR16. . . . . . . . . . . . . .	L NEAR 	0156	_TEXT
RCR8 . . . . . . . . . . . . . .	L NEAR 	012C	_TEXT
RD16MEM. . . . . . . . . . . . .	L NEAR 	01D0	_TEXT
RD16REG. . . . . . . . . . . . .	L NEAR 	01C3	_TEXT
RD_MEM . . . . . . . . . . . . .	L NEAR 	01C7	_TEXT
REG_OR_MEM . . . . . . . . . . .	L BYTE 	0005	DATA
RM0. . . . . . . . . . . . . . .	L NEAR 	024D	_TEXT
RM1. . . . . . . . . . . . . . .	L NEAR 	0277	_TEXT
RM2. . . . . . . . . . . . . . .	L NEAR 	0267	_TEXT
RM3. . . . . . . . . . . . . . .	L NEAR 	0257	_TEXT
RM4. . . . . . . . . . . . . . .	L NEAR 	0250	_TEXT
RM5. . . . . . . . . . . . . . .	L NEAR 	0260	_TEXT
RM6. . . . . . . . . . . . . . .	L NEAR 	026A	_TEXT
RM7. . . . . . . . . . . . . . .	L NEAR 	027A	_TEXT
RM_TABLE . . . . . . . . . . . .	L WORD 	04F7	_TEXT
ROL16. . . . . . . . . . . . . .	L NEAR 	0144	_TEXT
ROL8 . . . . . . . . . . . . . .	L NEAR 	011A	_TEXT
ROR16. . . . . . . . . . . . . .	L NEAR 	014A	_TEXT
ROR8 . . . . . . . . . . . . . .	L NEAR 	0120	_TEXT
SAR16. . . . . . . . . . . . . .	L NEAR 	0168	_TEXT
SAR8 . . . . . . . . . . . . . .	L NEAR 	013E	_TEXT
SAVED_AX . . . . . . . . . . . .	L WORD 	0010	SHADOW_STAC
SAVED_BP . . . . . . . . . . . .	L WORD 	0006	SHADOW_STAC
SAVED_BX . . . . . . . . . . . .	L WORD 	000A	SHADOW_STAC
SAVED_CS . . . . . . . . . . . .	L WORD 	0016	SHADOW_STAC
SAVED_CX . . . . . . . . . . . .	L WORD 	000E	SHADOW_STAC
SAVED_DI . . . . . . . . . . . .	L WORD 	0002	SHADOW_STAC
SAVED_DS . . . . . . . . . . . .	L WORD 	0012	SHADOW_STAC
SAVED_DX . . . . . . . . . . . .	L WORD 	000C	SHADOW_STAC
SAVED_ES . . . . . . . . . . . .	L WORD 	0000	SHADOW_STAC
SAVED_FLAGS. . . . . . . . . . .	L WORD 	0018	SHADOW_STAC
SAVED_IP . . . . . . . . . . . .	L WORD 	0014	SHADOW_STAC
SAVED_SI . . . . . . . . . . . .	L WORD 	0004	SHADOW_STAC
SAVED_SP . . . . . . . . . . . .	L WORD 	0008	SHADOW_STAC
SEG_PREF . . . . . . . . . . . .	L NEAR 	02CB	_TEXT
SET_FLAG . . . . . . . . . . . .	L NEAR 	016A	_TEXT
SET_OF . . . . . . . . . . . . .	L NEAR 	018C	_TEXT
SET_OF_CF. . . . . . . . . . . .	L NEAR 	0376	_TEXT
SHFT8. . . . . . . . . . . . . .	L NEAR 	0114	_TEXT
SHIFTABLE16. . . . . . . . . . .	L WORD 	0507	_TEXT
SHIFTABLE8 . . . . . . . . . . .	L WORD 	0517	_TEXT
SHL16. . . . . . . . . . . . . .	L NEAR 	015C	_TEXT
SHL8 . . . . . . . . . . . . . .	L NEAR 	0132	_TEXT
SHR16. . . . . . . . . . . . . .	L NEAR 	0162	_TEXT
SHR8 . . . . . . . . . . . . . .	L NEAR 	0138	_TEXT
SS_PREF. . . . . . . . . . . . .	L NEAR 	02C2	_TEXT
VAR_ALLOCATE . . . . . . . . . .	L NEAR 	0327	_TEXT
WORD_OFFSET. . . . . . . . . . .	L NEAR 	0299	_TEXT
WR8MEM . . . . . . . . . . . . .	L NEAR 	01AE	_TEXT
WR8REG . . . . . . . . . . . . .	L NEAR 	01A1	_TEXT

WRITE. . . . . . . . . . . . . .	L NEAR 	0356	_TEXT
WRITE_RESULT . . . . . . . . . .	L NEAR 	0190	_TEXT
WR_FL. . . . . . . . . . . . . .	L NEAR 	0172	_TEXT
WR_MEM . . . . . . . . . . . . .	L NEAR 	01A5	_TEXT

46538 Bytes free   

Warning Severe
Errors	Errors 
0	0
